{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Hosting Git Repositories \uf0c1 Gitolite allows you to setup git hosting on a central server, with fine-grained access control and many more powerful features. install/setup \uf0c1 If you're installing via your package manager, make sure you get the right one; it's often called gitolite3 . Source code is at https://github.com/sitaramc/gitolite . If your Unix-fu and ssh-fu are good, take a look at the quick install page. Otherwise follow the documentation flow, skipping whatever you think you don't need. documentation \uf0c1 (April 2014): There's a book on gitolite out . I've received some emails over the years asking where to donate for gitolite to show your appreciation, and I've always refused politely. Well, if you insist... buy the book :-) In general, the sections (see links in the navigation bar at the top) should be fairly self-explanatory, and reading through the documentation as it flows (i.e., using the \"Next\" link at the top right of each page) should work fine. There are some forward references here and there, but you can ignore those links on a first pass. In addition: There's a fool proof setup guide with detailed help showing one fool-proof way to install, as long as you follow instructions faithfully! Once you've installed and setup, there's the cookbook with recipes for common tasks. TROUBLESHOOTING \uf0c1 The emergencies page helps with all sorts of install/setup issues, recovering from lost keys and other self-inflicted wounds, lists some common (and some uncommon!) errors and non-standard configs that may trip you up. contact/support \uf0c1 security issues \uf0c1 If you think you found a possible security issue , please email me ( sitaramc@gmail.com ) directly. mailing list(s) \uf0c1 For all other communications, please use the mailing list. This has some advantages over sending direct to me (if I'm not available, someone else might respond; someone else may have additional info that I may not have thought of, or experiences to share; the issue becomes searchable for future reference; and finally, it keeps me honest!) NOTE : The first email from a new member is held until I can clear it; subsequent emails from the same email address do not get held up. Mailing list for support and general discussion: Subscribe: gitolite+subscribe@googlegroups.com Post: gitolite@googlegroups.com (If you're unwilling to join the mailing list, you can still send me direct mail if it's something simple, obvious, or quick. But if the issue needs multiple mails and/or some discussion, I prefer the mailing list.) There's also a low traffic, one-way, mailing list for release and security announcements: Subscribe: gitolite-announce+subscribe@googlegroups.com If you wish to send me code, please see the file called CONTRIBUTING in the source distribution. IRC \uf0c1 Our IRC channel is #gitolite on libera.chat. I live in India (UTC+0530 time zone), but there are a few regulars ( thanks, guys, you know who you are! ) from other times zones. That said, it's not heavy traffic and you may have to wait a while for an answer, depending on the time of day and day of week. There are also many gitolite-knowledgeable people on the git channel #git . license \uf0c1 The gitolite software is copyright Sitaram Chamarty and is licensed under the GPL v2; please see the file called COPYING in the source distribution. This documentation , which is maintained separately from the main gitolite source code, is copyright Sitaram Chamarty and is provided under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . However, certain parts are contributed by others who may have chosen other licenses; their names and license will be mentioned in the respective files. Documentation for a software product will naturally contain code examples. I believe that the principle of fair use should cover use of those snippets; see especially factors 3 and 4 in the list of factors here . If you're not convinced that it would be fair use, then you may consider those code snippets, as well as associated \"comments\" if any, to be under the GPLv2 license. Licensing is about intent, and the intent of these examples is that you use them wherever and however you can use gitolite itself. Note: GIT is a trademark of Software Freedom Conservancy and my use of \"Gitolite\" is under license.","title":"home"},{"location":"index.html#hosting-git-repositories","text":"Gitolite allows you to setup git hosting on a central server, with fine-grained access control and many more powerful features.","title":"Hosting Git Repositories"},{"location":"index.html#installsetup","text":"If you're installing via your package manager, make sure you get the right one; it's often called gitolite3 . Source code is at https://github.com/sitaramc/gitolite . If your Unix-fu and ssh-fu are good, take a look at the quick install page. Otherwise follow the documentation flow, skipping whatever you think you don't need.","title":"install/setup"},{"location":"index.html#documentation","text":"(April 2014): There's a book on gitolite out . I've received some emails over the years asking where to donate for gitolite to show your appreciation, and I've always refused politely. Well, if you insist... buy the book :-) In general, the sections (see links in the navigation bar at the top) should be fairly self-explanatory, and reading through the documentation as it flows (i.e., using the \"Next\" link at the top right of each page) should work fine. There are some forward references here and there, but you can ignore those links on a first pass. In addition: There's a fool proof setup guide with detailed help showing one fool-proof way to install, as long as you follow instructions faithfully! Once you've installed and setup, there's the cookbook with recipes for common tasks.","title":"documentation"},{"location":"index.html#troubleshooting","text":"The emergencies page helps with all sorts of install/setup issues, recovering from lost keys and other self-inflicted wounds, lists some common (and some uncommon!) errors and non-standard configs that may trip you up.","title":"TROUBLESHOOTING"},{"location":"index.html#contactsupport","text":"","title":"contact/support"},{"location":"index.html#security-issues","text":"If you think you found a possible security issue , please email me ( sitaramc@gmail.com ) directly.","title":"security issues"},{"location":"index.html#mailing-lists","text":"For all other communications, please use the mailing list. This has some advantages over sending direct to me (if I'm not available, someone else might respond; someone else may have additional info that I may not have thought of, or experiences to share; the issue becomes searchable for future reference; and finally, it keeps me honest!) NOTE : The first email from a new member is held until I can clear it; subsequent emails from the same email address do not get held up. Mailing list for support and general discussion: Subscribe: gitolite+subscribe@googlegroups.com Post: gitolite@googlegroups.com (If you're unwilling to join the mailing list, you can still send me direct mail if it's something simple, obvious, or quick. But if the issue needs multiple mails and/or some discussion, I prefer the mailing list.) There's also a low traffic, one-way, mailing list for release and security announcements: Subscribe: gitolite-announce+subscribe@googlegroups.com If you wish to send me code, please see the file called CONTRIBUTING in the source distribution.","title":"mailing list(s)"},{"location":"index.html#irc","text":"Our IRC channel is #gitolite on libera.chat. I live in India (UTC+0530 time zone), but there are a few regulars ( thanks, guys, you know who you are! ) from other times zones. That said, it's not heavy traffic and you may have to wait a while for an answer, depending on the time of day and day of week. There are also many gitolite-knowledgeable people on the git channel #git .","title":"IRC"},{"location":"index.html#license","text":"The gitolite software is copyright Sitaram Chamarty and is licensed under the GPL v2; please see the file called COPYING in the source distribution. This documentation , which is maintained separately from the main gitolite source code, is copyright Sitaram Chamarty and is provided under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License . However, certain parts are contributed by others who may have chosen other licenses; their names and license will be mentioned in the respective files. Documentation for a software product will naturally contain code examples. I believe that the principle of fair use should cover use of those snippets; see especially factors 3 and 4 in the list of factors here . If you're not convinced that it would be fair use, then you may consider those code snippets, as well as associated \"comments\" if any, to be under the GPLv2 license. Licensing is about intent, and the intent of these examples is that you use them wherever and however you can use gitolite itself. Note: GIT is a trademark of Software Freedom Conservancy and my use of \"Gitolite\" is under license.","title":"license"},{"location":"basic-admin.html","text":"basic administration \uf0c1 If you really, really, really want to manage gitolite directly on the server, i.e., without cloning the gitolite-admin repo, you can -- here's how . This is likely to be of interest mainly to puppet/chef type installations. Day-to-day management of a gitolite site is done by cloning the special 'gitolite-admin' repo, making appropriate changes to it, and pushing it back to the server. The concepts and terminology page has a section with some details on what happens after the push. In other words, do NOT add new repos or users manually on the server! clone the gitolite-admin repo \uf0c1 To clone the admin repo, go to the workstation where the public key used in 'setup' came from, and run this: git clone git@host:gitolite-admin NOTE that (1) you must not include the repositories/ part (gitolite handles that internally), and (2) you may include the \".git\" at the end but it is optional. If this step fails, be sure to look at the two pages linked from the ssh page before asking for help. A very basic first step is to run the info command ( ssh git@host info ); this page tells you what to expect. add/remove users \uf0c1 NOTE: This section only applies to ssh mode. If you've installed gitolite in http mode, adding and removing users is outside the scope of gitolite. Strictly speaking, gitolite doesn't know where users come from. (If that surprises you, go back to the concepts page and read the section on \"authentication and authorisation\"). However, gitolite does help with ssh-based authentication, by making it easy to add and remove users from ~/.ssh/authorized_keys . To add or remove users, you have to clone the gitolite-admin repository, then add or remove ssh pubkey files from the \"keydir/\" directory in the clone. Then commit those changes and push. Here's how to add users to gitolite. \"alice\" is the administrator and is adding \"bob\" and \"carol\". All this is done from the admin (Alice)'s workstation. The steps are: Run git clone git@server:gitolite-admin . Obtain pubkeys from each user; email, USB, DHL, pigeon post, owl mail, any method you like. Rename each received file to the name of the user, add a \".pub\" at the end, copy it into keydir/ in the gitolite-admin repo you cloned. Run git add keydir , then git commit , then git push . You do NOT need to add Carol or Bob as real (Unix) users. You do NOT add their keys directly anywhere on the server, and you most definitely do NOT fiddle with the authorized_keys file on the server directly! To remove a user, git rm keydir/alice.pub . Commit and push the changes. On receiving the push, gitolite will carry out the changes specified. NOTE : your users' public key is typically $HOME/.ssh/id_rsa.pub on her workstation. Please make sure it is in openssh's default format. multiple keys per user \uf0c1 You can put pubkeys in subdirectories within \"keydir/\", because the user name is simply the base name of the public key file name. That is, 'keydir/alice.pub', 'keydir/home/alice.pub', 'keydir/laptop/alice.pub', (or even 'keydir/work/desktop/alice.pub' -- any number of subdirectory levels are OK) all resolve to user \"alice\". This is the simplest and most understandable way to allow multiple keys per user. Please see appendix 2 at the bottom of this document for an older way that will continue to be supported but has proved hard to explain! (Finally, if you insist on wanting to actually put all the keys for a user into a single, multi-line, pubkey file, it is possible. For details, see the program src/triggers/post-compile/ssh-authkeys-split in the source.) add, remove, and rename repos \uf0c1 Note: this page describes how to add new repos. To bring already existing repos under gitolite's control, click here . To add a new repo, you have to clone the gitolite-admin repository, then edit the conf/gitolite.conf file. In that file, add the repo, along with at least one user with some permissions. You can add the new repo in its own paragraph, repo bar RW+ = alice or you can add it to an existing repo line, if the new repo is intended to have the same access rules: repo foo bar RW+ = alice Either way, commit and push the changes. Gitolite will create a bare, empty, repo on the server that is ready to be cloned and pushed to. As you can see, the \"repo\" line can have any number of repo names or repo group names in it. However, it can only be one line; this will not work: repo foo repo bar # WRONG; 'foo' is now forgotten RW+ = alice If you have too many to fit on one line comfortably, you can create and use a repo group : @myrepos = foo @myrepos = bar . . . @myrepos = zzq repo @myrepos RW+ = alice removing/renaming a repo \uf0c1 Removing a repo is not so straightforward. You certainly must remove the appropriate lines from the conf/gitolite.conf file, but gitolite will not automatically delete the repo from the server. You have to log on to the server and do the dirty deed yourself :-) It is best to make the change in the conf file, push it, and then go to the server and do what you need to. Renaming a repo is also not automatic. Here's what you do (and the order is important): Go to the server and rename the repo at the Unix command line. Don't forget to retain the \".git\" extension on the directory name. Change the name in the conf/gitolite.conf file in your gitolite-admin repo clone, and add/commit/push. appendix 1: bringing existing repos into gitolite \uf0c1 Warning! Gitolite will clobber any existing update hook in your repos when you do this. Please see either the cookbook or the non-core page for information on how to make your existing update hook work with gitolite. Gitolite may clobber any existing \"git-daemon-export-ok\" file in your repo; see the page on allowing access to gitweb and git-daemon for how to enable that via gitolite. With that out of the way, here's how to do this: Warning! This warning applies to versions before v3.6.10. Depending on how your gitolite.conf is setup, and how much time you take between moving the repositories and completing the rest of the instructions below, it may be possible for a user to read or write the repos you are in the process of migrating. To prevent writing, you can disable write access to all repos before you start this process. Preventing reading is much harder, but at the same time, most configurations will not have this problem. If in doubt, ask on the mailing list. Either way, don't forget to re-enable access at the end of this process! First, on the server: Move the repos to $HOME/repositories . Make sure that: They are all bare repos. All the repo names end in \".git\". All the files and directories are owned and writable by the gitolite hosting user (especially true if you copied them as root). There are no symbolic links left over from wherever the files were brought from. Run the following three commands: gitolite compile gitolite setup --hooks-only gitolite trigger POST_COMPILE If the repos are wildcard repos that already match some repo regex in the conf file, you need to manually create the gl-creator file, like so: echo username > ~/repositories/path/to/repo.git/gl-creator I haven't yet found this to be common enough to bother wrapping it in a nice interface or command. However, if the repos are normal repos, then, back on your workstation: Add them to the conf/gitolite.conf in your clone of the admin repo, then commit and push the change. appendix 2: old style multi-keys \uf0c1 There is another way that involves creating key files like alice@home.pub and alice@laptop.pub , but there is a complication because gitolite also allows full email addresses as user names. (i.e., sitaramc@gmail.com.pub denotes the user called sitaramc@gmail.com ). This older method of enabling multi-keys was developed to deal with that. It will continue to work and be supported in code , simply because I prefer it. But I will not accept questions or doc patches for it, because it seems it is too difficult to understand for a lot of people. This table of sample pubkey filenames and the corresponding derived usernames is all you get: plain username, no multikey sitaramc.pub sitaramc plain username, with multikeys sitaramc@laptop.pub sitaramc sitaramc@desktop.pub sitaramc email address as username, no multikey sitaramc@gmail.com.pub sitaramc@gmail.com email address as username, with multikeys sitaramc@gmail.com@laptop.pub sitaramc@gmail.com sitaramc@gmail.com@desktop.pub sitaramc@gmail.com","title":"basic administration"},{"location":"basic-admin.html#basic-administration","text":"If you really, really, really want to manage gitolite directly on the server, i.e., without cloning the gitolite-admin repo, you can -- here's how . This is likely to be of interest mainly to puppet/chef type installations. Day-to-day management of a gitolite site is done by cloning the special 'gitolite-admin' repo, making appropriate changes to it, and pushing it back to the server. The concepts and terminology page has a section with some details on what happens after the push. In other words, do NOT add new repos or users manually on the server!","title":"basic administration"},{"location":"basic-admin.html#clone-the-gitolite-admin-repo","text":"To clone the admin repo, go to the workstation where the public key used in 'setup' came from, and run this: git clone git@host:gitolite-admin NOTE that (1) you must not include the repositories/ part (gitolite handles that internally), and (2) you may include the \".git\" at the end but it is optional. If this step fails, be sure to look at the two pages linked from the ssh page before asking for help. A very basic first step is to run the info command ( ssh git@host info ); this page tells you what to expect.","title":"clone the gitolite-admin repo"},{"location":"basic-admin.html#addremove-users","text":"NOTE: This section only applies to ssh mode. If you've installed gitolite in http mode, adding and removing users is outside the scope of gitolite. Strictly speaking, gitolite doesn't know where users come from. (If that surprises you, go back to the concepts page and read the section on \"authentication and authorisation\"). However, gitolite does help with ssh-based authentication, by making it easy to add and remove users from ~/.ssh/authorized_keys . To add or remove users, you have to clone the gitolite-admin repository, then add or remove ssh pubkey files from the \"keydir/\" directory in the clone. Then commit those changes and push. Here's how to add users to gitolite. \"alice\" is the administrator and is adding \"bob\" and \"carol\". All this is done from the admin (Alice)'s workstation. The steps are: Run git clone git@server:gitolite-admin . Obtain pubkeys from each user; email, USB, DHL, pigeon post, owl mail, any method you like. Rename each received file to the name of the user, add a \".pub\" at the end, copy it into keydir/ in the gitolite-admin repo you cloned. Run git add keydir , then git commit , then git push . You do NOT need to add Carol or Bob as real (Unix) users. You do NOT add their keys directly anywhere on the server, and you most definitely do NOT fiddle with the authorized_keys file on the server directly! To remove a user, git rm keydir/alice.pub . Commit and push the changes. On receiving the push, gitolite will carry out the changes specified. NOTE : your users' public key is typically $HOME/.ssh/id_rsa.pub on her workstation. Please make sure it is in openssh's default format.","title":"add/remove users"},{"location":"basic-admin.html#multiple-keys-per-user","text":"You can put pubkeys in subdirectories within \"keydir/\", because the user name is simply the base name of the public key file name. That is, 'keydir/alice.pub', 'keydir/home/alice.pub', 'keydir/laptop/alice.pub', (or even 'keydir/work/desktop/alice.pub' -- any number of subdirectory levels are OK) all resolve to user \"alice\". This is the simplest and most understandable way to allow multiple keys per user. Please see appendix 2 at the bottom of this document for an older way that will continue to be supported but has proved hard to explain! (Finally, if you insist on wanting to actually put all the keys for a user into a single, multi-line, pubkey file, it is possible. For details, see the program src/triggers/post-compile/ssh-authkeys-split in the source.)","title":"multiple keys per user"},{"location":"basic-admin.html#add-remove-and-rename-repos","text":"Note: this page describes how to add new repos. To bring already existing repos under gitolite's control, click here . To add a new repo, you have to clone the gitolite-admin repository, then edit the conf/gitolite.conf file. In that file, add the repo, along with at least one user with some permissions. You can add the new repo in its own paragraph, repo bar RW+ = alice or you can add it to an existing repo line, if the new repo is intended to have the same access rules: repo foo bar RW+ = alice Either way, commit and push the changes. Gitolite will create a bare, empty, repo on the server that is ready to be cloned and pushed to. As you can see, the \"repo\" line can have any number of repo names or repo group names in it. However, it can only be one line; this will not work: repo foo repo bar # WRONG; 'foo' is now forgotten RW+ = alice If you have too many to fit on one line comfortably, you can create and use a repo group : @myrepos = foo @myrepos = bar . . . @myrepos = zzq repo @myrepos RW+ = alice","title":"add, remove, and rename repos"},{"location":"basic-admin.html#removingrenaming-a-repo","text":"Removing a repo is not so straightforward. You certainly must remove the appropriate lines from the conf/gitolite.conf file, but gitolite will not automatically delete the repo from the server. You have to log on to the server and do the dirty deed yourself :-) It is best to make the change in the conf file, push it, and then go to the server and do what you need to. Renaming a repo is also not automatic. Here's what you do (and the order is important): Go to the server and rename the repo at the Unix command line. Don't forget to retain the \".git\" extension on the directory name. Change the name in the conf/gitolite.conf file in your gitolite-admin repo clone, and add/commit/push.","title":"removing/renaming a repo"},{"location":"basic-admin.html#appendix-1-bringing-existing-repos-into-gitolite","text":"Warning! Gitolite will clobber any existing update hook in your repos when you do this. Please see either the cookbook or the non-core page for information on how to make your existing update hook work with gitolite. Gitolite may clobber any existing \"git-daemon-export-ok\" file in your repo; see the page on allowing access to gitweb and git-daemon for how to enable that via gitolite. With that out of the way, here's how to do this: Warning! This warning applies to versions before v3.6.10. Depending on how your gitolite.conf is setup, and how much time you take between moving the repositories and completing the rest of the instructions below, it may be possible for a user to read or write the repos you are in the process of migrating. To prevent writing, you can disable write access to all repos before you start this process. Preventing reading is much harder, but at the same time, most configurations will not have this problem. If in doubt, ask on the mailing list. Either way, don't forget to re-enable access at the end of this process! First, on the server: Move the repos to $HOME/repositories . Make sure that: They are all bare repos. All the repo names end in \".git\". All the files and directories are owned and writable by the gitolite hosting user (especially true if you copied them as root). There are no symbolic links left over from wherever the files were brought from. Run the following three commands: gitolite compile gitolite setup --hooks-only gitolite trigger POST_COMPILE If the repos are wildcard repos that already match some repo regex in the conf file, you need to manually create the gl-creator file, like so: echo username > ~/repositories/path/to/repo.git/gl-creator I haven't yet found this to be common enough to bother wrapping it in a nice interface or command. However, if the repos are normal repos, then, back on your workstation: Add them to the conf/gitolite.conf in your clone of the admin repo, then commit and push the change.","title":"appendix 1: bringing existing repos into gitolite"},{"location":"basic-admin.html#appendix-2-old-style-multi-keys","text":"There is another way that involves creating key files like alice@home.pub and alice@laptop.pub , but there is a complication because gitolite also allows full email addresses as user names. (i.e., sitaramc@gmail.com.pub denotes the user called sitaramc@gmail.com ). This older method of enabling multi-keys was developed to deal with that. It will continue to work and be supported in code , simply because I prefer it. But I will not accept questions or doc patches for it, because it seems it is too difficult to understand for a lot of people. This table of sample pubkey filenames and the corresponding derived usernames is all you get: plain username, no multikey sitaramc.pub sitaramc plain username, with multikeys sitaramc@laptop.pub sitaramc sitaramc@desktop.pub sitaramc email address as username, no multikey sitaramc@gmail.com.pub sitaramc@gmail.com email address as username, with multikeys sitaramc@gmail.com@laptop.pub sitaramc@gmail.com sitaramc@gmail.com@desktop.pub sitaramc@gmail.com","title":"appendix 2: old style multi-keys"},{"location":"build-docs.html","text":"building the documentation \uf0c1 I changed from my homemade system to mkdocs, mainly due to the search facility. (I'm sure there are any number of other static site generators out there, but this one seemed to have the smallest footprint and was easiest to install and get going). building the docs \uf0c1 Make sure the tree is not dirty. Run bin/build ; takes a few seconds and grabs the screen, sorry! Deploy site/ what doesn't work in mkdocs \uf0c1 bad language guesses \uf0c1 It seems to be too hard to make it turn off its \"guess the language\" pseudo-smartness when you use a plain indented code block. And looking at the mailing list archives does not give me much hope this will be fixed. So you're left with strange colors on some random words in many code blocks! (I could fence each of them with an explicit language but I'm reluctant to do that; plain markdown's plain indented code should be left plain, ideally!) no hidden docs \uf0c1 Every document must appear in the document menu (top nav bar), even if it is several levels deep. The only way to have a document rendered without putting it on the nav bar is not to even list a page hierarchy, which makes them all come out in alphabetical order, which is useless for a project of this size. The mailing list has some workarounds, but at the moment I am not using them. I'd already added all the documents willy-nilly anyway. Except, ironically, this document; this will never be rendered -- you'll only see it in the source repo. foo bar split across lines \uf0c1 If a foo bar is split across lines due to vim formatting, the bloody output also shows it split there. My constant OCD to reformat all paras has taken a hit, due to all these manually UN-formatted paragraphs. TOC levels \uf0c1 The 'cinder' theme gives you 3 levels, but does not scroll the side nav at all (i.e., if you have too many entries, you just won't see the ones that were below the window bottom)! Sticking with default theme for now. code highlight \uf0c1 the \"codehilite\" extension seems too complicated looking at the steps described in https://pythonhosted.org/Markdown/extensions/code_hilite.html in any case they don't recognise gitolite syntax. So we just use the <pre style=\"color: #ffffff; background-color: #000000;\"> ...code... </pre> syntax and let our preprocessor fix things up using vim. Kludgy, slow, annoying (all those xterms -- I need to implement caching for this), but it gets the job done with a minimum of fuss. short anchors \uf0c1 can only be created like: <h1 id=\"dl\">download</h1> Using # <a id=\"dl\" />download causes some weird artefacts in the generated page. At present I'm not using them at all; just using the long forms.","title":"building the documentation"},{"location":"build-docs.html#building-the-documentation","text":"I changed from my homemade system to mkdocs, mainly due to the search facility. (I'm sure there are any number of other static site generators out there, but this one seemed to have the smallest footprint and was easiest to install and get going).","title":"building the documentation"},{"location":"build-docs.html#building-the-docs","text":"Make sure the tree is not dirty. Run bin/build ; takes a few seconds and grabs the screen, sorry! Deploy site/","title":"building the docs"},{"location":"build-docs.html#what-doesnt-work-in-mkdocs","text":"","title":"what doesn't work in mkdocs"},{"location":"build-docs.html#bad-language-guesses","text":"It seems to be too hard to make it turn off its \"guess the language\" pseudo-smartness when you use a plain indented code block. And looking at the mailing list archives does not give me much hope this will be fixed. So you're left with strange colors on some random words in many code blocks! (I could fence each of them with an explicit language but I'm reluctant to do that; plain markdown's plain indented code should be left plain, ideally!)","title":"bad language guesses"},{"location":"build-docs.html#no-hidden-docs","text":"Every document must appear in the document menu (top nav bar), even if it is several levels deep. The only way to have a document rendered without putting it on the nav bar is not to even list a page hierarchy, which makes them all come out in alphabetical order, which is useless for a project of this size. The mailing list has some workarounds, but at the moment I am not using them. I'd already added all the documents willy-nilly anyway. Except, ironically, this document; this will never be rendered -- you'll only see it in the source repo.","title":"no hidden docs"},{"location":"build-docs.html#foo-bar-split-across-lines","text":"If a foo bar is split across lines due to vim formatting, the bloody output also shows it split there. My constant OCD to reformat all paras has taken a hit, due to all these manually UN-formatted paragraphs.","title":"foo bar split across lines"},{"location":"build-docs.html#toc-levels","text":"The 'cinder' theme gives you 3 levels, but does not scroll the side nav at all (i.e., if you have too many entries, you just won't see the ones that were below the window bottom)! Sticking with default theme for now.","title":"TOC levels"},{"location":"build-docs.html#code-highlight","text":"the \"codehilite\" extension seems too complicated looking at the steps described in https://pythonhosted.org/Markdown/extensions/code_hilite.html in any case they don't recognise gitolite syntax. So we just use the <pre style=\"color: #ffffff; background-color: #000000;\"> ...code... </pre> syntax and let our preprocessor fix things up using vim. Kludgy, slow, annoying (all those xterms -- I need to implement caching for this), but it gets the job done with a minimum of fuss.","title":"code highlight"},{"location":"build-docs.html#short-anchors","text":"can only be created like: <h1 id=\"dl\">download</h1> Using # <a id=\"dl\" />download causes some weird artefacts in the generated page. At present I'm not using them at all; just using the long forms.","title":"short anchors"},{"location":"cache.html","text":"gitolite and the (redis) cache \uf0c1 (requires v3.6.1) WARNING: this has not been tested in a while. YMMV Gitolite can optionally use the Redis in-memory key-value database for a little speed boost for really large sites. If you look in the [gitolite performance][perf] page, you will see, right at the bottom, that pretty much the only thing in gitolite that may be slow is the [info][] command. The cache feature fixes that problem :-) Using Redis as the backend database is actually a bit of overkill; technically this could just as well have been done using a DBM file or SQlite or something like that, but since this is only a cache , an in-memory database works out better. However, Redis does have one real advantage: cache [timeout][]s! Support for this feature is limited to verifiable gitolite bugs, if you find any; I can't help you with redis itself. how does caching work? \uf0c1 To use this feature, just install Redis, then the perl driver \"Redis.pm\". Install or upgrade Gitolite to the latest master, then uncomment (or add, if it doesn't exist) the following line in the rc file: CACHE => 'Redis', If you're adding it, please add it within the \\%RC hash, but outside the ENABLE list. (If in doubt, add it just after the UMASK entry). Then perform some gitolite operation (anything that requires any form of access checking). Redis should start automatically and the right things should happen; see below if it does not. troubleshooting caching \uf0c1 If you ever kill the redis-server be sure to also remove the socket file ~/.redis-gitolite.sock . Conversely if you ever remove the sock file be sure to kill the process also. Otherwise you get weird behaviour, including possible hangs. (If things don't seem to work, the first thing to do is to kill all 'redis-server's on that userid and remove ~/.redis-gitolite.* , then try again.) Note : To the best of my knowledge, this cannot result in wrong data being passed to gitolite, causing a security breach. If anyone has time I'd appreciate a review of the code. caching details \uf0c1 what is cached \uf0c1 At present, gitolite caches only one specific function: the \"access()\" function. This is available from the shell as the 'gitolite access ...' command, as well as from perl via the \"Easy.pm\" interface; see [dev-notes][] for more. It is easily the \"workhorse\" of gitolite. The cache is flushed completely when the gitolite.conf file is \"compiled\". You might see some things running a bit slower -- at least until things settle down. Finally, if you run 'perms', the cache entries for that specific repo are also flushed. how long is it cached {#timeout} \uf0c1 Redis has a timeout feature that can delete entries after a certain period of time has elapsed since they were created or updated. Gitolite sets a timeout of 90000 seconds (just over a day) normally. However, if you're using the GROUPLIST_PGM feature (see [here][ldap] for details), then this timeout becomes 900 seconds (only 15 minutes). This is because a user's group membership, and thus her access rights, can change without gitolite being aware of the change. If you're not using the GROUPLIST_PGM feature, you don't have to do anything. But if you are using it, then a cache timeout of 15 minutes may be too much or too little for you -- I cannot judge that. You can tell gitolite what timeout you want for your setup, by adding (or uncommenting) an RC variable called CACHE_TTL; its value is the number of seconds for the timeout.","title":"gitolite and the (redis) cache"},{"location":"cache.html#gitolite-and-the-redis-cache","text":"(requires v3.6.1) WARNING: this has not been tested in a while. YMMV Gitolite can optionally use the Redis in-memory key-value database for a little speed boost for really large sites. If you look in the [gitolite performance][perf] page, you will see, right at the bottom, that pretty much the only thing in gitolite that may be slow is the [info][] command. The cache feature fixes that problem :-) Using Redis as the backend database is actually a bit of overkill; technically this could just as well have been done using a DBM file or SQlite or something like that, but since this is only a cache , an in-memory database works out better. However, Redis does have one real advantage: cache [timeout][]s! Support for this feature is limited to verifiable gitolite bugs, if you find any; I can't help you with redis itself.","title":"gitolite and the (redis) cache"},{"location":"cache.html#how-does-caching-work","text":"To use this feature, just install Redis, then the perl driver \"Redis.pm\". Install or upgrade Gitolite to the latest master, then uncomment (or add, if it doesn't exist) the following line in the rc file: CACHE => 'Redis', If you're adding it, please add it within the \\%RC hash, but outside the ENABLE list. (If in doubt, add it just after the UMASK entry). Then perform some gitolite operation (anything that requires any form of access checking). Redis should start automatically and the right things should happen; see below if it does not.","title":"how does caching work?"},{"location":"cache.html#troubleshooting-caching","text":"If you ever kill the redis-server be sure to also remove the socket file ~/.redis-gitolite.sock . Conversely if you ever remove the sock file be sure to kill the process also. Otherwise you get weird behaviour, including possible hangs. (If things don't seem to work, the first thing to do is to kill all 'redis-server's on that userid and remove ~/.redis-gitolite.* , then try again.) Note : To the best of my knowledge, this cannot result in wrong data being passed to gitolite, causing a security breach. If anyone has time I'd appreciate a review of the code.","title":"troubleshooting caching"},{"location":"cache.html#caching-details","text":"","title":"caching details"},{"location":"cache.html#what-is-cached","text":"At present, gitolite caches only one specific function: the \"access()\" function. This is available from the shell as the 'gitolite access ...' command, as well as from perl via the \"Easy.pm\" interface; see [dev-notes][] for more. It is easily the \"workhorse\" of gitolite. The cache is flushed completely when the gitolite.conf file is \"compiled\". You might see some things running a bit slower -- at least until things settle down. Finally, if you run 'perms', the cache entries for that specific repo are also flushed.","title":"what is cached"},{"location":"cache.html#how-long-is-it-cached-timeout","text":"Redis has a timeout feature that can delete entries after a certain period of time has elapsed since they were created or updated. Gitolite sets a timeout of 90000 seconds (just over a day) normally. However, if you're using the GROUPLIST_PGM feature (see [here][ldap] for details), then this timeout becomes 900 seconds (only 15 minutes). This is because a user's group membership, and thus her access rights, can change without gitolite being aware of the change. If you're not using the GROUPLIST_PGM feature, you don't have to do anything. But if you are using it, then a cache timeout of 15 minutes may be too much or too little for you -- I cannot judge that. You can tell gitolite what timeout you want for your setup, by adding (or uncommenting) an RC variable called CACHE_TTL; its value is the number of seconds for the timeout.","title":"how long is it cached {#timeout}"},{"location":"concepts.html","text":"concepts, conventions, and terminology \uf0c1 (I assume you're at least somewhat familiar with git itself. If not, the \"before you start...\" page has a list of topics that you need to be familiar with, in order to use gitolite.) This page will help newcomers get used to what we're talking about elsewhere. It also explains the special gitolite-admin repo and how it is used to do te day-to-day management of a gitolite server. authentication and authorisation \uf0c1 Gitolite does not do authentication. It only does authorisation. So let's loosely define these words: Authentication is the process of verifying that you are who you claim to be. An authentication system will establish that I am the user \"sitaram\" on my work system. The one behind gmail will similarly establish that I am \"sitaramc\". And so on... Authorisation is the process of asking what you want to do and deciding if you're allowed to do it or not. When you install gitolite, your users will authenticate themselves to your server's \"sshd\" (ssh daemon) or to your web server. If authentication succeeds, sshd or httpd will pass control to gitolite, which then performs the authorisation check -- i.e., figure out whether to allow you to do whatever it is you want to whatever repo you decided to touch. ssh mode and http mode \uf0c1 Git allows authenticated remote access using these two mechanisms: ssh and http. Gitolite supports both. Ssh mode is much easier to install and setup; most systems already have whatever you need, and -- except for creating the \"hosting user\" -- you don't need to do anything as root. However, your users have to generate an ssh keypair for themselves (using \"ssh-keygen\") if they don't already have a keypair, and they have to send you the public key (the file ending in \".pub\"), which you add to gitolite. Http mode requires a bit more work in terms of setting things up. Once setup, however, it may be a little easier for your users. Authentication is by username + password, which, although much less secure than ssh keypairs, is conceptually easier for users. The \"hosting user\" \uf0c1 If you're wondering how it distinguishes between different users when they are all logging into \"git\", this page has answers! When you install gitolite in ssh mode, you pick one specific user on the Unix system to be the \"hosting user\". This is the user whose name goes into the repo URLs your users will be cloning, for example ssh://git@server/repo , or the simpler form git@server:repo . Usually , this is \"git\", and that is what we assume in this documentation. However, it can actually be any user on the system, and I think both the Fedora RPM and the Debian DEB use \"gitolite\", so adjust instructions and examples accordingly. Unless otherwise stated, everything that we do \"on the server\" is done in this userid (for ssh mode installations). Of course you can have any number of \"hosting users\", but that's rare. the \"logical repo name\" \uf0c1 Gitolite refers to repos using a logical repo name, which is whatever name you specified in the gitolite.conf file (described later). The actual repo will be in $HOME/repositories , and will have a \".git\" suffix. So, for example, the logical repo name \"foo\" will be $HOME/repositories/foo.git on disk, and \"bar/baz\" will be $HOME/repositories/bar/baz.git . The logical repo name is what you must use for all interactions with gitolite (within the conf file, repo name arguments to gitolite commands or API functions, etc.) unless specifically documented otherwise. One exception: you're allowed to add the \".git\" extension in git commands (clone, fetch, push, ls-remote, archive) if you wish, because git itself allows it, and we'd like to be as transparent as possible. The $HOME/repositories prefix should never be specified. If you do specify it, and things appear to work, something is wrong! . the special gitolite-admin repo \uf0c1 Gitolite manages git repos. Among them is a repo called \"gitolite-admin\", which is a very special repository that helps you add and remove users and repos, as well as define access rules for them. Most day-to-day management of gitolite is done by cloning this repository, making changes to it, and pushing the changes back to the server. Specifically, it contains a directory called \"keydir\", in which you place files with names like \"alice.pub\", \"bob.pub\", etc. These are the public keys of you and your users. (Of course this applies only to ssh mode). It also contains a file called \"conf/gitolite.conf\", in which you add access rules specifying who gets what level of access to each repo. Here's a simple example: # these lines were already in the file repo foo RW+ = alice RW = bob # these lines were added just now repo bar RW+ = bob R = alice Here's what happens when you commit the changes/additions to these files and push them to the server. Since we've already seen the ssh/sshd part of this process (in the overview page), we'll start off from \"git-receive-pack\": The gitolite-admin repo has a special post-update hook, installed by gitolite, which is invoked by git-receive-pack . This is how gitolite gets in on the action. Gitolite looks at the keys in keydir, and updates ssh's authorized keys file using those keys, so ssh knows who the valid users are. A ton of detail about this is in the ssh pages . It then updates some internal files in ~/.gitolite For new repositories (repos that do not exist in ~/repositories , but are mentioned in conf/gitolite.conf ), it creates the repository. For each repository, it updates a special file inside the repository that contains the rules pertaining to that repository. And that, boys and girls, is how gitolite does its thing. That is also why you should NEVER touch any of those files yourself, unless you know what you're doing!","title":"concepts, conventions, terminology"},{"location":"concepts.html#concepts-conventions-and-terminology","text":"(I assume you're at least somewhat familiar with git itself. If not, the \"before you start...\" page has a list of topics that you need to be familiar with, in order to use gitolite.) This page will help newcomers get used to what we're talking about elsewhere. It also explains the special gitolite-admin repo and how it is used to do te day-to-day management of a gitolite server.","title":"concepts, conventions, and terminology"},{"location":"concepts.html#authentication-and-authorisation","text":"Gitolite does not do authentication. It only does authorisation. So let's loosely define these words: Authentication is the process of verifying that you are who you claim to be. An authentication system will establish that I am the user \"sitaram\" on my work system. The one behind gmail will similarly establish that I am \"sitaramc\". And so on... Authorisation is the process of asking what you want to do and deciding if you're allowed to do it or not. When you install gitolite, your users will authenticate themselves to your server's \"sshd\" (ssh daemon) or to your web server. If authentication succeeds, sshd or httpd will pass control to gitolite, which then performs the authorisation check -- i.e., figure out whether to allow you to do whatever it is you want to whatever repo you decided to touch.","title":"authentication and authorisation"},{"location":"concepts.html#ssh-mode-and-http-mode","text":"Git allows authenticated remote access using these two mechanisms: ssh and http. Gitolite supports both. Ssh mode is much easier to install and setup; most systems already have whatever you need, and -- except for creating the \"hosting user\" -- you don't need to do anything as root. However, your users have to generate an ssh keypair for themselves (using \"ssh-keygen\") if they don't already have a keypair, and they have to send you the public key (the file ending in \".pub\"), which you add to gitolite. Http mode requires a bit more work in terms of setting things up. Once setup, however, it may be a little easier for your users. Authentication is by username + password, which, although much less secure than ssh keypairs, is conceptually easier for users.","title":"ssh mode and http mode"},{"location":"concepts.html#the-hosting-user","text":"If you're wondering how it distinguishes between different users when they are all logging into \"git\", this page has answers! When you install gitolite in ssh mode, you pick one specific user on the Unix system to be the \"hosting user\". This is the user whose name goes into the repo URLs your users will be cloning, for example ssh://git@server/repo , or the simpler form git@server:repo . Usually , this is \"git\", and that is what we assume in this documentation. However, it can actually be any user on the system, and I think both the Fedora RPM and the Debian DEB use \"gitolite\", so adjust instructions and examples accordingly. Unless otherwise stated, everything that we do \"on the server\" is done in this userid (for ssh mode installations). Of course you can have any number of \"hosting users\", but that's rare.","title":"The \"hosting user\""},{"location":"concepts.html#the-logical-repo-name","text":"Gitolite refers to repos using a logical repo name, which is whatever name you specified in the gitolite.conf file (described later). The actual repo will be in $HOME/repositories , and will have a \".git\" suffix. So, for example, the logical repo name \"foo\" will be $HOME/repositories/foo.git on disk, and \"bar/baz\" will be $HOME/repositories/bar/baz.git . The logical repo name is what you must use for all interactions with gitolite (within the conf file, repo name arguments to gitolite commands or API functions, etc.) unless specifically documented otherwise. One exception: you're allowed to add the \".git\" extension in git commands (clone, fetch, push, ls-remote, archive) if you wish, because git itself allows it, and we'd like to be as transparent as possible. The $HOME/repositories prefix should never be specified. If you do specify it, and things appear to work, something is wrong! .","title":"the \"logical repo name\""},{"location":"concepts.html#the-special-gitolite-admin-repo","text":"Gitolite manages git repos. Among them is a repo called \"gitolite-admin\", which is a very special repository that helps you add and remove users and repos, as well as define access rules for them. Most day-to-day management of gitolite is done by cloning this repository, making changes to it, and pushing the changes back to the server. Specifically, it contains a directory called \"keydir\", in which you place files with names like \"alice.pub\", \"bob.pub\", etc. These are the public keys of you and your users. (Of course this applies only to ssh mode). It also contains a file called \"conf/gitolite.conf\", in which you add access rules specifying who gets what level of access to each repo. Here's a simple example: # these lines were already in the file repo foo RW+ = alice RW = bob # these lines were added just now repo bar RW+ = bob R = alice Here's what happens when you commit the changes/additions to these files and push them to the server. Since we've already seen the ssh/sshd part of this process (in the overview page), we'll start off from \"git-receive-pack\": The gitolite-admin repo has a special post-update hook, installed by gitolite, which is invoked by git-receive-pack . This is how gitolite gets in on the action. Gitolite looks at the keys in keydir, and updates ssh's authorized keys file using those keys, so ssh knows who the valid users are. A ton of detail about this is in the ssh pages . It then updates some internal files in ~/.gitolite For new repositories (repos that do not exist in ~/repositories , but are mentioned in conf/gitolite.conf ), it creates the repository. For each repository, it updates a special file inside the repository that contains the rules pertaining to that repository. And that, boys and girls, is how gitolite does its thing. That is also why you should NEVER touch any of those files yourself, unless you know what you're doing!","title":"the special gitolite-admin repo"},{"location":"conf-2.html","text":"the \"conf\" file ( conf/gitolite.conf ) \uf0c1 (part 2) access control rule matching \uf0c1 Access control rule matching is pretty simple. From the previous section, you know what \"permission\", \"refex\", \"user\", and \"repo\" are. Here's how the rules are used to decide whether to allow or deny a request. Access is checked once only for \"read\" operations, but twice for \"write\"s. (Note that the deny-rules option, mentioned below, is explained in more detail in a later section.) Check #1 : the first check happens as soon as gitolite-shell receives control (from sshd or httpd). gitolite-shell will pass control to git-upload-pack or git-receive-pack only if this check succeeds. collect all the rules pertaining to this repo and this user ignore all the refexes; they don't apply to the first access check if the deny-rules option is not in effect for this repo, discard all the - (deny) rules look at the rules in sequence : if you find a - , access is denied for a \"read\" operation (clone, fetch, ...), if you find a rule containing R , access is allowed for a \"write\" operation (push), if you find a rule containing W , access is allowed if there are no more rules left, access is denied Check #2 : the second check only happens for \"push\" operations. It is invoked by git-receive-pack running the gitolite-installed update hook. If access is denied, the update hook fails, and git then aborts the push for this ref. (See man githooks for more.) In the following description, we use the word operation instead of W , because the actual operation could be a plain, fast-forward, push ( W ) or a rewind/delete ( + ). Other, less commonly used, values are \"C\", \"D\", or \"M\"; see here . collect all the rules pertaining to this repo and this user discard all the rules where the refex does not match the ref (branch or tag) being pushed look at the rules in sequence : if you find a - , access is denied if you find a rule containing the operation you are performing, access is allowed if there are no more rules left, access is denied an example \uf0c1 Just to be clear, let's work out an example of what happens when dilbert tries to push a branch called \"xyz\". We'll pretend the rule list looks like this: # managers should be able to read any repo repo @all R = @managers # ...other rules for other repos... repo foo bar RW+ = alice @teamleads - master = dilbert @devteam - refs/tags/v[0-9] = dilbert @devteam RW+ dev/ = dilbert @devteam RW = dilbert @devteam R = @managers After adding a default refex and expanding the supplied ones (see the refex section earlier), this is what it looks like. We've added line numbers for convenience; we'll see why later. 1 # managers should be able to read any repo 2 repo @all 3 R = @managers 4 5 # ...other rules for other repos... 6 7 repo foo bar 8 9 RW+ refs/.* = alice @teamleads 10 - refs/heads/master = dilbert @devteam 11 - refs/tags/v[0-9] = dilbert @devteam 12 RW+ refs/heads/dev/ = dilbert @devteam 13 RW refs/.* = dilbert @devteam 14 R = @managers This represents a set of rules that are basically this: repo user perm ref (from line) foo @managers R 3 foo alice RW+ refs/.* 9 foo @teamleads RW+ refs/.* 9 foo dilbert - refs/heads/master 10 foo @devteam - refs/heads/master 10 foo dilbert - refs/tags/v[0-9] 11 foo @devteam - refs/tags/v[0-9] 11 foo dilbert RW+ refs/heads/dev/ 12 foo @devteam RW+ refs/heads/dev/ 12 foo dilbert RW refs/.* 13 foo @devteam RW refs/.* 13 foo @managers R 14 Which of these rules apply for dilbert? We'll assume he's not a team lead, as that would defeat the whole purpose of this example! We know he's not a manager, as that would defeat the whole purpose of the comic! Finally, we assume he's also not part of \"@devteam\", (otherwise why would you name him separately in all those lines?). So we discard all those rules, which leaves us, for repo \"foo\" and user \"dilbert\": perm ref (from line) - refs/heads/master 10 - refs/tags/v[0-9] 11 RW+ refs/heads/dev/ 12 RW refs/.* 13 So what happens when dilbert tries to push a branch called \"xyz\"? At check #1, the data gitolite has is that \"oper\" is \"W\" (and ref of course is unknown). We discard lines 10 and 11 (the deny-rules option is off by default, so we ignore - rules). Line 12 supplies a perm of \"RW+\", which contains \"W\" (the \"oper\") so access is allowed. At check #2, the data gitolite has is that \"oper\" is \"W\" and ref is refs/heads/xyz . We discard the first three rules, since the ref does not match any of those refexes. That leaves just line 13. If the push were a fast-forward push, the \"oper\" would be \"W\", and since it is contained in the perm for rule 13, access is allowed. However, if he were to try a rewind-push, then the \"oper\" would be \"+\", which is not contained in \"RW\", it wouldn't match, then control would go back for the next rule, and since there aren't any more, access would be denied. tracing the access control decision \uf0c1 (v3.6.1) Gitolite can help you trace this logic quickly and easily. Here's one example run, with the above rules. This one tests whether dilbert can push to repo foo (check #1). Note that the syntax for specifying an unknown ref in this command is 'any'. $ gitolite access -s foo dilbert W any legend: d => skipped deny rule due to ref unknown or 'any', r => skipped due to refex not matching, p => skipped due to perm (W, +, etc) not matching, D => explicitly denied, A => explicitly allowed, F => denied due to fallthru (no rules matched) d gitolite.conf:10 - refs/heads/master = dilbert @devteam d gitolite.conf:11 - refs/tags/v[0-9] = dilbert @devteam A gitolite.conf:12 RW+ refs/heads/dev/ = dilbert @devteam refs/heads/dev/ Now see what happens when we try check #2 (we've omitted the legend in the output, since it's always the same): $ gitolite access -s foo dilbert W xyz r gitolite.conf:10 - refs/heads/master = dilbert @devteam r gitolite.conf:11 - refs/tags/v[0-9] = dilbert @devteam r gitolite.conf:12 RW+ refs/heads/dev/ = dilbert @devteam A gitolite.conf:13 RW refs/.* = dilbert @devteam refs/.* And if you try a force push: $ gitolite access -s foo dilbert + refs/heads/xyz r gitolite.conf:10 - refs/heads/master = dilbert @devteam r gitolite.conf:11 - refs/tags/v[0-9] = dilbert @devteam r gitolite.conf:12 RW+ refs/heads/dev/ = dilbert @devteam p gitolite.conf:13 RW refs/.* = dilbert @devteam F (fallthru) + refs/heads/xyz foo dilbert DENIED by fallthru I hope that was useful! Be sure you correlated the output of 'gitolite access -s' with the rule workflow pictures and corresponding descriptions to cement your understanding. read access respecting deny rules \uf0c1 Normally, deny rules are ignored by access check #1 (the one that runs before git-upload-pack or git-receive-pack is called by gitolite-shell); they apply only to check #2 (the update hook check). But sometimes you want this \"pre-git\" access check to respect deny rules; i.e., use the flow of check #2, not check #1. You tell gitolite to do this by setting the \"deny-rules\" option for the repo; when you do that, the flow of check #2 is used for both stages, before git and in the update hook. example 1 \uf0c1 Here's an example. Here, we have lots of repos, which should all be accessible by gitweb or daemon, so we want the convenience provided by lines 6 and 7 (we don't want to put line 7 in each repo). However, we also have some secret repos (maybe the gitolite-admin repo and some others that we will list), which we want to prevent gitweb or daemon from seeing. How do we do that? The naive approach -- putting in a deny rule just for those repos -- doesn't work. In fact nothing else seems to work either; you'll have to replace the @all with an exhaustive list of all repos other than the secret repos . 1 @secret = gitolite-admin secret-repo/..* 2 repo @secret 3 - = gitweb daemon 4 5 6 repo @all 7 R = gitweb daemon 8 9 # ...other repos and rules... That's... painful! What you really want is for that repo to always use check #2, even when it doesn't actually have a ref to test for. 1 @secret = gitolite-admin secret-repo/..* 2 repo @secret 3 - = gitweb daemon 4 option deny-rules = 1 5 6 repo @all 7 R = gitweb daemon 8 9 # ...other repos and rules... This is done by adding one line, line 4 in this example. This sets a gitolite \"option\" that says you want \"deny rules\" to be applicable even for read access. Once you do that, all you need to do is to ensure that the first rule encountered by these two \"users\" for those repos is a deny rule, so that it can take effect first. In this example, the placement of lines 2, 3 vis-a-vis lines 6, 7 matters -- don't switch them! example 2 \uf0c1 In this example the \"open\" repos are fewer in number, so it is the opposite situation to the above in terms of our ability to enumerate all the repos. @open = git gitolite foss/..* [...] repo @all - = gitweb daemon option deny-rules = 1 repo @open R = gitweb daemon option deny-rules = 0 To see why this works, you need to understand that for options and config lines, a later setting overrides earlier ones. So we set it to 1 for all repos, then selectively set it to 0 for some. This means the \"deny-rules\" option applies to all the repos except the \"open\" repos , and so the first rule encountered by gitweb and daemon is a deny rule, so they are denied read access. The \"open\" repos, on the other hand, get the normal default behaviour, which is to ignore deny rules for read access, and thus they only see the \"R\" permission. appendix 1: different types of write operations \uf0c1 Git supplies enough information to the update hook to be able to distinguish several types of writes. The most common are: RW -- create a ref or fast-forward push a ref. No rewinds or deletes. RW+ -- create, fast-forward push, rewind push, or delete a ref. Sometimes you want to allow people to push, but not create a ref. Or rewind, but not delete a ref. The C and D qualifiers help here. If a rule specifies RWC or RW+C , then rules that do NOT have the C qualifier will no longer permit creating a ref in that repo . Please do not confuse this with the standalone C permission that allows someone to create a repo If a rule specifies RWD or RW+D , then rules that do NOT have the D qualifier will no longer permit deleting a ref in that repo . Note: These two can be combined, so you can have RWCD and RW+CD as well. One very rare need is to reject merge commits (a commit series that is not a straight line of commits). The M qualifier helps here: When a rule has M appended to the permissions, rules that do NOT have it will reject a commit sequence that contains a merge commit (i.e., they only accept a straight line series of commits). summary of permissions \uf0c1 The full set of permissions, in regex syntax, is -|R|RW+?C?D?M? . This expands to one of - , R , RW , RW+ , RWC , RW+C , RWD , RW+D , RWCD , or RW+CD , all but the first two optionally followed by an M . appendix 2: gitolite access check flow \uf0c1 Here's lots more detail on the access check process, with flow diagrams. When do the access checks happen and what are the four pieces of data (repo, user, operation, ref) in each case? read write In these pictures the access checks are marked in yellow. The picture on the left is for a read (git clone, fetch, ls-remote). There is only one access check for a read operation. If access is denied, the operation aborts. Otherwise, gitolite-shell invokes git-upload-pack. Notice the information available to the access check. The \"oper\" (operation) is \"R\", indicating a read operation. The \"ref\" is listed as \"unknown\", although we could also call it \"irrelevant\"! Access check #1 proceeds with those 4 bits of information, and either passes or fails. If it passes, gitolite passes control to \"git-upload-pack\" and its job is done. The flow for a push operation (the picture on the right) is very similar upto the first access check. The \"oper\" is \"W\" now, although the \"ref\" is still unknown. Even though this is a push, at this stage in the protocol nothing on the server knows what branch or tag or combination of them are coming down the wire, since we haven't executed git-receive-pack yet! If it succeeds, gitolite passes control to \"git-receive-pack\", but its job is not done yet. Git will eventually invoke the update hook (see 'man githooks'). Gitolite has already grabbed this hook, which receives from git the ref name being pushed, as well as enough information to compute whether this push is a \"fast-forward push\" or a \"rewind push\". Based on this, gitolite sets the \"oper\" field to \"W\" or \"+\", respectively. Access check #2 proceeds with this information. The result is sent back to git-receive-pack (in the form of an exit code; again, see 'man githooks'), and the push fails or succeeds based on that. putting it all together \uf0c1 At this point, we have the following pieces of information: A set of rules, each containing 4 pieces of data: repo, user, perm, refex. They are in the sequence they were found in the conf file. We discard all rules that do not apply to this repo and this user, which means our set of rules have only two fields: perm, refex. As a quick reminder, perm is one of R, RW, RW+, or - . Four elements that make up the access being attempted: repo, user, oper, ref. Again, as a reminder, the \"oper\" is one letter . For \"check #1\" it is either R or W, and for check #2 it can be W or +. Note on permissions and \"oper\": there are other types of permissions , but for our discussion these are enough. The others are rare, and anyway it is easy to extrapolate to them. With that background, here's the flow. The one on the left is for check #1 (ref is unknown) while the one on the right is for check #2 (ref is known). ref unknown ref known As you can see, deny rules are ignored by check #1 -- they're not tested in any way. For check #2, if there is a deny rule whose refex matched the ref, access is denied (as you'd expect). appendix 3: embedding test code in your conf \uf0c1 As of v3.6.7, it is possible to embed test code within gitolite.conf. This can be useful if your conf file is complicated, and you need a way to make sure that any changes are not messing with your most important restrictions. Full details, including preparation and caveats, are in contrib/utils/testconf , but here's a teaser example: repo foo RW+ = u1 RW = u2 =begin testconf gitolite access -q foo u1 + any || echo FAILED gitolite access -q foo u2 + any && echo FAILED gitolite access -q foo u2 W any || echo FAILED =end","title":"the \"conf\" file (part 2)"},{"location":"conf-2.html#the-conf-file-confgitoliteconf","text":"(part 2)","title":"the \"conf\" file (conf/gitolite.conf)"},{"location":"conf-2.html#access-control-rule-matching","text":"Access control rule matching is pretty simple. From the previous section, you know what \"permission\", \"refex\", \"user\", and \"repo\" are. Here's how the rules are used to decide whether to allow or deny a request. Access is checked once only for \"read\" operations, but twice for \"write\"s. (Note that the deny-rules option, mentioned below, is explained in more detail in a later section.) Check #1 : the first check happens as soon as gitolite-shell receives control (from sshd or httpd). gitolite-shell will pass control to git-upload-pack or git-receive-pack only if this check succeeds. collect all the rules pertaining to this repo and this user ignore all the refexes; they don't apply to the first access check if the deny-rules option is not in effect for this repo, discard all the - (deny) rules look at the rules in sequence : if you find a - , access is denied for a \"read\" operation (clone, fetch, ...), if you find a rule containing R , access is allowed for a \"write\" operation (push), if you find a rule containing W , access is allowed if there are no more rules left, access is denied Check #2 : the second check only happens for \"push\" operations. It is invoked by git-receive-pack running the gitolite-installed update hook. If access is denied, the update hook fails, and git then aborts the push for this ref. (See man githooks for more.) In the following description, we use the word operation instead of W , because the actual operation could be a plain, fast-forward, push ( W ) or a rewind/delete ( + ). Other, less commonly used, values are \"C\", \"D\", or \"M\"; see here . collect all the rules pertaining to this repo and this user discard all the rules where the refex does not match the ref (branch or tag) being pushed look at the rules in sequence : if you find a - , access is denied if you find a rule containing the operation you are performing, access is allowed if there are no more rules left, access is denied","title":"access control rule matching"},{"location":"conf-2.html#an-example","text":"Just to be clear, let's work out an example of what happens when dilbert tries to push a branch called \"xyz\". We'll pretend the rule list looks like this: # managers should be able to read any repo repo @all R = @managers # ...other rules for other repos... repo foo bar RW+ = alice @teamleads - master = dilbert @devteam - refs/tags/v[0-9] = dilbert @devteam RW+ dev/ = dilbert @devteam RW = dilbert @devteam R = @managers After adding a default refex and expanding the supplied ones (see the refex section earlier), this is what it looks like. We've added line numbers for convenience; we'll see why later. 1 # managers should be able to read any repo 2 repo @all 3 R = @managers 4 5 # ...other rules for other repos... 6 7 repo foo bar 8 9 RW+ refs/.* = alice @teamleads 10 - refs/heads/master = dilbert @devteam 11 - refs/tags/v[0-9] = dilbert @devteam 12 RW+ refs/heads/dev/ = dilbert @devteam 13 RW refs/.* = dilbert @devteam 14 R = @managers This represents a set of rules that are basically this: repo user perm ref (from line) foo @managers R 3 foo alice RW+ refs/.* 9 foo @teamleads RW+ refs/.* 9 foo dilbert - refs/heads/master 10 foo @devteam - refs/heads/master 10 foo dilbert - refs/tags/v[0-9] 11 foo @devteam - refs/tags/v[0-9] 11 foo dilbert RW+ refs/heads/dev/ 12 foo @devteam RW+ refs/heads/dev/ 12 foo dilbert RW refs/.* 13 foo @devteam RW refs/.* 13 foo @managers R 14 Which of these rules apply for dilbert? We'll assume he's not a team lead, as that would defeat the whole purpose of this example! We know he's not a manager, as that would defeat the whole purpose of the comic! Finally, we assume he's also not part of \"@devteam\", (otherwise why would you name him separately in all those lines?). So we discard all those rules, which leaves us, for repo \"foo\" and user \"dilbert\": perm ref (from line) - refs/heads/master 10 - refs/tags/v[0-9] 11 RW+ refs/heads/dev/ 12 RW refs/.* 13 So what happens when dilbert tries to push a branch called \"xyz\"? At check #1, the data gitolite has is that \"oper\" is \"W\" (and ref of course is unknown). We discard lines 10 and 11 (the deny-rules option is off by default, so we ignore - rules). Line 12 supplies a perm of \"RW+\", which contains \"W\" (the \"oper\") so access is allowed. At check #2, the data gitolite has is that \"oper\" is \"W\" and ref is refs/heads/xyz . We discard the first three rules, since the ref does not match any of those refexes. That leaves just line 13. If the push were a fast-forward push, the \"oper\" would be \"W\", and since it is contained in the perm for rule 13, access is allowed. However, if he were to try a rewind-push, then the \"oper\" would be \"+\", which is not contained in \"RW\", it wouldn't match, then control would go back for the next rule, and since there aren't any more, access would be denied.","title":"an example"},{"location":"conf-2.html#tracing-the-access-control-decision","text":"(v3.6.1) Gitolite can help you trace this logic quickly and easily. Here's one example run, with the above rules. This one tests whether dilbert can push to repo foo (check #1). Note that the syntax for specifying an unknown ref in this command is 'any'. $ gitolite access -s foo dilbert W any legend: d => skipped deny rule due to ref unknown or 'any', r => skipped due to refex not matching, p => skipped due to perm (W, +, etc) not matching, D => explicitly denied, A => explicitly allowed, F => denied due to fallthru (no rules matched) d gitolite.conf:10 - refs/heads/master = dilbert @devteam d gitolite.conf:11 - refs/tags/v[0-9] = dilbert @devteam A gitolite.conf:12 RW+ refs/heads/dev/ = dilbert @devteam refs/heads/dev/ Now see what happens when we try check #2 (we've omitted the legend in the output, since it's always the same): $ gitolite access -s foo dilbert W xyz r gitolite.conf:10 - refs/heads/master = dilbert @devteam r gitolite.conf:11 - refs/tags/v[0-9] = dilbert @devteam r gitolite.conf:12 RW+ refs/heads/dev/ = dilbert @devteam A gitolite.conf:13 RW refs/.* = dilbert @devteam refs/.* And if you try a force push: $ gitolite access -s foo dilbert + refs/heads/xyz r gitolite.conf:10 - refs/heads/master = dilbert @devteam r gitolite.conf:11 - refs/tags/v[0-9] = dilbert @devteam r gitolite.conf:12 RW+ refs/heads/dev/ = dilbert @devteam p gitolite.conf:13 RW refs/.* = dilbert @devteam F (fallthru) + refs/heads/xyz foo dilbert DENIED by fallthru I hope that was useful! Be sure you correlated the output of 'gitolite access -s' with the rule workflow pictures and corresponding descriptions to cement your understanding.","title":"tracing the access control decision"},{"location":"conf-2.html#read-access-respecting-deny-rules","text":"Normally, deny rules are ignored by access check #1 (the one that runs before git-upload-pack or git-receive-pack is called by gitolite-shell); they apply only to check #2 (the update hook check). But sometimes you want this \"pre-git\" access check to respect deny rules; i.e., use the flow of check #2, not check #1. You tell gitolite to do this by setting the \"deny-rules\" option for the repo; when you do that, the flow of check #2 is used for both stages, before git and in the update hook.","title":"read access respecting deny rules"},{"location":"conf-2.html#example-1","text":"Here's an example. Here, we have lots of repos, which should all be accessible by gitweb or daemon, so we want the convenience provided by lines 6 and 7 (we don't want to put line 7 in each repo). However, we also have some secret repos (maybe the gitolite-admin repo and some others that we will list), which we want to prevent gitweb or daemon from seeing. How do we do that? The naive approach -- putting in a deny rule just for those repos -- doesn't work. In fact nothing else seems to work either; you'll have to replace the @all with an exhaustive list of all repos other than the secret repos . 1 @secret = gitolite-admin secret-repo/..* 2 repo @secret 3 - = gitweb daemon 4 5 6 repo @all 7 R = gitweb daemon 8 9 # ...other repos and rules... That's... painful! What you really want is for that repo to always use check #2, even when it doesn't actually have a ref to test for. 1 @secret = gitolite-admin secret-repo/..* 2 repo @secret 3 - = gitweb daemon 4 option deny-rules = 1 5 6 repo @all 7 R = gitweb daemon 8 9 # ...other repos and rules... This is done by adding one line, line 4 in this example. This sets a gitolite \"option\" that says you want \"deny rules\" to be applicable even for read access. Once you do that, all you need to do is to ensure that the first rule encountered by these two \"users\" for those repos is a deny rule, so that it can take effect first. In this example, the placement of lines 2, 3 vis-a-vis lines 6, 7 matters -- don't switch them!","title":"example 1"},{"location":"conf-2.html#example-2","text":"In this example the \"open\" repos are fewer in number, so it is the opposite situation to the above in terms of our ability to enumerate all the repos. @open = git gitolite foss/..* [...] repo @all - = gitweb daemon option deny-rules = 1 repo @open R = gitweb daemon option deny-rules = 0 To see why this works, you need to understand that for options and config lines, a later setting overrides earlier ones. So we set it to 1 for all repos, then selectively set it to 0 for some. This means the \"deny-rules\" option applies to all the repos except the \"open\" repos , and so the first rule encountered by gitweb and daemon is a deny rule, so they are denied read access. The \"open\" repos, on the other hand, get the normal default behaviour, which is to ignore deny rules for read access, and thus they only see the \"R\" permission.","title":"example 2"},{"location":"conf-2.html#appendix-1-different-types-of-write-operations","text":"Git supplies enough information to the update hook to be able to distinguish several types of writes. The most common are: RW -- create a ref or fast-forward push a ref. No rewinds or deletes. RW+ -- create, fast-forward push, rewind push, or delete a ref. Sometimes you want to allow people to push, but not create a ref. Or rewind, but not delete a ref. The C and D qualifiers help here. If a rule specifies RWC or RW+C , then rules that do NOT have the C qualifier will no longer permit creating a ref in that repo . Please do not confuse this with the standalone C permission that allows someone to create a repo If a rule specifies RWD or RW+D , then rules that do NOT have the D qualifier will no longer permit deleting a ref in that repo . Note: These two can be combined, so you can have RWCD and RW+CD as well. One very rare need is to reject merge commits (a commit series that is not a straight line of commits). The M qualifier helps here: When a rule has M appended to the permissions, rules that do NOT have it will reject a commit sequence that contains a merge commit (i.e., they only accept a straight line series of commits).","title":"appendix 1: different types of write operations"},{"location":"conf-2.html#summary-of-permissions","text":"The full set of permissions, in regex syntax, is -|R|RW+?C?D?M? . This expands to one of - , R , RW , RW+ , RWC , RW+C , RWD , RW+D , RWCD , or RW+CD , all but the first two optionally followed by an M .","title":"summary of permissions"},{"location":"conf-2.html#appendix-2-gitolite-access-check-flow","text":"Here's lots more detail on the access check process, with flow diagrams. When do the access checks happen and what are the four pieces of data (repo, user, operation, ref) in each case? read write In these pictures the access checks are marked in yellow. The picture on the left is for a read (git clone, fetch, ls-remote). There is only one access check for a read operation. If access is denied, the operation aborts. Otherwise, gitolite-shell invokes git-upload-pack. Notice the information available to the access check. The \"oper\" (operation) is \"R\", indicating a read operation. The \"ref\" is listed as \"unknown\", although we could also call it \"irrelevant\"! Access check #1 proceeds with those 4 bits of information, and either passes or fails. If it passes, gitolite passes control to \"git-upload-pack\" and its job is done. The flow for a push operation (the picture on the right) is very similar upto the first access check. The \"oper\" is \"W\" now, although the \"ref\" is still unknown. Even though this is a push, at this stage in the protocol nothing on the server knows what branch or tag or combination of them are coming down the wire, since we haven't executed git-receive-pack yet! If it succeeds, gitolite passes control to \"git-receive-pack\", but its job is not done yet. Git will eventually invoke the update hook (see 'man githooks'). Gitolite has already grabbed this hook, which receives from git the ref name being pushed, as well as enough information to compute whether this push is a \"fast-forward push\" or a \"rewind push\". Based on this, gitolite sets the \"oper\" field to \"W\" or \"+\", respectively. Access check #2 proceeds with this information. The result is sent back to git-receive-pack (in the form of an exit code; again, see 'man githooks'), and the push fails or succeeds based on that.","title":"appendix 2: gitolite access check flow"},{"location":"conf-2.html#putting-it-all-together","text":"At this point, we have the following pieces of information: A set of rules, each containing 4 pieces of data: repo, user, perm, refex. They are in the sequence they were found in the conf file. We discard all rules that do not apply to this repo and this user, which means our set of rules have only two fields: perm, refex. As a quick reminder, perm is one of R, RW, RW+, or - . Four elements that make up the access being attempted: repo, user, oper, ref. Again, as a reminder, the \"oper\" is one letter . For \"check #1\" it is either R or W, and for check #2 it can be W or +. Note on permissions and \"oper\": there are other types of permissions , but for our discussion these are enough. The others are rare, and anyway it is easy to extrapolate to them. With that background, here's the flow. The one on the left is for check #1 (ref is unknown) while the one on the right is for check #2 (ref is known). ref unknown ref known As you can see, deny rules are ignored by check #1 -- they're not tested in any way. For check #2, if there is a deny rule whose refex matched the ref, access is denied (as you'd expect).","title":"putting it all together"},{"location":"conf-2.html#appendix-3-embedding-test-code-in-your-conf","text":"As of v3.6.7, it is possible to embed test code within gitolite.conf. This can be useful if your conf file is complicated, and you need a way to make sure that any changes are not messing with your most important restrictions. Full details, including preparation and caveats, are in contrib/utils/testconf , but here's a teaser example: repo foo RW+ = u1 RW = u2 =begin testconf gitolite access -q foo u1 + any || echo FAILED gitolite access -q foo u2 + any && echo FAILED gitolite access -q foo u2 W any || echo FAILED =end","title":"appendix 3: embedding test code in your conf"},{"location":"conf.html","text":"the \"conf\" file ( conf/gitolite.conf ) \uf0c1 (part 1) You might recall from the basic administration page that this file is part of the gitolite-admin repo. You need to clone that repo, make and commit changes to this file, and push the commits back. The conf/gitolite.conf file (often called just \"the conf file\" for short) is one of the two most important files in gitolite. It specifies repo names and access rules, as well as repo options of various kinds and git-config values. Pretty much all day-to-day management, except managing users , happens from this file. We'll use the following example to describe it's features. (A tip of the hat to Teemu Matilainen's gitolite vim-syntax file for the colors.) @staff = dilbert alice # groups @projects = foo bar repo @projects baz # repos RW+ = @staff # rules - master = ashok RW = ashok R = wally option deny-rules = 1 # options config hooks.emailprefix = '[%GL_REPO] ' # git-config basic syntax \uf0c1 As the example above shows, the syntax is fairly straightforward and simple. In general, everything is space separated ; there are no commas, semicolons, etc., in the syntax. Comments are in the usual shell-ish style. User names and repo names are as simple as possible; they must start with an alphanumeric, but after that they can also contain . , _ , or - . Usernames can optionally be followed by an @ and a domainname containing at least one . (this allows you to use an email address as someone's username). Group names are like simple usernames (i.e., not email addresses) but start with an @ sign. Reponames can contain / characters (this allows you to put your repos in a tree-structure for convenience). There are no continuation lines by default. You do not need them; the section on groups will tell you how you can break up large lists of names in a group definition into multiple lines. (But if you must have them, you can optionally enable them; look for \"continuation-lines\" in ~/.gitolite.rc ). include files \uf0c1 Gitolite allows you to break up the configuration into multiple files and include them in the main file for convenience. For example: include \"foo.conf\" will include the contents of the file \"conf/foo.conf\". You can also use a glob ( include \"*.conf\" ), or put your include files into subdirectories of \"conf\" ( include \"foo/bar.conf\" ), or both ( include \"repos/*.conf\" ). Included files are always searched from the gitolite-admin repo's conf/ directory, unless you supplied an absolute path. (Note: in the interests of cloning the admin-repo sanely you should avoid absolute paths!) If you end up recursing, files that have been already processed once are skipped, with a warning. It is not a fatal error for an include file to be missing. If it is a glob, you won't even get a warning. Advanced users: subconf , a command that is very closely related to include , is documented here . Please note that whenever you see \"the conf/gitolite.conf file\" or \"the conf file\" in gitolite documentation, it means the combined text after the include processing is done. group definitions \uf0c1 You can group repos or users for convenience. The syntax is the same for both and does not distinguish; until you use the group name it could really be either. Here's an example: @developers = dilbert alice wally Group definitions accumulate; this is the same as the above: @developers = dilbert @developers = alice @developers = wally You can use one group in another group definition; the values will be expanded immediately (meaning later additions will not appear in the second group): @developers = dilbert alice @interns = ashok @staff = @interns @developers @developers = wally # wally is NOT part of @staff Here's a very simple but complete example of using groups: @developers = dilbert alice wally @foss-repos = git gitolite repo @foss-repos RW+ = @developers special group @all \uf0c1 @all is a special group name that is often convenient to use if you really mean \"all repos\" or \"all users\". warnings on undefined groups \uf0c1 Gitolite cannot truly catch undefined groups because the conf parser is 1-pass, and you're allowed to define a group after it is used, like so: repo foo RW = @foo @foo = u1 u2 (v3.5.3+) However, in a simplistic attempt to help people tearing their hair out because of a typo, gitolite will warn if a group is not defined when it is used. So if you defined it later, either ignore the warning or move the definition up. Note that these warnings do NOT appear if you're getting user group info from LDAP . getting user group info from LDAP \uf0c1 Gitolite's groups are pretty convenient, but some organisations already have similar (or sufficient) information in their LDAP store. Gitolite can tap into that information, with a little help. Write a program which, given a username, queries your LDAP store and returns a space-separated list of groups that the user is a member of. Then put the full path to this program in an rc variable called GROUPLIST_PGM , like so: GROUPLIST_PGM => '/home/git/bin/ldap-query-groups', Now you can use those groupnames in access rules in gitolite, because the user is a member of those groups as well as any normal gitolite groups you may have added him to in the conf file. Caution: your program must do its own logging if you want the audit trail of \"why/how did this user get access to this repo at this time?\" to resolve properly. Gitolite does not do any logging of the results of the queries because for people who don't need it that would be a huge waste. access rules \uf0c1 Some of the pictures are thanks ( enormous thanks!) to someone who contributed them but does not want to be named (go figure!). She even converted them to ditaa format when I asked; these are not as pretty as what she sent me originally but they're vim-editable in source form :-) This section talks about how gitolite's access rules work. It's a very important section, and well worth spending some time on. Gitolite's access rules are designed to be easy to use for common situations, such as some of the examples you saw earlier. However, they also pack a lot of power and flexibility. Access rules decide whether a particular access is allowed or denied. An access is defined by four pieces of data: \"reponame, username, operation, and ref\". Each rule also has four similar pieces of data, and of course there are several rules -- some people have thousands! -- in the conf file. This section will try and explain how these rules are used to decide if a given operation is to be allowed or denied. what does a rule look like? \uf0c1 You've seen some simple rules so far, for example in the basic administration page. Here's a slightly more complex one, just for illustration. repo foo bar RW+ = alice @teamleads - master = dilbert @devteam - refs/tags/v[0-9] = dilbert @devteam RW+ dev/ = dilbert @devteam RW = dilbert @devteam R = @managers A \"repo\" line names one or more repos, and is followed by one or more rule lines. All the rules from then till the next \"repo\" line apply to the repo(s) specified in the repo line -- in this example, the 'foo' and 'bar' repos. If there are no rule, config , or option lines before the next \"repo\" line, the repo line is silently ignored. Each rule line has a \"permission\" field, zero or more \"refex\"es, and one or more user or user group name after the equal sign. The \"repo\" line can also have repo groups, as we have seen in the section on groups above. Also, it can have regular expressions that match multiple repos. Before describing the various fields more formally, here's a description of what this specific rule list is saying: alice and the team leads can do whatever they want (i.e., push, rewind, or delete any branch or tag). dilbert and the dev team has these restrictions they can do anything to branches whose names start with \"dev/\" they can create or fast-forward push, but not rewind or delete, any branch except master they can create (but not update/delete) any tag except tags starting with \"v\" followed by a digit. managers can read the repo but they can't push anything. More formally, a rule line has the following fields: the permission field \uf0c1 The permission field gives the type of access this rule line permits. The most commonly used permissions are: R, to allow read operations only RW, to allow fast-forward push of a branch, or create new branch/tag RW+, to allow pretty much anything -- fast-forward, rewind or delete branches or tags - (the minus sign), to deny access. There are also other, less commonly used, types of permissions . the \"refex\" field \uf0c1 You cannot write rules for all possible branch and tag names (i.e., refs) that users will push. The only sensible way to do this is to use regular expressions instead. A refex is a word I made up to mean \"a regex that matches a ref\". In addition: If no refex is supplied, it defaults to refs/.* , for example in a rule like this: RW = alice A refex not starting with refs/ (or VREF/ ) is assumed to start with refs/heads/ . This means normal branches can be conveniently written like this: RW master = alice # becomes 'refs/heads/master' internally while tags will need to be fully qualified RW refs/tags/v[0-9] = bob A refex is implicitly anchored at the start, but not at the end. In regular expression lingo, a ^ is assumed at the start (but no $ at the end is assumed). So a refex of master will match all these refs: refs/heads/master refs/heads/master1 refs/heads/master2 refs/heads/master/full More commonly, a refex of refs/tags/v[0-9] will match all versioned tags (i.e., not just v1 but also v12 , v1.2 , v12345 , etc.) If you want to restrict the match to just the one specific ref, add a $ at the end, for example: RW master$ = alice You can also use virtual refs to perform extra checks and controls that you can't do with just the normal ref (like refs/heads/master) being pushed. The most common example is restricting pushes by dir/file name, but there are lots of other possibilities. user/user group list \uf0c1 Like the repos on the repo line, you can have any number of user names and/or user group names on the rule line. (However, please note that there is no concept of regular expressions for user names). SECTION SUMMARY : at this point you know that each rule basically specifies a repo, user, permission, and a \"refex\". rule accumulation \uf0c1 All the rules for a repo need not be specified in one place. For example, you might see something like this, perhaps at the top or bottom of the conf file: # managers should be able to read any repo repo @all R = @managers or perhaps this: # anyone can clone open source repos repo @FOSS R = @all Clearly, both these constructs affect repos which may have their own rules elsewhere. If a bunch of projects share some naming convention, you can specify any rules that are common to all of them by specifying the set of repos that are affected as a regular expression. Notice that the regex can be defined directly in the repo line, or it can be defined in a group and the group used in the repo line; it's all the same to gitolite. repo FOSS/..* # ...rules for repos under FOSS/ @secret = secret/..* private/..* repo @secret # ...rules for repos under secret/ and private/ Finally, although not very common, you can certainly do things like this: repo foo # ...some rules... # ...other repos and rules... repo foo # ...more rules for foo... Note that the \"other repos and rules\" may indirectly include repo \"foo\" (for example it there were rules for \"repo @all\", or some other group that \"foo\" was a member of). When access is being checked for an operation against a repo, all the rules that pertain to that repo are collected, in the order they were seen in the conf file . Gitolite then discards those rules that do not apply to the user whose access is being checked . (A rule applies to a user if the user's name appears in the rule (after the equal sign), or if he is a member of any of the group names that appear in the rule.) defining \"user\" and \"repo\" \uf0c1 To be very specific, when we speak of \"user\" and \"repo\" in rules, \"user\" means \"user or a group that he/she is a member of\", and \"repo\" means \"repo, or a group that it is a member of, or a regex that matches it, or a group that contains a regex that matches it\".","title":"the \"conf\" file (part 1)"},{"location":"conf.html#the-conf-file-confgitoliteconf","text":"(part 1) You might recall from the basic administration page that this file is part of the gitolite-admin repo. You need to clone that repo, make and commit changes to this file, and push the commits back. The conf/gitolite.conf file (often called just \"the conf file\" for short) is one of the two most important files in gitolite. It specifies repo names and access rules, as well as repo options of various kinds and git-config values. Pretty much all day-to-day management, except managing users , happens from this file. We'll use the following example to describe it's features. (A tip of the hat to Teemu Matilainen's gitolite vim-syntax file for the colors.) @staff = dilbert alice # groups @projects = foo bar repo @projects baz # repos RW+ = @staff # rules - master = ashok RW = ashok R = wally option deny-rules = 1 # options config hooks.emailprefix = '[%GL_REPO] ' # git-config","title":"the \"conf\" file (conf/gitolite.conf)"},{"location":"conf.html#basic-syntax","text":"As the example above shows, the syntax is fairly straightforward and simple. In general, everything is space separated ; there are no commas, semicolons, etc., in the syntax. Comments are in the usual shell-ish style. User names and repo names are as simple as possible; they must start with an alphanumeric, but after that they can also contain . , _ , or - . Usernames can optionally be followed by an @ and a domainname containing at least one . (this allows you to use an email address as someone's username). Group names are like simple usernames (i.e., not email addresses) but start with an @ sign. Reponames can contain / characters (this allows you to put your repos in a tree-structure for convenience). There are no continuation lines by default. You do not need them; the section on groups will tell you how you can break up large lists of names in a group definition into multiple lines. (But if you must have them, you can optionally enable them; look for \"continuation-lines\" in ~/.gitolite.rc ).","title":"basic syntax"},{"location":"conf.html#include-files","text":"Gitolite allows you to break up the configuration into multiple files and include them in the main file for convenience. For example: include \"foo.conf\" will include the contents of the file \"conf/foo.conf\". You can also use a glob ( include \"*.conf\" ), or put your include files into subdirectories of \"conf\" ( include \"foo/bar.conf\" ), or both ( include \"repos/*.conf\" ). Included files are always searched from the gitolite-admin repo's conf/ directory, unless you supplied an absolute path. (Note: in the interests of cloning the admin-repo sanely you should avoid absolute paths!) If you end up recursing, files that have been already processed once are skipped, with a warning. It is not a fatal error for an include file to be missing. If it is a glob, you won't even get a warning. Advanced users: subconf , a command that is very closely related to include , is documented here . Please note that whenever you see \"the conf/gitolite.conf file\" or \"the conf file\" in gitolite documentation, it means the combined text after the include processing is done.","title":"include files"},{"location":"conf.html#group-definitions","text":"You can group repos or users for convenience. The syntax is the same for both and does not distinguish; until you use the group name it could really be either. Here's an example: @developers = dilbert alice wally Group definitions accumulate; this is the same as the above: @developers = dilbert @developers = alice @developers = wally You can use one group in another group definition; the values will be expanded immediately (meaning later additions will not appear in the second group): @developers = dilbert alice @interns = ashok @staff = @interns @developers @developers = wally # wally is NOT part of @staff Here's a very simple but complete example of using groups: @developers = dilbert alice wally @foss-repos = git gitolite repo @foss-repos RW+ = @developers","title":"group definitions"},{"location":"conf.html#special-group-all","text":"@all is a special group name that is often convenient to use if you really mean \"all repos\" or \"all users\".","title":"special group @all"},{"location":"conf.html#warnings-on-undefined-groups","text":"Gitolite cannot truly catch undefined groups because the conf parser is 1-pass, and you're allowed to define a group after it is used, like so: repo foo RW = @foo @foo = u1 u2 (v3.5.3+) However, in a simplistic attempt to help people tearing their hair out because of a typo, gitolite will warn if a group is not defined when it is used. So if you defined it later, either ignore the warning or move the definition up. Note that these warnings do NOT appear if you're getting user group info from LDAP .","title":"warnings on undefined groups"},{"location":"conf.html#getting-user-group-info-from-ldap","text":"Gitolite's groups are pretty convenient, but some organisations already have similar (or sufficient) information in their LDAP store. Gitolite can tap into that information, with a little help. Write a program which, given a username, queries your LDAP store and returns a space-separated list of groups that the user is a member of. Then put the full path to this program in an rc variable called GROUPLIST_PGM , like so: GROUPLIST_PGM => '/home/git/bin/ldap-query-groups', Now you can use those groupnames in access rules in gitolite, because the user is a member of those groups as well as any normal gitolite groups you may have added him to in the conf file. Caution: your program must do its own logging if you want the audit trail of \"why/how did this user get access to this repo at this time?\" to resolve properly. Gitolite does not do any logging of the results of the queries because for people who don't need it that would be a huge waste.","title":"getting user group info from LDAP"},{"location":"conf.html#access-rules","text":"Some of the pictures are thanks ( enormous thanks!) to someone who contributed them but does not want to be named (go figure!). She even converted them to ditaa format when I asked; these are not as pretty as what she sent me originally but they're vim-editable in source form :-) This section talks about how gitolite's access rules work. It's a very important section, and well worth spending some time on. Gitolite's access rules are designed to be easy to use for common situations, such as some of the examples you saw earlier. However, they also pack a lot of power and flexibility. Access rules decide whether a particular access is allowed or denied. An access is defined by four pieces of data: \"reponame, username, operation, and ref\". Each rule also has four similar pieces of data, and of course there are several rules -- some people have thousands! -- in the conf file. This section will try and explain how these rules are used to decide if a given operation is to be allowed or denied.","title":"access rules"},{"location":"conf.html#what-does-a-rule-look-like","text":"You've seen some simple rules so far, for example in the basic administration page. Here's a slightly more complex one, just for illustration. repo foo bar RW+ = alice @teamleads - master = dilbert @devteam - refs/tags/v[0-9] = dilbert @devteam RW+ dev/ = dilbert @devteam RW = dilbert @devteam R = @managers A \"repo\" line names one or more repos, and is followed by one or more rule lines. All the rules from then till the next \"repo\" line apply to the repo(s) specified in the repo line -- in this example, the 'foo' and 'bar' repos. If there are no rule, config , or option lines before the next \"repo\" line, the repo line is silently ignored. Each rule line has a \"permission\" field, zero or more \"refex\"es, and one or more user or user group name after the equal sign. The \"repo\" line can also have repo groups, as we have seen in the section on groups above. Also, it can have regular expressions that match multiple repos. Before describing the various fields more formally, here's a description of what this specific rule list is saying: alice and the team leads can do whatever they want (i.e., push, rewind, or delete any branch or tag). dilbert and the dev team has these restrictions they can do anything to branches whose names start with \"dev/\" they can create or fast-forward push, but not rewind or delete, any branch except master they can create (but not update/delete) any tag except tags starting with \"v\" followed by a digit. managers can read the repo but they can't push anything. More formally, a rule line has the following fields:","title":"what does a rule look like?"},{"location":"conf.html#the-permission-field","text":"The permission field gives the type of access this rule line permits. The most commonly used permissions are: R, to allow read operations only RW, to allow fast-forward push of a branch, or create new branch/tag RW+, to allow pretty much anything -- fast-forward, rewind or delete branches or tags - (the minus sign), to deny access. There are also other, less commonly used, types of permissions .","title":"the permission field"},{"location":"conf.html#the-refex-field","text":"You cannot write rules for all possible branch and tag names (i.e., refs) that users will push. The only sensible way to do this is to use regular expressions instead. A refex is a word I made up to mean \"a regex that matches a ref\". In addition: If no refex is supplied, it defaults to refs/.* , for example in a rule like this: RW = alice A refex not starting with refs/ (or VREF/ ) is assumed to start with refs/heads/ . This means normal branches can be conveniently written like this: RW master = alice # becomes 'refs/heads/master' internally while tags will need to be fully qualified RW refs/tags/v[0-9] = bob A refex is implicitly anchored at the start, but not at the end. In regular expression lingo, a ^ is assumed at the start (but no $ at the end is assumed). So a refex of master will match all these refs: refs/heads/master refs/heads/master1 refs/heads/master2 refs/heads/master/full More commonly, a refex of refs/tags/v[0-9] will match all versioned tags (i.e., not just v1 but also v12 , v1.2 , v12345 , etc.) If you want to restrict the match to just the one specific ref, add a $ at the end, for example: RW master$ = alice You can also use virtual refs to perform extra checks and controls that you can't do with just the normal ref (like refs/heads/master) being pushed. The most common example is restricting pushes by dir/file name, but there are lots of other possibilities.","title":"the \"refex\" field"},{"location":"conf.html#useruser-group-list","text":"Like the repos on the repo line, you can have any number of user names and/or user group names on the rule line. (However, please note that there is no concept of regular expressions for user names). SECTION SUMMARY : at this point you know that each rule basically specifies a repo, user, permission, and a \"refex\".","title":"user/user group list"},{"location":"conf.html#rule-accumulation","text":"All the rules for a repo need not be specified in one place. For example, you might see something like this, perhaps at the top or bottom of the conf file: # managers should be able to read any repo repo @all R = @managers or perhaps this: # anyone can clone open source repos repo @FOSS R = @all Clearly, both these constructs affect repos which may have their own rules elsewhere. If a bunch of projects share some naming convention, you can specify any rules that are common to all of them by specifying the set of repos that are affected as a regular expression. Notice that the regex can be defined directly in the repo line, or it can be defined in a group and the group used in the repo line; it's all the same to gitolite. repo FOSS/..* # ...rules for repos under FOSS/ @secret = secret/..* private/..* repo @secret # ...rules for repos under secret/ and private/ Finally, although not very common, you can certainly do things like this: repo foo # ...some rules... # ...other repos and rules... repo foo # ...more rules for foo... Note that the \"other repos and rules\" may indirectly include repo \"foo\" (for example it there were rules for \"repo @all\", or some other group that \"foo\" was a member of). When access is being checked for an operation against a repo, all the rules that pertain to that repo are collected, in the order they were seen in the conf file . Gitolite then discards those rules that do not apply to the user whose access is being checked . (A rule applies to a user if the user's name appears in the rule (after the equal sign), or if he is a member of any of the group names that appear in the rule.)","title":"rule accumulation"},{"location":"conf.html#defining-user-and-repo","text":"To be very specific, when we speak of \"user\" and \"repo\" in rules, \"user\" means \"user or a group that he/she is a member of\", and \"repo\" means \"repo, or a group that it is a member of, or a regex that matches it, or a group that contains a regex that matches it\".","title":"defining \"user\" and \"repo\""},{"location":"cookbook.html","text":"gitolite cookbook \uf0c1 (a.k.a. \"stop all that rambling and just tell me what I need to do!\") Documentation is meant to be as complete as possible, which means it attempts to cover all situations and scenarios. That makes it harder to read. However, if you make some assumptions, remove the rationale, justification, exceptions and special cases, etc., and generally just say what is to be done rather than explain why , many tasks can be described very easily. Or, if the main documentation already does that, a cookbook may help you find it faster, simply because it's organised differently. Maybe this will help. If you run into problems, please check the main documentation before asking for help. administration \uf0c1 separating \"key admin\" from \"repo admin\" \uf0c1 In gitolite, the person who controls the keys is the most critical in terms of security -- because he can always add his own key in your name :-) Traditionally, the same person also administers repos and permissions. But sometimes you want to separate them. To separate those roles, put the following in conf/gitolite.conf, and let the repo-manager manage everything through \"actual.conf\": repo gitolite-admin RW+ = key-manager repo-manager RW+ VREF/ NAME/ = key-manager - VREF/ NAME/ keydir/ = @all - VREF/ NAME/ conf/gitolite.conf = @all include \"actual.conf\" access \uf0c1 looking up repo access from external tools \uf0c1 There are two supported interfaces for this, one in perl and one in shell. Other languages should probably use the shell mode. (The shell mode has a very convenient \"batch\" mode if you need to check many repos at once). Perl interface : A good intro to this, including a link to code, using gitweb as an example can be found by looking for 'repo-specific authorisation in gitweb' in the page on allowing access to gitweb and git-daemon . Some notes: be sure to read the comments in the code to learn exactly how to adapt it to your needs in place of the can_read function in that code, you can of course use can_write . In fact, reading the comments in \"Easy.pm\" (look for it in the source) shows you several other interesting tests you can make, like is_admin , in_group , and owns . Shell interface : If you want to do this from shell, it's even easier. The same \"Easy.pm\" source contains comments that show shell equivalents for each of the functions it exports, but here's a sample: if gitolite access -q reponame username W then ... You can even test for access to specific branches: if gitolite access -q reponame username W master then ... If your gitolite is older than v3.6, you must use the full ref name; just 'master' won't do. allowing access by other programs \uf0c1 Giving external tools (like apache) access to gitolite repositories involves making sure that the unix owner/group and permissions settings allow this. This is all described in the UMASK section in the page on the rc file , because that's the only setting that gitolite controls; every thing else is pure Unix. commands \uf0c1 adding your own commands \uf0c1 To add a command, say foo , do this: add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$ENV{HOME}/local\", copy the program foo into $HOME/local/commands . (Don't forget the chmod +x !) making commands available to remote users \uf0c1 Once you do the above, foo is available as gitolite foo . To make it available to remote users (as ssh git@host foo ), add the line: `foo`, (including the comma at the end) to the ENABLE list in the rc file. hooks \uf0c1 Note: the main documentation for this feature starts here . adding your own update hooks \uf0c1 You have some update hooks (for example crlf checking) that you want to include in gitolite. Assuming the hook itself is tested and works as a normal git update hook does (i.e., conforms to what man githooks says an update hook should do), here's how to do this: add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$ENV{HOME}/local\", copy your update hook to a subdirectory called VREF under this directory, giving it a suitable name (let's say \"crlf\"): # log on to gitolite hosting user on the server, then: cd $HOME mkdir -p local/VREF cp your-crlf-update-hook local/VREF/crlf chmod +x local/VREF/crlf in your gitolite-admin clone, edit conf/gitolite.conf and add lines like this: - VREF/crlf = @all to each repo that should have that \"update\" hook. Alternatively, you can simply add this at the end of the gitolite.conf file: repo @all - VREF/crlf = @all Either way, add/commit/push the change to the gitolite-admin repo. adding other (non-update) hooks \uf0c1 Say you want other hooks, like a post-receive hook. Here's how: add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$ENV{HOME}/local\", put your hooks into that directory, in a sub-sub-directory called \"hooks/common\": # log on to gitolite hosting user on the server, then: cd $HOME mkdir -p local/hooks/common cp your-post-receive-hook local/hooks/common/post-receive chmod +x local/hooks/common/post-receive run gitolite setup to have the hooks propagate to existing repos (repos created after this will get them anyway). variation: maintain these hooks in the gitolite-admin repo \uf0c1 Important security note: If you enable this, anyone who can push changes to the admin repo will effectively be able to run any arbitrary command on the server. See gitolite admin and shell access for more background. If you want to maintain these update hooks (VREFs) or non-update hooks (post-update, pre-receive, post-receive) in the gitolite-admin repo, instead of having to log on to the server and make changes, the procedure is almost the same except for the following differences: add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$rc{GL_ADMIN_BASE}/local\", Notice \"local\" is not in $HOME like in the previous examples! the hooks/scripts are to be added inside your gitolite-admin clone, not on the server. That is, whereever the above two sections say cd $HOME , you should read it as \"cd /path/to/your/gitolite-admin-clone\". (The directory local will be within this clone of course, not in $HOME .) add/commit/push as usual. For update hooks, you will of course need to add VREF rule lines to appropriate repos in the conf file. For non-update hooks, you don't need to run 'gitolite setup' on the server; the push takes care of that. (v3.6+) variation: repo-specific hooks \uf0c1 Until now, the non-update hooks you specified apply to all repos. Here's how to apply them only to certain repos: add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$rc{GL_ADMIN_BASE}/local\", uncomment the 'repo-specific-hooks' line in the rc file or add it to the ENABLE list if it doesn't exist. If your rc file does not have an ENABLE list, you need to add this to the POST_COMPILE and the POST_CREATE lists. Click here for more on all this. put your hooks into your gitolite-admin clone, as follows: # on your workstation cd /path/to/your/gitolite-admin-clone mkdir -p local/hooks/repo-specific Now add your hooks to that directory, but instead of using the git \"standard\" names (pre-receive, post-receive, post-update), you use descriptive names (e.g. \"deploy\", \"RSS-post\", etc). For pre-receive or pre-auto-gc you should not use more than one hook. If you really need more than one, ask on the mailing list. add them to the repos you want them to be active in, in your conf file. For example: repo foo option hook.post-update = jenkins repo bar @baz option hook.post-update = deploy RSS-post add, commit, and push the admin repo. triggers \uf0c1 adding your own triggers \uf0c1 First, write your trigger code, using the documentation here . Note especially the sections \"common arguments\" and \"trigger-specific arguments\". Look in the shipped triggers for ideas. Note: If your trigger is a perl module, as opposed to a standalone script or executable, please see the section on adding a perl module as a trigger . Let's say your trigger is called foo , and it will be a PRE_GIT trigger. add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$ENV{HOME}/local\", copy the program foo into $HOME/local/triggers . (Don't forget the chmod +x !) edit ~/.gitolite.rc again, and look for a PRE_GIT section. If it exists, add 'foo', (note the trailing comma!) to it. If it does not exist, add this block just before the ENABLE section: PRE_GIT => [ 'foo' ], (again, note the trailing comma at the end of the block!) After saving the file, test that this worked by running gitolite query-rc PRE_GIT ; your foo should be in the output list. If it's not, back up and double check your work. That should be it. VREFs \uf0c1 adding your own VREFs \uf0c1 Adding VREFs is the same as adding the update hook, so please see the section on \"adding your own update hooks\" above. example VREFs \uf0c1 However, writing a proper VREF is not the same as writing a normal git \"update hook\". A proper VREF does more than just take 3 arguments, do something, and exit with a non-zero exit code for failure. A VREF is called with at least 4 more arguments after the 3 that git itself defines for an update hook, plus usually at least one or two more. It also returns a lot more meaningful results via STDOUT. Here are some examples. I also advise you to keep a browser tab open to the doc on VREF arguments as you look at these. Important: VREFs only come into play for push operations. When we say \"access\" in this section, we mean only write access. If you want to restrict it even for reads, you can do this in a PRE_GIT trigger; there's an example in contrib/triggers/IP-check in the gitolite source tree that may be useful as a template. example 1: restricting by day of week \uf0c1 Here's the conf extract to say \"junior devs can only push on weekdays\": repo foo - VREF/DAY/Sat = @junior-devs - VREF/DAY/Sun = @junior-devs The code for this VREF is ridiculously simple: #!/bin/bash echo VREF/DAY/ `date +%a` On encountering the VREF rules (i.e., when a junior dev tries to push to this repo), gitolite calls the \"DAY\" VREF-maker. The code within the VREF maker simply echoes something like \"VREF/DAY/Mon\", where the last part is whatever the actual day of the week happens to be. This output is then treated as a virtual ref and matched against the rules. On a Monday to Friday, nothing happens, because the VREFs generated do not match any deny rules (or indeed any rules at all). On weekends, they do match, and the push is denied. example 2: restricting by source IP address \uf0c1 This one restricts junior developers to push to this repo only from a specific network block. The conf file here is slightly different. We know that the VREF-maker will return with some network address (as you'll see in the code later), so we set it up so that the correct network block is allowed and anything else is disallowed: repo foo RW+ VREF/FROM/192.168.48.0/23 = @junior-devs - VREF/FROM = @junior-devs The code is not that complex. We take the user's actual IP address (this is available as the first word in $SSH_CONNECTION for ssh users, and for smart-http users, gitolite fakes it and creates that variable!). We then treat the \"23\" in the VREF rule, which appears to the code as $9 , as the number of bits in the network address, then compute the network address for the users IP with that number of bits. This network address is then sent back. (The $9 is added back at the end, but this is only to enable it to match the VREF rule). #!/bin/bash # exit if no arguments were supplied to the VREF. This covers the # second VREF rule in the conf above [ -n \" $8 \" ] || exit 0 from = ${ SSH_CONNECTION %% * } eval `ipcalc -n $from / $9 ` # sets env var \"NETWORK\" echo VREF/FROM/ $NETWORK / $9 For a source IP of 192.168.49.97, this runs ipcalc -n 192.168.49.97/23 , which gives the network address 192.168.48.0. The echo then just sends back VREF/FROM/192.168.48.0/23. This VREF matches the RW+ line. But if the IP is, say, 192.168.45.67, running ipcalc -n 192.168.45.67/23 gives you 192.168.44.0. The echo then send back VREF/FROM/192.18.44.0/23, which won't match the RW+ line, but will match the next one and thus deny the push. (One thing that may not be obvious in this specific example is that you have to be careful when constructing the VREF rule. For any VREF/FROM/A/B, the result of running ipcalc -n A/B must be A, otherwise this won't work. That is, the bits of the network address after the network bits must be zero). wild repos \uf0c1 making exceptions for specific instances of a wild repo \uf0c1 Sometimes you want to specify rules or config for specific instances of a wild repo, while still leaving it to be created by a user in the normal way. This will not work: repo foo/..* C = blah blah RW+ = CREATOR RW = WRITERS R = READERS # this does NOT work repo foo/special-1 RW+ = sitaram option foo.bar = baz The repo will be created as a normal (not wild) repo as soon as you push, which means you can't run the perms command on it to add people to the READERS and WRITERS roles , or do other things that wild repos allow. The mental nudge you need to deal with this is to think what you would do if you had to write the same rule for more than one repo, say, any repo starting with \"foo/special-\" followed by a number. You'd use a pattern. And a pattern prevents an ordinary repo from being created. So do this: # this will work repo foo/special-[1] RW+ = sitaram option foo.bar = baz Using a pattern for just one repo might sound like a kludge, but it's perfectly valid and supported. Note that you do NOT need a \"C\" rule in there, since the pattern is a subset of the previous one ( foo/..* ), everything there applies to this repo also. If you're not sure why that is, you may need to read up on rule accumulation . moving stuff around \uf0c1 moving a gitolite install from one machine to another \uf0c1 See moving servers .","title":"(quick! how do I...) the cookbook"},{"location":"cookbook.html#gitolite-cookbook","text":"(a.k.a. \"stop all that rambling and just tell me what I need to do!\") Documentation is meant to be as complete as possible, which means it attempts to cover all situations and scenarios. That makes it harder to read. However, if you make some assumptions, remove the rationale, justification, exceptions and special cases, etc., and generally just say what is to be done rather than explain why , many tasks can be described very easily. Or, if the main documentation already does that, a cookbook may help you find it faster, simply because it's organised differently. Maybe this will help. If you run into problems, please check the main documentation before asking for help.","title":"gitolite cookbook"},{"location":"cookbook.html#administration","text":"","title":"administration"},{"location":"cookbook.html#separating-key-admin-from-repo-admin","text":"In gitolite, the person who controls the keys is the most critical in terms of security -- because he can always add his own key in your name :-) Traditionally, the same person also administers repos and permissions. But sometimes you want to separate them. To separate those roles, put the following in conf/gitolite.conf, and let the repo-manager manage everything through \"actual.conf\": repo gitolite-admin RW+ = key-manager repo-manager RW+ VREF/ NAME/ = key-manager - VREF/ NAME/ keydir/ = @all - VREF/ NAME/ conf/gitolite.conf = @all include \"actual.conf\"","title":"separating \"key admin\" from \"repo admin\""},{"location":"cookbook.html#access","text":"","title":"access"},{"location":"cookbook.html#looking-up-repo-access-from-external-tools","text":"There are two supported interfaces for this, one in perl and one in shell. Other languages should probably use the shell mode. (The shell mode has a very convenient \"batch\" mode if you need to check many repos at once). Perl interface : A good intro to this, including a link to code, using gitweb as an example can be found by looking for 'repo-specific authorisation in gitweb' in the page on allowing access to gitweb and git-daemon . Some notes: be sure to read the comments in the code to learn exactly how to adapt it to your needs in place of the can_read function in that code, you can of course use can_write . In fact, reading the comments in \"Easy.pm\" (look for it in the source) shows you several other interesting tests you can make, like is_admin , in_group , and owns . Shell interface : If you want to do this from shell, it's even easier. The same \"Easy.pm\" source contains comments that show shell equivalents for each of the functions it exports, but here's a sample: if gitolite access -q reponame username W then ... You can even test for access to specific branches: if gitolite access -q reponame username W master then ... If your gitolite is older than v3.6, you must use the full ref name; just 'master' won't do.","title":"looking up repo access from external tools"},{"location":"cookbook.html#allowing-access-by-other-programs","text":"Giving external tools (like apache) access to gitolite repositories involves making sure that the unix owner/group and permissions settings allow this. This is all described in the UMASK section in the page on the rc file , because that's the only setting that gitolite controls; every thing else is pure Unix.","title":"allowing access by other programs"},{"location":"cookbook.html#commands","text":"","title":"commands"},{"location":"cookbook.html#adding-your-own-commands","text":"To add a command, say foo , do this: add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$ENV{HOME}/local\", copy the program foo into $HOME/local/commands . (Don't forget the chmod +x !)","title":"adding your own commands"},{"location":"cookbook.html#making-commands-available-to-remote-users","text":"Once you do the above, foo is available as gitolite foo . To make it available to remote users (as ssh git@host foo ), add the line: `foo`, (including the comma at the end) to the ENABLE list in the rc file.","title":"making commands available to remote users"},{"location":"cookbook.html#hooks","text":"Note: the main documentation for this feature starts here .","title":"hooks"},{"location":"cookbook.html#adding-your-own-update-hooks","text":"You have some update hooks (for example crlf checking) that you want to include in gitolite. Assuming the hook itself is tested and works as a normal git update hook does (i.e., conforms to what man githooks says an update hook should do), here's how to do this: add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$ENV{HOME}/local\", copy your update hook to a subdirectory called VREF under this directory, giving it a suitable name (let's say \"crlf\"): # log on to gitolite hosting user on the server, then: cd $HOME mkdir -p local/VREF cp your-crlf-update-hook local/VREF/crlf chmod +x local/VREF/crlf in your gitolite-admin clone, edit conf/gitolite.conf and add lines like this: - VREF/crlf = @all to each repo that should have that \"update\" hook. Alternatively, you can simply add this at the end of the gitolite.conf file: repo @all - VREF/crlf = @all Either way, add/commit/push the change to the gitolite-admin repo.","title":"adding your own update hooks"},{"location":"cookbook.html#adding-other-non-update-hooks","text":"Say you want other hooks, like a post-receive hook. Here's how: add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$ENV{HOME}/local\", put your hooks into that directory, in a sub-sub-directory called \"hooks/common\": # log on to gitolite hosting user on the server, then: cd $HOME mkdir -p local/hooks/common cp your-post-receive-hook local/hooks/common/post-receive chmod +x local/hooks/common/post-receive run gitolite setup to have the hooks propagate to existing repos (repos created after this will get them anyway).","title":"adding other (non-update) hooks"},{"location":"cookbook.html#variation-maintain-these-hooks-in-the-gitolite-admin-repo","text":"Important security note: If you enable this, anyone who can push changes to the admin repo will effectively be able to run any arbitrary command on the server. See gitolite admin and shell access for more background. If you want to maintain these update hooks (VREFs) or non-update hooks (post-update, pre-receive, post-receive) in the gitolite-admin repo, instead of having to log on to the server and make changes, the procedure is almost the same except for the following differences: add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$rc{GL_ADMIN_BASE}/local\", Notice \"local\" is not in $HOME like in the previous examples! the hooks/scripts are to be added inside your gitolite-admin clone, not on the server. That is, whereever the above two sections say cd $HOME , you should read it as \"cd /path/to/your/gitolite-admin-clone\". (The directory local will be within this clone of course, not in $HOME .) add/commit/push as usual. For update hooks, you will of course need to add VREF rule lines to appropriate repos in the conf file. For non-update hooks, you don't need to run 'gitolite setup' on the server; the push takes care of that.","title":"variation: maintain these hooks in the gitolite-admin repo"},{"location":"cookbook.html#v36-variation-repo-specific-hooks","text":"Until now, the non-update hooks you specified apply to all repos. Here's how to apply them only to certain repos: add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$rc{GL_ADMIN_BASE}/local\", uncomment the 'repo-specific-hooks' line in the rc file or add it to the ENABLE list if it doesn't exist. If your rc file does not have an ENABLE list, you need to add this to the POST_COMPILE and the POST_CREATE lists. Click here for more on all this. put your hooks into your gitolite-admin clone, as follows: # on your workstation cd /path/to/your/gitolite-admin-clone mkdir -p local/hooks/repo-specific Now add your hooks to that directory, but instead of using the git \"standard\" names (pre-receive, post-receive, post-update), you use descriptive names (e.g. \"deploy\", \"RSS-post\", etc). For pre-receive or pre-auto-gc you should not use more than one hook. If you really need more than one, ask on the mailing list. add them to the repos you want them to be active in, in your conf file. For example: repo foo option hook.post-update = jenkins repo bar @baz option hook.post-update = deploy RSS-post add, commit, and push the admin repo.","title":"(v3.6+) variation: repo-specific hooks"},{"location":"cookbook.html#triggers","text":"","title":"triggers"},{"location":"cookbook.html#adding-your-own-triggers","text":"First, write your trigger code, using the documentation here . Note especially the sections \"common arguments\" and \"trigger-specific arguments\". Look in the shipped triggers for ideas. Note: If your trigger is a perl module, as opposed to a standalone script or executable, please see the section on adding a perl module as a trigger . Let's say your trigger is called foo , and it will be a PRE_GIT trigger. add this line in the rc file, within the %RC block, if it's not already present, or uncomment it if it's already present and commented out: LOCAL_CODE => \"$ENV{HOME}/local\", copy the program foo into $HOME/local/triggers . (Don't forget the chmod +x !) edit ~/.gitolite.rc again, and look for a PRE_GIT section. If it exists, add 'foo', (note the trailing comma!) to it. If it does not exist, add this block just before the ENABLE section: PRE_GIT => [ 'foo' ], (again, note the trailing comma at the end of the block!) After saving the file, test that this worked by running gitolite query-rc PRE_GIT ; your foo should be in the output list. If it's not, back up and double check your work. That should be it.","title":"adding your own triggers"},{"location":"cookbook.html#vrefs","text":"","title":"VREFs"},{"location":"cookbook.html#adding-your-own-vrefs","text":"Adding VREFs is the same as adding the update hook, so please see the section on \"adding your own update hooks\" above.","title":"adding your own VREFs"},{"location":"cookbook.html#example-vrefs","text":"However, writing a proper VREF is not the same as writing a normal git \"update hook\". A proper VREF does more than just take 3 arguments, do something, and exit with a non-zero exit code for failure. A VREF is called with at least 4 more arguments after the 3 that git itself defines for an update hook, plus usually at least one or two more. It also returns a lot more meaningful results via STDOUT. Here are some examples. I also advise you to keep a browser tab open to the doc on VREF arguments as you look at these. Important: VREFs only come into play for push operations. When we say \"access\" in this section, we mean only write access. If you want to restrict it even for reads, you can do this in a PRE_GIT trigger; there's an example in contrib/triggers/IP-check in the gitolite source tree that may be useful as a template.","title":"example VREFs"},{"location":"cookbook.html#example-1-restricting-by-day-of-week","text":"Here's the conf extract to say \"junior devs can only push on weekdays\": repo foo - VREF/DAY/Sat = @junior-devs - VREF/DAY/Sun = @junior-devs The code for this VREF is ridiculously simple: #!/bin/bash echo VREF/DAY/ `date +%a` On encountering the VREF rules (i.e., when a junior dev tries to push to this repo), gitolite calls the \"DAY\" VREF-maker. The code within the VREF maker simply echoes something like \"VREF/DAY/Mon\", where the last part is whatever the actual day of the week happens to be. This output is then treated as a virtual ref and matched against the rules. On a Monday to Friday, nothing happens, because the VREFs generated do not match any deny rules (or indeed any rules at all). On weekends, they do match, and the push is denied.","title":"example 1: restricting by day of week"},{"location":"cookbook.html#example-2-restricting-by-source-ip-address","text":"This one restricts junior developers to push to this repo only from a specific network block. The conf file here is slightly different. We know that the VREF-maker will return with some network address (as you'll see in the code later), so we set it up so that the correct network block is allowed and anything else is disallowed: repo foo RW+ VREF/FROM/192.168.48.0/23 = @junior-devs - VREF/FROM = @junior-devs The code is not that complex. We take the user's actual IP address (this is available as the first word in $SSH_CONNECTION for ssh users, and for smart-http users, gitolite fakes it and creates that variable!). We then treat the \"23\" in the VREF rule, which appears to the code as $9 , as the number of bits in the network address, then compute the network address for the users IP with that number of bits. This network address is then sent back. (The $9 is added back at the end, but this is only to enable it to match the VREF rule). #!/bin/bash # exit if no arguments were supplied to the VREF. This covers the # second VREF rule in the conf above [ -n \" $8 \" ] || exit 0 from = ${ SSH_CONNECTION %% * } eval `ipcalc -n $from / $9 ` # sets env var \"NETWORK\" echo VREF/FROM/ $NETWORK / $9 For a source IP of 192.168.49.97, this runs ipcalc -n 192.168.49.97/23 , which gives the network address 192.168.48.0. The echo then just sends back VREF/FROM/192.168.48.0/23. This VREF matches the RW+ line. But if the IP is, say, 192.168.45.67, running ipcalc -n 192.168.45.67/23 gives you 192.168.44.0. The echo then send back VREF/FROM/192.18.44.0/23, which won't match the RW+ line, but will match the next one and thus deny the push. (One thing that may not be obvious in this specific example is that you have to be careful when constructing the VREF rule. For any VREF/FROM/A/B, the result of running ipcalc -n A/B must be A, otherwise this won't work. That is, the bits of the network address after the network bits must be zero).","title":"example 2: restricting by source IP address"},{"location":"cookbook.html#wild-repos","text":"","title":"wild repos"},{"location":"cookbook.html#making-exceptions-for-specific-instances-of-a-wild-repo","text":"Sometimes you want to specify rules or config for specific instances of a wild repo, while still leaving it to be created by a user in the normal way. This will not work: repo foo/..* C = blah blah RW+ = CREATOR RW = WRITERS R = READERS # this does NOT work repo foo/special-1 RW+ = sitaram option foo.bar = baz The repo will be created as a normal (not wild) repo as soon as you push, which means you can't run the perms command on it to add people to the READERS and WRITERS roles , or do other things that wild repos allow. The mental nudge you need to deal with this is to think what you would do if you had to write the same rule for more than one repo, say, any repo starting with \"foo/special-\" followed by a number. You'd use a pattern. And a pattern prevents an ordinary repo from being created. So do this: # this will work repo foo/special-[1] RW+ = sitaram option foo.bar = baz Using a pattern for just one repo might sound like a kludge, but it's perfectly valid and supported. Note that you do NOT need a \"C\" rule in there, since the pattern is a subset of the previous one ( foo/..* ), everything there applies to this repo also. If you're not sure why that is, you may need to read up on rule accumulation .","title":"making exceptions for specific instances of a wild repo"},{"location":"cookbook.html#moving-stuff-around","text":"","title":"moving stuff around"},{"location":"cookbook.html#moving-a-gitolite-install-from-one-machine-to-another","text":"See moving servers .","title":"moving a gitolite install from one machine to another"},{"location":"deleg.html","text":"delegating access control responsibilities \uf0c1 Delegation allows you to divide up a large conf file into smaller groups of repos (called subconf s) and hand over responsibility to manage them to sub-admin s. Gitolite can prevent one sub-admin from being able to set access rules for any other sub-admin's repos. Delegation is achieved by combining two gitolite features: subconf and the NAME VREF . example \uf0c1 Here's a sample conf that does delegation: @webbrowsers = firefox lynx browsers/..* @webservers = apache nginx servers/..* @malwares = conficker storm ms/..* # side note: if anyone objects, we claim ms stands for \"metasploit\" ;-) # the admin repo access probably had these 2 lines to start with: repo gitolite-admin RW+ = sitaram # now add these lines to the config for the admin repo RW = alice bob mallory RW VREF/ NAME/ conf/subs/webbrowsers = alice RW VREF/ NAME/ conf/subs/webservers = bob RW VREF/ NAME/ conf/subs/malwares = mallory - VREF/ NAME/ = alice bob mallory # pull in these files using the \"subconf\" command subconf \"subs/*.conf\" If you've read the VREF part, or at least understood how NAME VREF s work, it should be clear that, in terms of changes to the gitolite-admin repo: The user sitaram has no restrictions of any kind Users alice, bob, and mallory can only touch files within their assigned areas within conf/subs. If they try to change any other file (keydir, conf/gitolite.conf, or something in one of the other sub-admin's areas), then the last rule kicks in and the push gets rejected. Now all we need is to see what this \"subconf\" thing is all about. the subconf command \uf0c1 Subconf is exactly like the include command in syntax: subconf \"foo.conf\" but while reading the included file (as well as anything included from it), gitolite sets the \"current subconf name\" to \"foo\". A \"subconf\" imposes some restrictions on what repos can be managed. For example, while the subconf name is \"foo\", as in the above example, gitolite will only process \"repo\" lines for: A repo called \"foo\". A group called \"@foo\", as long as the group is defined in the main conf file (i.e., outside \"foo.conf\"). A member of a group called \"@foo\" (again, defined outside). A repo that matches a member of a group called \"@foo\" if that member is a regular expression. Here's an example. If the main conf file contains @foo = aa bb cc/..* then the subconf can only accept repo statements that refer to 'foo', '@foo', 'aa', 'bb', or any repo whose name starts with 'cc/'. Note : the subconf name \"master\" is special; it is the default subconf in effect for the main conf file and has no restrictions. how the \"subconf name\" is derived \uf0c1 For subconf lines that look just like include statements, i.e., subconf \"foo/bar.conf\" subconf \"frob/*.conf\" # assume frob has files aa.conf, bb.conf the subconf name as each file is being processed is the base name of the file. This means it would be \"bar\" for the first line, \"aa\" when processing \"frob/aa.conf\", and \"bb\" when processing \"frob/bb.conf\". A variation of subconf exists that can explicitly state the subconf name: subconf foo \"frob/*.conf\" In this variation, regardless of what file in \"frob/\" is being read, the subconf name in effect is \"foo\". security notes \uf0c1 group names \uf0c1 You can use \"@group\"s defined in the main config file but do not attempt to redefine or extend them in your own subconf file. If you must extend a group (say @foo ) defined in the main config file, do this: @myfoo = @foo # now do whatever you want with @myfoo Group names you define in your subconf will not clash even if the exact same name is used in another subconf file, so you need not worry about that. delegating pubkeys \uf0c1 Short answer: not gonna happen. The delegation feature is meant only for access control rules, not pubkeys. Adding/removing pubkeys is a much more significant event than changing branch level permissions for people already on staff, and only the main admin should be allowed to do it. Gitolite's \"userids\" all live in the same namespace. This is unlikely to change, so please don't ask -- it gets real complicated to do otherwise. Allowing sub-admins to add users means username collisions, which also means security problems (admin-A creates a pubkey for Admin-B, thus gaining access to all of Admin-B's stuff). If you feel the need to delegate even that, please just go the whole hog and give them separate gitolite instances (i.e., running on different servers, or at least under different gitolite hosting users on the same server)!","title":"delegation of admin duties"},{"location":"deleg.html#delegating-access-control-responsibilities","text":"Delegation allows you to divide up a large conf file into smaller groups of repos (called subconf s) and hand over responsibility to manage them to sub-admin s. Gitolite can prevent one sub-admin from being able to set access rules for any other sub-admin's repos. Delegation is achieved by combining two gitolite features: subconf and the NAME VREF .","title":"delegating access control responsibilities"},{"location":"deleg.html#example","text":"Here's a sample conf that does delegation: @webbrowsers = firefox lynx browsers/..* @webservers = apache nginx servers/..* @malwares = conficker storm ms/..* # side note: if anyone objects, we claim ms stands for \"metasploit\" ;-) # the admin repo access probably had these 2 lines to start with: repo gitolite-admin RW+ = sitaram # now add these lines to the config for the admin repo RW = alice bob mallory RW VREF/ NAME/ conf/subs/webbrowsers = alice RW VREF/ NAME/ conf/subs/webservers = bob RW VREF/ NAME/ conf/subs/malwares = mallory - VREF/ NAME/ = alice bob mallory # pull in these files using the \"subconf\" command subconf \"subs/*.conf\" If you've read the VREF part, or at least understood how NAME VREF s work, it should be clear that, in terms of changes to the gitolite-admin repo: The user sitaram has no restrictions of any kind Users alice, bob, and mallory can only touch files within their assigned areas within conf/subs. If they try to change any other file (keydir, conf/gitolite.conf, or something in one of the other sub-admin's areas), then the last rule kicks in and the push gets rejected. Now all we need is to see what this \"subconf\" thing is all about.","title":"example"},{"location":"deleg.html#the-subconf-command","text":"Subconf is exactly like the include command in syntax: subconf \"foo.conf\" but while reading the included file (as well as anything included from it), gitolite sets the \"current subconf name\" to \"foo\". A \"subconf\" imposes some restrictions on what repos can be managed. For example, while the subconf name is \"foo\", as in the above example, gitolite will only process \"repo\" lines for: A repo called \"foo\". A group called \"@foo\", as long as the group is defined in the main conf file (i.e., outside \"foo.conf\"). A member of a group called \"@foo\" (again, defined outside). A repo that matches a member of a group called \"@foo\" if that member is a regular expression. Here's an example. If the main conf file contains @foo = aa bb cc/..* then the subconf can only accept repo statements that refer to 'foo', '@foo', 'aa', 'bb', or any repo whose name starts with 'cc/'. Note : the subconf name \"master\" is special; it is the default subconf in effect for the main conf file and has no restrictions.","title":"the subconf command"},{"location":"deleg.html#how-the-subconf-name-is-derived","text":"For subconf lines that look just like include statements, i.e., subconf \"foo/bar.conf\" subconf \"frob/*.conf\" # assume frob has files aa.conf, bb.conf the subconf name as each file is being processed is the base name of the file. This means it would be \"bar\" for the first line, \"aa\" when processing \"frob/aa.conf\", and \"bb\" when processing \"frob/bb.conf\". A variation of subconf exists that can explicitly state the subconf name: subconf foo \"frob/*.conf\" In this variation, regardless of what file in \"frob/\" is being read, the subconf name in effect is \"foo\".","title":"how the \"subconf name\" is derived"},{"location":"deleg.html#security-notes","text":"","title":"security notes"},{"location":"deleg.html#group-names","text":"You can use \"@group\"s defined in the main config file but do not attempt to redefine or extend them in your own subconf file. If you must extend a group (say @foo ) defined in the main config file, do this: @myfoo = @foo # now do whatever you want with @myfoo Group names you define in your subconf will not clash even if the exact same name is used in another subconf file, so you need not worry about that.","title":"group names"},{"location":"deleg.html#delegating-pubkeys","text":"Short answer: not gonna happen. The delegation feature is meant only for access control rules, not pubkeys. Adding/removing pubkeys is a much more significant event than changing branch level permissions for people already on staff, and only the main admin should be allowed to do it. Gitolite's \"userids\" all live in the same namespace. This is unlikely to change, so please don't ask -- it gets real complicated to do otherwise. Allowing sub-admins to add users means username collisions, which also means security problems (admin-A creates a pubkey for Admin-B, thus gaining access to all of Admin-B's stuff). If you feel the need to delegate even that, please just go the whole hog and give them separate gitolite instances (i.e., running on different servers, or at least under different gitolite hosting users on the same server)!","title":"delegating pubkeys"},{"location":"dev-notes.html","text":"writing your own \"non-core\" programs \uf0c1 This page is about writing hooks, commands, triggers, VREFS, and sugar scripts. Installing them, including \"where and how\", is described here . Note: the non-core page is the starting point for all information about customising gitolite. environment variables and other inputs \uf0c1 In general, the following environment variables should always be available: GL_BINDIR GL_REPO_BASE GL_ADMIN_BASE GL_BINDIR is loosely equivalent to GIT_EXEC_PATH in git. GL_REPO_BASE is always $HOME/repositories , and GL_ADMIN_BASE is $HOME/.gitolite . (You might ask why, if they're fixed values, do we need those variables. Good question... next!) In addition, commands invoked by a remote client also have GL_USER , while hooks have GL_USER as well as GL_REPO (which is the logical reponame ). A special form of the option syntax can be used to set repo-specific environment variables . Finally, note that triggers get a lot of relevant information from gitolite as arguments; see here for details. APIs \uf0c1 the shell API \uf0c1 The following commands exist to help you write shell scripts that interact easily with gitolite. Each of them responds to -h so please run that for more info. gitolite access to check access rights given repo, user, type of access (R, W, ...) and refname (optional). Example use: src/commands/desc. gitolite creator to get/check the creator of a repo. Example use: src/commands/desc. gitolite git-config to check gitolite options or git config variables directly from gitolite's \"compiled\" output, (i.e., without looking at the actual repo.git/config file or using the git config command). Example use: src/triggers/post-compile/update-gitweb-access-list. gitolite query-rc to check the value of an RC variable. Example use: src/commands/desc. In addition, you can also look at the comments in src/lib/Gitolite/Easy.pm (the perl API module) for ideas. the perl API \uf0c1 ...is implemented by Gitolite::Easy ; the comments in src/lib/Gitolite/Easy.pm serve as documentation. Note that some of the perl functions called by Easy.pm will change the current directory to something else, without saving and restoring the directory. Patches (to Easy.pm only ) welcome. writing your own... \uf0c1 ...commands \uf0c1 Commands are standalone programs, in any language you like. They simply receive the arguments you append. In addition, the env var GL_USER is available if it is being run remotely. src/commands/desc is the best example at present. ...hooks \uf0c1 anything but the update hook \uf0c1 If you want to add any hook other than the update hook, 'man githooks' is all you need. update hook \uf0c1 If you want to add additional update hook functionality, do this: Write and test your update hook separately from gitolite. Now add the code as a VREF (see here for details). Let's say you called it \"foo\". To call your new update hook to all accesses for all repos, add this to the end of your conf file: repo @all - VREF/foo = @all As you probably guessed, you can make your additional update hooks more selective, applying them only to some repos / users / combinations. Note: a normal update hook expects 3 arguments (ref, old SHA, new SHA). A VREF will get those three, followed by at least 4 more. Your VREF should just ignore the extra args. ...trigger programs \uf0c1 Trigger programs run at specific points in gitolite's execution, with specific arguments being passed to them. See the triggers page for details. You can write programs that are both manually runnable as well as callable by trigger events, especially if they don't need any arguments. ...\"sugar\" \uf0c1 Syntactic sugar helpers are NOT complete, standalone, programs. They must include a perl sub called sugar_script that takes in a listref, and returns a listref. The listrefs point to a list that contains the entire conf file (with all include processing already done). You create a new list with contents modified as you like and return a ref to it. There are a couple of examples in src/syntactic-sugar. appendix 1: repo-specific environment variables \uf0c1 A special form of the option syntax can be used to set repo-specific environment variables that are visible to gitolite triggers and any git hooks you may install. For example, let's say you installed a post-update hook that initiates a CI job. By default, of course, this hook will be active for all gitolite-managed repos. However, you only want it to run for some specific repos, say r1, r2, and r4. To do that, first add this to the gitolite.conf: repo r1 r2 r4 option ENV.CI = 1 This creates an environment variable called GL_OPTION_CI with the value 1, before any trigger or hook is invoked. Note: option names must start with ENV. , followed by a seqence of characters composed of alphas, numbers, and the underscore character. Now the hook running the CI job can easily decide what to do: # exit if $GL_OPTION_CI is not set [ -z $GL_OPTION_CI ] && exit ... rest of CI job code as before ... Of course you can also do the opposite; i.e. decide that the listed repos should not run the CI job but all other repos should: repo @all option ENV.CI = 1 repo r1 r2 r4 option ENV.CI = \"\" (The hook code remains the same as before.) Before this feature was added, you could still do this, by using the gitolite git-config command inside the hook code to test for options and configs set for the repo, like: if gitolite git-config -q reponame gitolite-options.option-name then ... The new method is much more convenient, as you can see. appendix 2: log file format \uf0c1 Here's a brief description of gitolite's log file format. All fields are tab separated. There are two kinds of lines in the log file: third field non-empty: actual log lines. These are documented below. third field empty (i.e., two tabs after the second field): extra output to help diagnose problems. These are NOT documented and may change without notice. They can be turned off completely by setting the RC variable LOG_EXTRA to 0. For all types of log lines, the first two fields are: field 1: local time, in YYYY-MM-DD.HH:MM:SS format field 2: transaction ID or \"TID\". This is actually the PID of the outermost command that was initiated (usually \"gitolite-shell\"). It helps to keep log lines pertaining to one \"run\" together, even if several sub-commands are spawned (like for example from triggers, or even the update hook itself). The third and later fields are all dependent on what type of log line it is. The various log line formats are: start This line denotes the beginning of a gitolite operation. field 3: 'ssh' or 'http' field 4: ARGV=<comma-separated list of command line arguments> Usually this is just the gitolite username (the argument to gitolite-shell, as supplied by the forced command in the authorized keys file). If you're giving shell access to some users, this would be -s,username . That's two command line arguments (\"-s\" and the username), comma separated. field 5: SOC=<original command from client> This is the command exactly as the git client sent it, or the user typed it. Typically this is one of these: git-upload-pack 'reponame' git-receive-pack 'reponame' (including the single quotes, because that's what the client sent). Gitolite commands are also recorded as is, so this could be something like info or perhaps perms -l reponame etc. field 6: FROM=<ip address> pre-git This log line appears when the first access check succeeds (i.e., before git-upload-pack or git-receive-pack is called). field 3: 'pre_git' field 4: reponame field 5: username field 6: 'R' or 'W' field 7: 'any' field 8: the refex that allowed access update This log line appears when the second access check succeeds (i.e., when the update hook decides to allow the push). field 3: 'update' field 4: reponame field 5: username field 6: 'W', '+', 'C', 'D', 'WM', '+M', 'CM', or 'DM' field 7: ref name (like 'refs/heads/master') field 8: old SHA field 9: new SHA field 10: the refex that allowed access The values in field 6 reflect the possible write types , but note that there is a difference between what the log file contains and what the gitolite.conf file contains (e.g., + versus RW+ ). There's another subtle difference for those who are not thinking clearly: the RW+ in the conf file is a permission, but it would show up as a + in the log file only if an actual force push had happened, otherwise it would be just W . By the way, notice that fields 7 to 9 are exactly what git itself supplies the update hook (see 'man githooks'). There is a special version of this line that appears when someone bypasses gitolite's access control to push directly on the server. The 'reponame' (field 4) is replaced by the full path of the repo being pushed to, the username (field 5) is replaced by the Unix userid in parentheses, and the operation code (field 6) is 'bypass'. create This log line appears when a wild repo was auto-created by a user. field 3: 'create' field 4: reponame field 5: username field 6: 'R' or 'W' Field 6 is 'perms-c' if the wild repo is created using the perms command's '-c' option. end This indicates the end of the transaction. Normally, you should not see any more lines with the same TID after this line. field 3: 'END' warnings and errors Typically seen when access is denied. field 3: 'warn' or 'die' field 4: message. Parts of the message (like reponame, username, etc) are not split out into fields, though. cli This logs gitolite sub-commands run directly on the server, like gitolite setup etc. field 3: 'cli' field 4: 'gitolite' field 5 to end: arguments supplied to gitolite command, one per field appendix 3: sending log lines to syslog \uf0c1 Gitolite allows you to send log entries to syslog. To do that, uncomment one of the commented out values for LOG_DEST in the rc file. If your rc file does not have any such lines, add one of the following lines just after the LOG_EXTRA line: # use this to log only to syslog LOG_DEST => 'syslog', # use this to log to syslog and the normal gitolite log LOG_DEST => 'syslog,normal', Please note: The first two fields described in the previous section (time, TID) are different. Syslog takes care of putting in the time, and the TID is appended to the ident, so instead of just 'gitolite', you get 'gitolite[$GL_TID]'. This means actual log lines will look something like this, since syslog appends the actual PID to the ident as well: Jun 3 09:26:11 sita-lt gitolite[14950][14950]: ssh ARGV=admin SOC=git-receive-pack 'gitolite-admin' FROM=::1 Jun 3 09:26:11 sita-lt gitolite[14950][14950]: pre_git gitolite-admin admin W any refs/.* Jun 3 09:26:11 sita-lt gitolite[14950][14991]: update gitolite-admin admin W refs/heads/master [snip] Jun 3 09:26:13 sita-lt gitolite[14950][14950]: END Normal log messages use the 'info' priority, while LOG_EXTRA messages (see previous section) use the 'debug' priority. It may be useful to send the debug output to a different output file. Unlike in the normal gitolite logs, where there is an extra tab character (or, an empty field, depending on how you look at it), the syslog lines do not let you easily distinguish between the main log lines and the LOG_EXTRA lines.","title":"writing your own non-core code"},{"location":"dev-notes.html#writing-your-own-non-core-programs","text":"This page is about writing hooks, commands, triggers, VREFS, and sugar scripts. Installing them, including \"where and how\", is described here . Note: the non-core page is the starting point for all information about customising gitolite.","title":"writing your own \"non-core\" programs"},{"location":"dev-notes.html#environment-variables-and-other-inputs","text":"In general, the following environment variables should always be available: GL_BINDIR GL_REPO_BASE GL_ADMIN_BASE GL_BINDIR is loosely equivalent to GIT_EXEC_PATH in git. GL_REPO_BASE is always $HOME/repositories , and GL_ADMIN_BASE is $HOME/.gitolite . (You might ask why, if they're fixed values, do we need those variables. Good question... next!) In addition, commands invoked by a remote client also have GL_USER , while hooks have GL_USER as well as GL_REPO (which is the logical reponame ). A special form of the option syntax can be used to set repo-specific environment variables . Finally, note that triggers get a lot of relevant information from gitolite as arguments; see here for details.","title":"environment variables and other inputs"},{"location":"dev-notes.html#apis","text":"","title":"APIs"},{"location":"dev-notes.html#the-shell-api","text":"The following commands exist to help you write shell scripts that interact easily with gitolite. Each of them responds to -h so please run that for more info. gitolite access to check access rights given repo, user, type of access (R, W, ...) and refname (optional). Example use: src/commands/desc. gitolite creator to get/check the creator of a repo. Example use: src/commands/desc. gitolite git-config to check gitolite options or git config variables directly from gitolite's \"compiled\" output, (i.e., without looking at the actual repo.git/config file or using the git config command). Example use: src/triggers/post-compile/update-gitweb-access-list. gitolite query-rc to check the value of an RC variable. Example use: src/commands/desc. In addition, you can also look at the comments in src/lib/Gitolite/Easy.pm (the perl API module) for ideas.","title":"the shell API"},{"location":"dev-notes.html#the-perl-api","text":"...is implemented by Gitolite::Easy ; the comments in src/lib/Gitolite/Easy.pm serve as documentation. Note that some of the perl functions called by Easy.pm will change the current directory to something else, without saving and restoring the directory. Patches (to Easy.pm only ) welcome.","title":"the perl API"},{"location":"dev-notes.html#writing-your-own","text":"","title":"writing your own..."},{"location":"dev-notes.html#commands","text":"Commands are standalone programs, in any language you like. They simply receive the arguments you append. In addition, the env var GL_USER is available if it is being run remotely. src/commands/desc is the best example at present.","title":"...commands"},{"location":"dev-notes.html#hooks","text":"","title":"...hooks"},{"location":"dev-notes.html#anything-but-the-update-hook","text":"If you want to add any hook other than the update hook, 'man githooks' is all you need.","title":"anything but the update hook"},{"location":"dev-notes.html#update-hook","text":"If you want to add additional update hook functionality, do this: Write and test your update hook separately from gitolite. Now add the code as a VREF (see here for details). Let's say you called it \"foo\". To call your new update hook to all accesses for all repos, add this to the end of your conf file: repo @all - VREF/foo = @all As you probably guessed, you can make your additional update hooks more selective, applying them only to some repos / users / combinations. Note: a normal update hook expects 3 arguments (ref, old SHA, new SHA). A VREF will get those three, followed by at least 4 more. Your VREF should just ignore the extra args.","title":"update hook"},{"location":"dev-notes.html#trigger-programs","text":"Trigger programs run at specific points in gitolite's execution, with specific arguments being passed to them. See the triggers page for details. You can write programs that are both manually runnable as well as callable by trigger events, especially if they don't need any arguments.","title":"...trigger programs"},{"location":"dev-notes.html#sugar","text":"Syntactic sugar helpers are NOT complete, standalone, programs. They must include a perl sub called sugar_script that takes in a listref, and returns a listref. The listrefs point to a list that contains the entire conf file (with all include processing already done). You create a new list with contents modified as you like and return a ref to it. There are a couple of examples in src/syntactic-sugar.","title":"...\"sugar\""},{"location":"dev-notes.html#appendix-1-repo-specific-environment-variables","text":"A special form of the option syntax can be used to set repo-specific environment variables that are visible to gitolite triggers and any git hooks you may install. For example, let's say you installed a post-update hook that initiates a CI job. By default, of course, this hook will be active for all gitolite-managed repos. However, you only want it to run for some specific repos, say r1, r2, and r4. To do that, first add this to the gitolite.conf: repo r1 r2 r4 option ENV.CI = 1 This creates an environment variable called GL_OPTION_CI with the value 1, before any trigger or hook is invoked. Note: option names must start with ENV. , followed by a seqence of characters composed of alphas, numbers, and the underscore character. Now the hook running the CI job can easily decide what to do: # exit if $GL_OPTION_CI is not set [ -z $GL_OPTION_CI ] && exit ... rest of CI job code as before ... Of course you can also do the opposite; i.e. decide that the listed repos should not run the CI job but all other repos should: repo @all option ENV.CI = 1 repo r1 r2 r4 option ENV.CI = \"\" (The hook code remains the same as before.) Before this feature was added, you could still do this, by using the gitolite git-config command inside the hook code to test for options and configs set for the repo, like: if gitolite git-config -q reponame gitolite-options.option-name then ... The new method is much more convenient, as you can see.","title":"appendix 1: repo-specific environment variables"},{"location":"dev-notes.html#appendix-2-log-file-format","text":"Here's a brief description of gitolite's log file format. All fields are tab separated. There are two kinds of lines in the log file: third field non-empty: actual log lines. These are documented below. third field empty (i.e., two tabs after the second field): extra output to help diagnose problems. These are NOT documented and may change without notice. They can be turned off completely by setting the RC variable LOG_EXTRA to 0. For all types of log lines, the first two fields are: field 1: local time, in YYYY-MM-DD.HH:MM:SS format field 2: transaction ID or \"TID\". This is actually the PID of the outermost command that was initiated (usually \"gitolite-shell\"). It helps to keep log lines pertaining to one \"run\" together, even if several sub-commands are spawned (like for example from triggers, or even the update hook itself). The third and later fields are all dependent on what type of log line it is. The various log line formats are: start This line denotes the beginning of a gitolite operation. field 3: 'ssh' or 'http' field 4: ARGV=<comma-separated list of command line arguments> Usually this is just the gitolite username (the argument to gitolite-shell, as supplied by the forced command in the authorized keys file). If you're giving shell access to some users, this would be -s,username . That's two command line arguments (\"-s\" and the username), comma separated. field 5: SOC=<original command from client> This is the command exactly as the git client sent it, or the user typed it. Typically this is one of these: git-upload-pack 'reponame' git-receive-pack 'reponame' (including the single quotes, because that's what the client sent). Gitolite commands are also recorded as is, so this could be something like info or perhaps perms -l reponame etc. field 6: FROM=<ip address> pre-git This log line appears when the first access check succeeds (i.e., before git-upload-pack or git-receive-pack is called). field 3: 'pre_git' field 4: reponame field 5: username field 6: 'R' or 'W' field 7: 'any' field 8: the refex that allowed access update This log line appears when the second access check succeeds (i.e., when the update hook decides to allow the push). field 3: 'update' field 4: reponame field 5: username field 6: 'W', '+', 'C', 'D', 'WM', '+M', 'CM', or 'DM' field 7: ref name (like 'refs/heads/master') field 8: old SHA field 9: new SHA field 10: the refex that allowed access The values in field 6 reflect the possible write types , but note that there is a difference between what the log file contains and what the gitolite.conf file contains (e.g., + versus RW+ ). There's another subtle difference for those who are not thinking clearly: the RW+ in the conf file is a permission, but it would show up as a + in the log file only if an actual force push had happened, otherwise it would be just W . By the way, notice that fields 7 to 9 are exactly what git itself supplies the update hook (see 'man githooks'). There is a special version of this line that appears when someone bypasses gitolite's access control to push directly on the server. The 'reponame' (field 4) is replaced by the full path of the repo being pushed to, the username (field 5) is replaced by the Unix userid in parentheses, and the operation code (field 6) is 'bypass'. create This log line appears when a wild repo was auto-created by a user. field 3: 'create' field 4: reponame field 5: username field 6: 'R' or 'W' Field 6 is 'perms-c' if the wild repo is created using the perms command's '-c' option. end This indicates the end of the transaction. Normally, you should not see any more lines with the same TID after this line. field 3: 'END' warnings and errors Typically seen when access is denied. field 3: 'warn' or 'die' field 4: message. Parts of the message (like reponame, username, etc) are not split out into fields, though. cli This logs gitolite sub-commands run directly on the server, like gitolite setup etc. field 3: 'cli' field 4: 'gitolite' field 5 to end: arguments supplied to gitolite command, one per field","title":"appendix 2: log file format"},{"location":"dev-notes.html#appendix-3-sending-log-lines-to-syslog","text":"Gitolite allows you to send log entries to syslog. To do that, uncomment one of the commented out values for LOG_DEST in the rc file. If your rc file does not have any such lines, add one of the following lines just after the LOG_EXTRA line: # use this to log only to syslog LOG_DEST => 'syslog', # use this to log to syslog and the normal gitolite log LOG_DEST => 'syslog,normal', Please note: The first two fields described in the previous section (time, TID) are different. Syslog takes care of putting in the time, and the TID is appended to the ident, so instead of just 'gitolite', you get 'gitolite[$GL_TID]'. This means actual log lines will look something like this, since syslog appends the actual PID to the ident as well: Jun 3 09:26:11 sita-lt gitolite[14950][14950]: ssh ARGV=admin SOC=git-receive-pack 'gitolite-admin' FROM=::1 Jun 3 09:26:11 sita-lt gitolite[14950][14950]: pre_git gitolite-admin admin W any refs/.* Jun 3 09:26:11 sita-lt gitolite[14950][14991]: update gitolite-admin admin W refs/heads/master [snip] Jun 3 09:26:13 sita-lt gitolite[14950][14950]: END Normal log messages use the 'info' priority, while LOG_EXTRA messages (see previous section) use the 'debug' priority. It may be useful to send the debug output to a different output file. Unlike in the normal gitolite logs, where there is an extra tab character (or, an empty field, depending on how you look at it), the syslog lines do not let you easily distinguish between the main log lines and the LOG_EXTRA lines.","title":"appendix 3: sending log lines to syslog"},{"location":"emergencies.html","text":"help for emergencies \uf0c1 \"Don't Panic!\" IMPORTANT Almost nothing in gitolite requires root (with some obvious exceptions). Unless the documentation says \"do this from root \", assume it is to be done from the hosting user account. install/setup issues \uf0c1 Most install/setup issues in ssh mode are caused by lack of ssh knowledge. Ssh is a complex beast, and can cause problems for people who are not familiar with its quirks. Be prepared to spend some time reading the ssh documentation that comes with gitolite . lost admin key/access \uf0c1 If you lost your gitolite admin key or access, here's what you do. We'll assume your username is \"alice\" (i.e., alice has RW or RW+ permissions on the gitolite-admin repo). Make yourself a new keypair and copy the public key to the server as 'alice.pub'. Log on to the server, and run gitolite setup -pk alice.pub . That's it; the new alice.pub file replaces whatever existed in the repo before. bypassing gitolite \uf0c1 You may have lost access because of a conf file error, in which case the above trick (which merely changes a pubkey) won't help. What you want is to make changes to the gitolite-admin repo (or perhaps just rewind) and push that. Here's how to do that: Log on to the server. Clone the admin repo using the full path: git clone $HOME/repositories/gitolite-admin.git temp 'cd' to this clone and make whatever changes you want -- add/replace a key, 'git revert' or 'git reset --hard' to an older commit, etc. Anything you need to fix the problem, really. Run gitolite push (or possibly gitolite push -f ). Note that's 'gitolite push', not 'git push' . NOTE : gitolite does no access checking when you do this! botched something? \uf0c1 fixing botched repos \uf0c1 If you copied some repos from somewhere else, or mucked with the hooks for some reason, or deleted any gitolite-specific files, or tried any other \"behind the scenes\" stunts, the quickest, sanest, way to fix everything up is: Make sure any new repos you copied in are mentioned in the gitolite.conf in some 'repo' line and the change pushed. Run the following three commands: gitolite compile gitolite setup --hooks-only gitolite trigger POST_COMPILE If the repo you botched is a wild repo, there's a bit more to be done. Wild repos store the creator name in a file called gl-creator, and the data managed by the perms command in a file called \"gl-perms\". If these files got deleted, you may have to manually recreate them. The format is very simple and guessable by looking at those files on any other wild repo. cleaning out a botched install \uf0c1 Here's a list of files and directories to deal with: Gitolite sources -- can be found by running which gitolite . If it's a symlink, go to its target directory. If the which command does not work, you'll have to find this info from looking at the 'command=' option in pubkey lines in ~/.ssh/authorized_keys . Gitolite admin directory -- $HOME/.gitolite . Save the 'logs' directory if you want to preserve them for any reason. The rc file -- $HOME/.gitolite.rc . If you made any changes to it you can save it as some other name instead of deleting it. The gitolite-admin repo -- $HOME/repositories/gitolite-admin.git . You can clone it somewhere to save it before blowing it away if you wish. Git repositories -- $HOME/repositories . The install process will not touch any existing repos except 'gitolite-admin.git', so you do not have to blow away (or move) your work repos to fix a botched install. Only when you update the conf to include those repos and push the changes will those repos be touched. And even then all that happens is that the update hook, if any, is replaced with gitolite's own hook. Ssh stuff -- exercise caution when doing this, but in general it should be safe to delete all lines between the \"gitolite start\" and \"gitolite end\" markers in $HOME/.ssh/authorized_keys . Gitolite does not touch any other files in the ssh directory. common errors \uf0c1 WARNING: keydir/<yourname>.pub duplicates a non-gitolite key, sshd will ignore it You used a key that is already set to give you shell access. You cannot use the same key to get shell access as well as access gitolite repos. Solution: use a different keypair for gitolite. There's a wee bit more on this in the setup section of the install page. Also see why bypassing causes a problem and both the pages linked from ssh for background. Empty compile time value given to use lib at hooks/update line 6 (followed by Can't locate Gitolite/Hooks/Update.pm in @INC a couple of lines later). You're bypassing gitolite. You cloned the repo using the full path (i.e., including the repositories/ prefix), either directly on the server, or via ssh with a key that gives you shell access. Solution: same as for the previous bullet. NOTE: If you really must do it, and this is on the server and is a one-time thing, you can try gitolite push instead of git push . BUT ... this defeats all gitolite access control, so if you're going to do this often, maybe you don't need gitolite! uncommon errors \uf0c1 (This page intentionally left blank) non-standard configs that'll trip you up \uf0c1 IMPORTANT : although a default openssh config will not do this (AFAIK), do not allow the user to set environment variables if you care about security at all. If your 'git' binary is in a non-PATH location, or you have more than one version and want a specific one to be picked up, you will have to add a line like this at the end of the rc file (outside the %RC hash, but before the 1; line): $ENV{PATH} = \"/your/git/path:$ENV{PATH}\"; If you have your sshd configured to put the authorized_keys file somewhere other than the default (which is in .ssh in the hosting user 's home directory), you'll probably have to roll your own ssh handling, either disabling 'ssh-authkeys' in the rc file, or building on that somehow (maybe a post-processing step that copies the relevant auth keys lines from the default file to the other). If you have sshd setup to not allow incoming ssh for the hosting user, gitolite won't work. Check things like Allowusers setting in /etc/ssh/sshd_config etc. to make sure. If you have the home directory in a partition that is mounted noexec, gitolite won't work. I believe it would be sufficient if the \".gitolite\" directory were moved to a different mount and symlinked, but please test thoroughly. A failure to execute a hook does not throw up any errors or warnings for you to notice! If the default shell is something like /bin/false, and/or not listed in /etc/shells, there might be problems. things that are not gitolite problems \uf0c1 There are several things that appear to be gitolite problems but are not. I cannot help with most of these (although the good folks on irc or the mailing list -- see contact -- might be able to; they certainly appear to have a lot more patience than I do, bless 'em!) Client side software putty/plink jgit/Eclipse Mac OS client or server putty/plink windows as a server ...probably some more I forgot; will update this list as I remember... did I mention putty/plink? Ssh The superstar of the \"not a gitolite problem\" category is actually ssh. Surprised? It's a common misunderstanding; see this section in the concepts page, and then this page for details. Everything I know is in that latter link, and the two more pages it points to. Please email me about ssh ONLY if you find something wrong or missing in those pages. Git I wish I had a dollar for each time someone did a first push on a new repo, got an error because there were \"no refs in common (etc.)\", and asked me why gitolite was not allowing the push. Gitolite is designed to look like just another bare repo server to a client (except requiring public keys -- no passwords allowed). It is completely transparent when there is no authorisation failure (i.e., when the access is allowed, the remote client has no way of knowing gitolite was even installed!) Even \"on disk\", apart from reserving the update hook for itself, gitolite does nothing to your bare repos unless you tell it to (for example, adding 'gitweb.owner' and such to the config file). BEFORE you think gitolite is the problem, try the same thing with a normal bare repo. In most cases you can play with it just by doing something like this: mkdir /tmp/throwaway cd /tmp/throwaway git clone --mirror <some repo you have a URL for> bare.git git clone bare.git worktree cd worktree <...try stuff>","title":"emergency!!"},{"location":"emergencies.html#help-for-emergencies","text":"\"Don't Panic!\" IMPORTANT Almost nothing in gitolite requires root (with some obvious exceptions). Unless the documentation says \"do this from root \", assume it is to be done from the hosting user account.","title":"help for emergencies"},{"location":"emergencies.html#installsetup-issues","text":"Most install/setup issues in ssh mode are caused by lack of ssh knowledge. Ssh is a complex beast, and can cause problems for people who are not familiar with its quirks. Be prepared to spend some time reading the ssh documentation that comes with gitolite .","title":"install/setup issues"},{"location":"emergencies.html#lost-admin-keyaccess","text":"If you lost your gitolite admin key or access, here's what you do. We'll assume your username is \"alice\" (i.e., alice has RW or RW+ permissions on the gitolite-admin repo). Make yourself a new keypair and copy the public key to the server as 'alice.pub'. Log on to the server, and run gitolite setup -pk alice.pub . That's it; the new alice.pub file replaces whatever existed in the repo before.","title":"lost admin key/access"},{"location":"emergencies.html#bypassing-gitolite","text":"You may have lost access because of a conf file error, in which case the above trick (which merely changes a pubkey) won't help. What you want is to make changes to the gitolite-admin repo (or perhaps just rewind) and push that. Here's how to do that: Log on to the server. Clone the admin repo using the full path: git clone $HOME/repositories/gitolite-admin.git temp 'cd' to this clone and make whatever changes you want -- add/replace a key, 'git revert' or 'git reset --hard' to an older commit, etc. Anything you need to fix the problem, really. Run gitolite push (or possibly gitolite push -f ). Note that's 'gitolite push', not 'git push' . NOTE : gitolite does no access checking when you do this!","title":"bypassing gitolite"},{"location":"emergencies.html#botched-something","text":"","title":"botched something?"},{"location":"emergencies.html#fixing-botched-repos","text":"If you copied some repos from somewhere else, or mucked with the hooks for some reason, or deleted any gitolite-specific files, or tried any other \"behind the scenes\" stunts, the quickest, sanest, way to fix everything up is: Make sure any new repos you copied in are mentioned in the gitolite.conf in some 'repo' line and the change pushed. Run the following three commands: gitolite compile gitolite setup --hooks-only gitolite trigger POST_COMPILE If the repo you botched is a wild repo, there's a bit more to be done. Wild repos store the creator name in a file called gl-creator, and the data managed by the perms command in a file called \"gl-perms\". If these files got deleted, you may have to manually recreate them. The format is very simple and guessable by looking at those files on any other wild repo.","title":"fixing botched repos"},{"location":"emergencies.html#cleaning-out-a-botched-install","text":"Here's a list of files and directories to deal with: Gitolite sources -- can be found by running which gitolite . If it's a symlink, go to its target directory. If the which command does not work, you'll have to find this info from looking at the 'command=' option in pubkey lines in ~/.ssh/authorized_keys . Gitolite admin directory -- $HOME/.gitolite . Save the 'logs' directory if you want to preserve them for any reason. The rc file -- $HOME/.gitolite.rc . If you made any changes to it you can save it as some other name instead of deleting it. The gitolite-admin repo -- $HOME/repositories/gitolite-admin.git . You can clone it somewhere to save it before blowing it away if you wish. Git repositories -- $HOME/repositories . The install process will not touch any existing repos except 'gitolite-admin.git', so you do not have to blow away (or move) your work repos to fix a botched install. Only when you update the conf to include those repos and push the changes will those repos be touched. And even then all that happens is that the update hook, if any, is replaced with gitolite's own hook. Ssh stuff -- exercise caution when doing this, but in general it should be safe to delete all lines between the \"gitolite start\" and \"gitolite end\" markers in $HOME/.ssh/authorized_keys . Gitolite does not touch any other files in the ssh directory.","title":"cleaning out a botched install"},{"location":"emergencies.html#common-errors","text":"WARNING: keydir/<yourname>.pub duplicates a non-gitolite key, sshd will ignore it You used a key that is already set to give you shell access. You cannot use the same key to get shell access as well as access gitolite repos. Solution: use a different keypair for gitolite. There's a wee bit more on this in the setup section of the install page. Also see why bypassing causes a problem and both the pages linked from ssh for background. Empty compile time value given to use lib at hooks/update line 6 (followed by Can't locate Gitolite/Hooks/Update.pm in @INC a couple of lines later). You're bypassing gitolite. You cloned the repo using the full path (i.e., including the repositories/ prefix), either directly on the server, or via ssh with a key that gives you shell access. Solution: same as for the previous bullet. NOTE: If you really must do it, and this is on the server and is a one-time thing, you can try gitolite push instead of git push . BUT ... this defeats all gitolite access control, so if you're going to do this often, maybe you don't need gitolite!","title":"common errors"},{"location":"emergencies.html#uncommon-errors","text":"(This page intentionally left blank)","title":"uncommon errors"},{"location":"emergencies.html#non-standard-configs-thatll-trip-you-up","text":"IMPORTANT : although a default openssh config will not do this (AFAIK), do not allow the user to set environment variables if you care about security at all. If your 'git' binary is in a non-PATH location, or you have more than one version and want a specific one to be picked up, you will have to add a line like this at the end of the rc file (outside the %RC hash, but before the 1; line): $ENV{PATH} = \"/your/git/path:$ENV{PATH}\"; If you have your sshd configured to put the authorized_keys file somewhere other than the default (which is in .ssh in the hosting user 's home directory), you'll probably have to roll your own ssh handling, either disabling 'ssh-authkeys' in the rc file, or building on that somehow (maybe a post-processing step that copies the relevant auth keys lines from the default file to the other). If you have sshd setup to not allow incoming ssh for the hosting user, gitolite won't work. Check things like Allowusers setting in /etc/ssh/sshd_config etc. to make sure. If you have the home directory in a partition that is mounted noexec, gitolite won't work. I believe it would be sufficient if the \".gitolite\" directory were moved to a different mount and symlinked, but please test thoroughly. A failure to execute a hook does not throw up any errors or warnings for you to notice! If the default shell is something like /bin/false, and/or not listed in /etc/shells, there might be problems.","title":"non-standard configs that'll trip you up"},{"location":"emergencies.html#things-that-are-not-gitolite-problems","text":"There are several things that appear to be gitolite problems but are not. I cannot help with most of these (although the good folks on irc or the mailing list -- see contact -- might be able to; they certainly appear to have a lot more patience than I do, bless 'em!) Client side software putty/plink jgit/Eclipse Mac OS client or server putty/plink windows as a server ...probably some more I forgot; will update this list as I remember... did I mention putty/plink? Ssh The superstar of the \"not a gitolite problem\" category is actually ssh. Surprised? It's a common misunderstanding; see this section in the concepts page, and then this page for details. Everything I know is in that latter link, and the two more pages it points to. Please email me about ssh ONLY if you find something wrong or missing in those pages. Git I wish I had a dollar for each time someone did a first push on a new repo, got an error because there were \"no refs in common (etc.)\", and asked me why gitolite was not allowing the push. Gitolite is designed to look like just another bare repo server to a client (except requiring public keys -- no passwords allowed). It is completely transparent when there is no authorisation failure (i.e., when the access is allowed, the remote client has no way of knowing gitolite was even installed!) Even \"on disk\", apart from reserving the update hook for itself, gitolite does nothing to your bare repos unless you tell it to (for example, adding 'gitweb.owner' and such to the config file). BEFORE you think gitolite is the problem, try the same thing with a normal bare repo. In most cases you can play with it just by doing something like this: mkdir /tmp/throwaway cd /tmp/throwaway git clone --mirror <some repo you have a URL for> bare.git git clone bare.git worktree cd worktree <...try stuff>","title":"things that are not gitolite problems"},{"location":"files.html","text":"gitolite files and directories \uf0c1 directories \uf0c1 Gitolite creates and uses the following files and directories: ~/repositories -- the actual (bare) repositories are here ~/.gitolite.rc -- configuration parameters that must be done directly on the server ~/.gitolite -- gitolite's \"working\" directory. This contains everything else that gitolite needs. (Warning: you're not supposed to fiddle with the files and directories within; instead, make changes in a clone of the gitolite-admin repository and push, and those appear magically here). Once the install/setup is done, any (or all) of these may be moved elsewhere and replaced by symlinks. The most common reason for locating ~/repositories somewhere else is disk space, but FHS compliance could also be a reason. In addition, the following are of interest: ~/.ssh -- if you're using ssh (as opposed to http), since this is where the authorized_keys file is kept special files \uf0c1 You may want to backup the contents of ~/.gitolite/logs if you care about auditability etc. inside a \"gitolite repo\" \uf0c1 A gitolite repo is just like a normal bare repo on any normal git server. There are a few extra files placed in the repo directory whose names start with \"gl-\", and there is also an update hook placed in the hooks subdirectory, but that's about it, for the most part. In other words, you can treat a gitolite-managed repo just like any other bare repo as long as you leave those files alone. gitolite software \uf0c1 The above list does not include the gitolite software itself. Gitolite offers you 3 ways to install software. After cloning the gitolite sources, run the install command in it with a -h argument to see what they are. Where the actual software is found depends on that.","title":"gitolite files & directories"},{"location":"files.html#gitolite-files-and-directories","text":"","title":"gitolite files and directories"},{"location":"files.html#directories","text":"Gitolite creates and uses the following files and directories: ~/repositories -- the actual (bare) repositories are here ~/.gitolite.rc -- configuration parameters that must be done directly on the server ~/.gitolite -- gitolite's \"working\" directory. This contains everything else that gitolite needs. (Warning: you're not supposed to fiddle with the files and directories within; instead, make changes in a clone of the gitolite-admin repository and push, and those appear magically here). Once the install/setup is done, any (or all) of these may be moved elsewhere and replaced by symlinks. The most common reason for locating ~/repositories somewhere else is disk space, but FHS compliance could also be a reason. In addition, the following are of interest: ~/.ssh -- if you're using ssh (as opposed to http), since this is where the authorized_keys file is kept","title":"directories"},{"location":"files.html#special-files","text":"You may want to backup the contents of ~/.gitolite/logs if you care about auditability etc.","title":"special files"},{"location":"files.html#inside-a-gitolite-repo","text":"A gitolite repo is just like a normal bare repo on any normal git server. There are a few extra files placed in the repo directory whose names start with \"gl-\", and there is also an update hook placed in the hooks subdirectory, but that's about it, for the most part. In other words, you can treat a gitolite-managed repo just like any other bare repo as long as you leave those files alone.","title":"inside a \"gitolite repo\""},{"location":"files.html#gitolite-software","text":"The above list does not include the gitolite software itself. Gitolite offers you 3 ways to install software. After cloning the gitolite sources, run the install command in it with a -h argument to see what they are. Where the actual software is found depends on that.","title":"gitolite software"},{"location":"fool_proof_setup.html","text":"fool-proof, step-by-step, install and setup \uf0c1 This page is useful if the normal install instructions did not work for you. pre-requisites, etc \uf0c1 These are the pre-requisites: Any Linux machine on which git has already been installed. Probably any BSD or legacy system like Solaris will also work, but I have not tested them. I do not consider Apple devices to be Unix enough; it should work, but please do not ask me for help if it does not. This page has several restrictions and constraints that seem unnecessary to people who do understand ssh. That's the whole point -- I'm compensating for lack of ssh knowledge by removing things that trip people up. If even this page does not help you install gitolite, I probably cannot help you. Either you did not follow the instructions carefully (maybe some task has to be run on your workstation, but you ran it on the server, or you ran something as root when it should be as the hosting user, etc.) , or your environment is far too different from standard Unix, or you have some other problem. In any case, it is not something I can help with. Sorry. assumptions \uf0c1 Your name is Ron. Substitute accordingly in the instructions below. You have a workstation. You have a server called server . You have root access on this server. installation tasks \uf0c1 Create a new userid on the server, say git . This will be the hosting user . (\"hosting user\" means when you're done installing, your users will use URLs like git@server:reponame or ssh://git@server/reponame ). Make sure this is a NEW userid . If the name you want already exists, then: Log in as root. If you have any data on that user's HOME directory save it somewhere else. Delete the userid. Completely wipe out (erase) the home directory of the user (since on most systems merely deleting the user does not remove the home directory). Re-create the userid again. If you don't already have one, make yourself an ssh keypair on your workstation . Do NOT add this public key to the authorised keys file on the newly created hosting user! Your ONLY access to the new ( git ) userid should be by logging onto the server as root, then running su - git . Now copy the pubkey from your workstation ( ~/.ssh/id_rsa.pub ) to the server as /tmp/ron.pub . (Your name is Ron, remember?) Log on to the server as root. Switch to the git user: su - git Clone the gitolite source code git clone https://github.com/sitaramc/gitolite Install it cd $HOME mkdir -p bin gitolite/install -to $HOME/bin Set it up cd $HOME $HOME/bin/gitolite setup -pk /tmp/ron.pub Now go to your workstation and type in git ls-remote git@server:gitolite-admin This should return something like 9dd8aab60bac5e54ccf887a87b4f3d35c96b05e4 HEAD 9dd8aab60bac5e54ccf887a87b4f3d35c96b05e4 refs/heads/master (do I have to mention that your SHAs will be different?) administration tasks \uf0c1 Most day-to-day administration is done by making changes to a clone of the gitolite-admin repo and pushing. (There are some things that are done by editing $HOME/.gitolite.rc on the server, but those are too advanced for this tutorial so we will ignore that). To start administering gitolite, clone the gitolite-admin repo: git clone git@server:gitolite-admin Now go to the new directory this creates, and look around: cd gitolite-admin ls -A which gives you conf/ .git/ keydir/ Ignoring the \".git\" and exploring further: ls -A conf keydir which says: conf: gitolite.conf keydir: ron.pub Let's say you want to add your colleague Alice. She has sent you her ssh public key by email (the file is called id_rsa.pub ). Save this file as /tmp/alice.pub, then do this: # still in your gitolite-admin clone, from the previous step cp /tmp/alice.pub keydir git add keydir git commit -m 'new user alice' git push Well, that might not be sufficient. There aren't any new repos for alice to play with, yet. So here's what you do: edit \"conf/gitolite.conf\" and add something like to the end: repo foo RW+ = alice R = ron Save the file, then git add conf; git commit -m 'new repo foo'; git push . This will automatically create a brand new repo called \"foo\" on the server, and alice will be able to clone from it, or push anything to it.","title":"(if all else fails) fool-proof, step-by-step, install and setup"},{"location":"fool_proof_setup.html#fool-proof-step-by-step-install-and-setup","text":"This page is useful if the normal install instructions did not work for you.","title":"fool-proof, step-by-step, install and setup"},{"location":"fool_proof_setup.html#pre-requisites-etc","text":"These are the pre-requisites: Any Linux machine on which git has already been installed. Probably any BSD or legacy system like Solaris will also work, but I have not tested them. I do not consider Apple devices to be Unix enough; it should work, but please do not ask me for help if it does not. This page has several restrictions and constraints that seem unnecessary to people who do understand ssh. That's the whole point -- I'm compensating for lack of ssh knowledge by removing things that trip people up. If even this page does not help you install gitolite, I probably cannot help you. Either you did not follow the instructions carefully (maybe some task has to be run on your workstation, but you ran it on the server, or you ran something as root when it should be as the hosting user, etc.) , or your environment is far too different from standard Unix, or you have some other problem. In any case, it is not something I can help with. Sorry.","title":"pre-requisites, etc"},{"location":"fool_proof_setup.html#assumptions","text":"Your name is Ron. Substitute accordingly in the instructions below. You have a workstation. You have a server called server . You have root access on this server.","title":"assumptions"},{"location":"fool_proof_setup.html#installation-tasks","text":"Create a new userid on the server, say git . This will be the hosting user . (\"hosting user\" means when you're done installing, your users will use URLs like git@server:reponame or ssh://git@server/reponame ). Make sure this is a NEW userid . If the name you want already exists, then: Log in as root. If you have any data on that user's HOME directory save it somewhere else. Delete the userid. Completely wipe out (erase) the home directory of the user (since on most systems merely deleting the user does not remove the home directory). Re-create the userid again. If you don't already have one, make yourself an ssh keypair on your workstation . Do NOT add this public key to the authorised keys file on the newly created hosting user! Your ONLY access to the new ( git ) userid should be by logging onto the server as root, then running su - git . Now copy the pubkey from your workstation ( ~/.ssh/id_rsa.pub ) to the server as /tmp/ron.pub . (Your name is Ron, remember?) Log on to the server as root. Switch to the git user: su - git Clone the gitolite source code git clone https://github.com/sitaramc/gitolite Install it cd $HOME mkdir -p bin gitolite/install -to $HOME/bin Set it up cd $HOME $HOME/bin/gitolite setup -pk /tmp/ron.pub Now go to your workstation and type in git ls-remote git@server:gitolite-admin This should return something like 9dd8aab60bac5e54ccf887a87b4f3d35c96b05e4 HEAD 9dd8aab60bac5e54ccf887a87b4f3d35c96b05e4 refs/heads/master (do I have to mention that your SHAs will be different?)","title":"installation tasks"},{"location":"fool_proof_setup.html#administration-tasks","text":"Most day-to-day administration is done by making changes to a clone of the gitolite-admin repo and pushing. (There are some things that are done by editing $HOME/.gitolite.rc on the server, but those are too advanced for this tutorial so we will ignore that). To start administering gitolite, clone the gitolite-admin repo: git clone git@server:gitolite-admin Now go to the new directory this creates, and look around: cd gitolite-admin ls -A which gives you conf/ .git/ keydir/ Ignoring the \".git\" and exploring further: ls -A conf keydir which says: conf: gitolite.conf keydir: ron.pub Let's say you want to add your colleague Alice. She has sent you her ssh public key by email (the file is called id_rsa.pub ). Save this file as /tmp/alice.pub, then do this: # still in your gitolite-admin clone, from the previous step cp /tmp/alice.pub keydir git add keydir git commit -m 'new user alice' git push Well, that might not be sufficient. There aren't any new repos for alice to play with, yet. So here's what you do: edit \"conf/gitolite.conf\" and add something like to the end: repo foo RW+ = alice R = ron Save the file, then git add conf; git commit -m 'new repo foo'; git push . This will automatically create a brand new repo called \"foo\" on the server, and alice will be able to clone from it, or push anything to it.","title":"administration tasks"},{"location":"g2migr-example.html","text":"migration example \uf0c1 This shows what a typical migration would look like, using a test setup. existing setup \uf0c1 The existing gitolite is the latest in the \"g2\" (v2.x) branch. First, the rc file has the following lines different from the default: -$GL_WILDREPOS = 0; +$GL_WILDREPOS = 1; -$GL_GITCONFIG_KEYS = \"\"; +$GL_GITCONFIG_KEYS = \".*\"; Next, the conf/gitolite.conf file in ~/.gitolite : repo gitolite-admin RW+ = tester u1 repo testing RW+ = @all repo foo RW+ = u1 u2 RW+ NAME/ = u1 RW+ NAME/ u2 = u2 repo bar RW = u2 repo baz/..* C = u3 u4 RW+ = CREATOR config foo.bar = baz (Note that this conf file has NAME/ rules, which have changed significantly in v3; see [here][g2i-name] for details). These are the repos already existing $ find repositories -name \"*.git\" | sort repositories/bar.git repositories/baz/u3.git repositories/baz/u4.git repositories/baz/uthree.git repositories/foo.git repositories/gitolite-admin.git repositories/testing.git The config entries exist for all the baz/ repos: $ grep -2 foo `find repositories -name \"config\" ` repositories/baz/uthree.git/config-[gitweb] repositories/baz/uthree.git/config- owner = u3 repositories/baz/uthree.git/config:[foo] repositories/baz/uthree.git/config- bar = baz -- repositories/baz/u4.git/config-[gitweb] repositories/baz/u4.git/config- owner = u4 repositories/baz/u4.git/config:[foo] repositories/baz/u4.git/config- bar = baz -- repositories/baz/u3.git/config-[gitweb] repositories/baz/u3.git/config- owner = u3 repositories/baz/u3.git/config:[foo] repositories/baz/u3.git/config- bar = baz preparing for the migration \uf0c1 getting v3 \uf0c1 Fortunately this is easy here; I just happened to have the repo already fetched so I just had to switch branches. You may have to 'git clone ...' from github. $ cd gitolite $ git checkout master Branch master set up to track remote branch master from origin. Switched to a new branch 'master' run check-g2-compat \uf0c1 This is a quick and dirty program to catch some of the big issues. $ cd $ gitolite/check-g2-compat INFO This program only checks for uses that make the new v3 completely unusable or that might end up giving *more* access to someone if migrated as-is. It does NOT attempt to catch all the differences described in the docs. INFO 'see docs' usually means the pre-migration checklist in \"g2migr.html\"; to get there, start from the main migration page at https://sitaramc.github.com/gitolite/migr/ checking rc file... NOTE GL_ADMINDIR is in the right place; assuming you did not mess with GL_CONF, GL_LOGT, GL_KEYDIR, and GL_CONF_COMPILED checking conf file(s)... SEVERE NAME rules; see docs checking repos... WARNING found 3 gl-creater files; see docs ...all done... the actual migration \uf0c1 Here's the actual migration, step by step step 1 \uf0c1 $ ls -a bin . gl-admin-push gl-install gl-setup-authkeys gl-VREF-DUPKEYS .. gl-auth-command gl-mirror-push gl-system-install gl-VREF-EMAIL_CHECK gitolite_env.pm gl-compile-conf gl-mirror-shell gl-time gl-VREF-FILETYPE gitolite.pm gl-conf-convert gl-query-rc gl-tool gl-VREF-MERGE_CHECK gitolite_rc.pm gl-dryrun gl-setup gl-VREF-COUNT sshkeys-lint $ rm -rf bin;mkdir bin $ grep GL_PACKAGE .gitolite.rc $GL_PACKAGE_CONF = \"/home/git/share/gitolite/conf\"; $GL_PACKAGE_HOOKS = \"/home/git/share/gitolite/hooks\"; $ rm -rf share $GL_PACKAGE_HOOKS = \"/home/git/share/gitolite/hooks\"; $ rm -rf share $ mv .gitolite.rc old.grc (still on step 1, this is substep 3) notice we are cloning on the server , using a full path to the repo. $ git clone repositories/gitolite-admin.git old.ga Cloning into 'old.ga'... done. $ rm -rf repositories/gitolite-admin.git/ Since I'm not interested in preserving the logs and don't have any custom hooks: $ rm -rf .gitolite step 2 \uf0c1 I have no variables that must be preset, since the report by check-g2-compat is clear. step 3 \uf0c1 Here we install the new gitolite. Remember we already got the new software (in order to run 'check-g2-compat'). Just check that bin is empty, then run 'install -ln' from the gitolite source tree: $ ls -al bin total 8 drwxrwxr-x 2 git git 4096 Apr 24 10:57 . drwx------ 8 git git 4096 Apr 24 10:59 .. $ gitolite/install -ln $ ls -al bin total 8 drwxrwxr-x 2 git git 4096 Apr 24 11:01 . drwx------ 8 git git 4096 Apr 24 10:59 .. lrwxrwxrwx 1 git git 30 Apr 24 11:01 gitolite -> /home/git/gitolite/src/gitolite OK that went well. Now setup gitolite. You don't need a key here; just use a random name: $ gitolite setup -a admin Initialized empty Git repository in /home/git/repositories/gitolite-admin.git/ step 4 \uf0c1 Now go to your old clone, and push it: $ cd old.ga $ gitolite push -f ...usual git progress output deleted... remote: FATAL: git config foo.bar not allowed remote: check GIT_CONFIG_KEYS in the rc file To /home/git/repositories/gitolite-admin.git + 7eb8163...1474770 master -> master (forced update) Aaha! I forgot to set GIT_CONFIG_KEYS (new name for GL_GITCONFIG_KEYS ) in the new rc file so fix that: $ vim ~/.gitolite.rc (edit and set it to `.*` for now) and push again: $ gitolite push -f Everything up-to-date Damn. We have to make a dummy commit to allow the push to do something. But wait! We forgot fix the [NAME/][g2i-name] rules, so may as well fix those, add, and push: $ vim conf/gitolite.conf # change all NAME/ to VREF/NAME/ # append a '- VREF/NAME/ = @all' at the end # save git add conf $ git commit -m name-rules ... some output for add... $ gitolite push -f Counting objects: 1, done. Writing objects: 100% (1/1), 181 bytes, done. Total 1 (delta 0), reused 0 (delta 0) Unpacking objects: 100% (1/1), done. To /home/git/repositories/gitolite-admin.git 1474770..4c2b41d master -> master step 5 \uf0c1 The only thing left is to fix up the gl-creater files: $ cd $HOME/repositories $ find . -type d -name \"*.git\" -prune | while read r > do > mv $r/gl-creater $r/gl-creator > done 2>/dev/null And we're done! checking things out \uf0c1 Let's see what repos u3 has: # as user 'u3' ssh git@server info hello u3, this is git@server running gitolite3 v3.0-11-g090b0f5 on git 1.7.7.6 C baz/..* R W baz/u3 R W baz/uthree R W gitolite-admin R W testing That's a combination of 'info' and 'expand', by the way. There is no expand command any more. How about adding a new repo and checking if the config entries made it? # as user u4 $ git ls-remote git@server:baz/ufour Initialized empty Git repository in /home/git/repositories/baz/ufour.git/ $ grep -A1 foo `find repositories -name \"config\" ` repositories/baz/u3.git/config:[foo] repositories/baz/u3.git/config- bar = baz -- repositories/baz/u4.git/config:[foo] repositories/baz/u4.git/config- bar = baz -- repositories/baz/ufour.git/config:[foo] repositories/baz/ufour.git/config- bar = baz -- repositories/baz/uthree.git/config:[foo] repositories/baz/uthree.git/config- bar = baz And there it is, in the second block of lines... And now we're really done.","title":"migration example"},{"location":"g2migr-example.html#migration-example","text":"This shows what a typical migration would look like, using a test setup.","title":"migration example"},{"location":"g2migr-example.html#existing-setup","text":"The existing gitolite is the latest in the \"g2\" (v2.x) branch. First, the rc file has the following lines different from the default: -$GL_WILDREPOS = 0; +$GL_WILDREPOS = 1; -$GL_GITCONFIG_KEYS = \"\"; +$GL_GITCONFIG_KEYS = \".*\"; Next, the conf/gitolite.conf file in ~/.gitolite : repo gitolite-admin RW+ = tester u1 repo testing RW+ = @all repo foo RW+ = u1 u2 RW+ NAME/ = u1 RW+ NAME/ u2 = u2 repo bar RW = u2 repo baz/..* C = u3 u4 RW+ = CREATOR config foo.bar = baz (Note that this conf file has NAME/ rules, which have changed significantly in v3; see [here][g2i-name] for details). These are the repos already existing $ find repositories -name \"*.git\" | sort repositories/bar.git repositories/baz/u3.git repositories/baz/u4.git repositories/baz/uthree.git repositories/foo.git repositories/gitolite-admin.git repositories/testing.git The config entries exist for all the baz/ repos: $ grep -2 foo `find repositories -name \"config\" ` repositories/baz/uthree.git/config-[gitweb] repositories/baz/uthree.git/config- owner = u3 repositories/baz/uthree.git/config:[foo] repositories/baz/uthree.git/config- bar = baz -- repositories/baz/u4.git/config-[gitweb] repositories/baz/u4.git/config- owner = u4 repositories/baz/u4.git/config:[foo] repositories/baz/u4.git/config- bar = baz -- repositories/baz/u3.git/config-[gitweb] repositories/baz/u3.git/config- owner = u3 repositories/baz/u3.git/config:[foo] repositories/baz/u3.git/config- bar = baz","title":"existing setup"},{"location":"g2migr-example.html#preparing-for-the-migration","text":"","title":"preparing for the migration"},{"location":"g2migr-example.html#getting-v3","text":"Fortunately this is easy here; I just happened to have the repo already fetched so I just had to switch branches. You may have to 'git clone ...' from github. $ cd gitolite $ git checkout master Branch master set up to track remote branch master from origin. Switched to a new branch 'master'","title":"getting v3"},{"location":"g2migr-example.html#run-check-g2-compat","text":"This is a quick and dirty program to catch some of the big issues. $ cd $ gitolite/check-g2-compat INFO This program only checks for uses that make the new v3 completely unusable or that might end up giving *more* access to someone if migrated as-is. It does NOT attempt to catch all the differences described in the docs. INFO 'see docs' usually means the pre-migration checklist in \"g2migr.html\"; to get there, start from the main migration page at https://sitaramc.github.com/gitolite/migr/ checking rc file... NOTE GL_ADMINDIR is in the right place; assuming you did not mess with GL_CONF, GL_LOGT, GL_KEYDIR, and GL_CONF_COMPILED checking conf file(s)... SEVERE NAME rules; see docs checking repos... WARNING found 3 gl-creater files; see docs ...all done...","title":"run check-g2-compat"},{"location":"g2migr-example.html#the-actual-migration","text":"Here's the actual migration, step by step","title":"the actual migration"},{"location":"g2migr-example.html#step-1","text":"$ ls -a bin . gl-admin-push gl-install gl-setup-authkeys gl-VREF-DUPKEYS .. gl-auth-command gl-mirror-push gl-system-install gl-VREF-EMAIL_CHECK gitolite_env.pm gl-compile-conf gl-mirror-shell gl-time gl-VREF-FILETYPE gitolite.pm gl-conf-convert gl-query-rc gl-tool gl-VREF-MERGE_CHECK gitolite_rc.pm gl-dryrun gl-setup gl-VREF-COUNT sshkeys-lint $ rm -rf bin;mkdir bin $ grep GL_PACKAGE .gitolite.rc $GL_PACKAGE_CONF = \"/home/git/share/gitolite/conf\"; $GL_PACKAGE_HOOKS = \"/home/git/share/gitolite/hooks\"; $ rm -rf share $GL_PACKAGE_HOOKS = \"/home/git/share/gitolite/hooks\"; $ rm -rf share $ mv .gitolite.rc old.grc (still on step 1, this is substep 3) notice we are cloning on the server , using a full path to the repo. $ git clone repositories/gitolite-admin.git old.ga Cloning into 'old.ga'... done. $ rm -rf repositories/gitolite-admin.git/ Since I'm not interested in preserving the logs and don't have any custom hooks: $ rm -rf .gitolite","title":"step 1"},{"location":"g2migr-example.html#step-2","text":"I have no variables that must be preset, since the report by check-g2-compat is clear.","title":"step 2"},{"location":"g2migr-example.html#step-3","text":"Here we install the new gitolite. Remember we already got the new software (in order to run 'check-g2-compat'). Just check that bin is empty, then run 'install -ln' from the gitolite source tree: $ ls -al bin total 8 drwxrwxr-x 2 git git 4096 Apr 24 10:57 . drwx------ 8 git git 4096 Apr 24 10:59 .. $ gitolite/install -ln $ ls -al bin total 8 drwxrwxr-x 2 git git 4096 Apr 24 11:01 . drwx------ 8 git git 4096 Apr 24 10:59 .. lrwxrwxrwx 1 git git 30 Apr 24 11:01 gitolite -> /home/git/gitolite/src/gitolite OK that went well. Now setup gitolite. You don't need a key here; just use a random name: $ gitolite setup -a admin Initialized empty Git repository in /home/git/repositories/gitolite-admin.git/","title":"step 3"},{"location":"g2migr-example.html#step-4","text":"Now go to your old clone, and push it: $ cd old.ga $ gitolite push -f ...usual git progress output deleted... remote: FATAL: git config foo.bar not allowed remote: check GIT_CONFIG_KEYS in the rc file To /home/git/repositories/gitolite-admin.git + 7eb8163...1474770 master -> master (forced update) Aaha! I forgot to set GIT_CONFIG_KEYS (new name for GL_GITCONFIG_KEYS ) in the new rc file so fix that: $ vim ~/.gitolite.rc (edit and set it to `.*` for now) and push again: $ gitolite push -f Everything up-to-date Damn. We have to make a dummy commit to allow the push to do something. But wait! We forgot fix the [NAME/][g2i-name] rules, so may as well fix those, add, and push: $ vim conf/gitolite.conf # change all NAME/ to VREF/NAME/ # append a '- VREF/NAME/ = @all' at the end # save git add conf $ git commit -m name-rules ... some output for add... $ gitolite push -f Counting objects: 1, done. Writing objects: 100% (1/1), 181 bytes, done. Total 1 (delta 0), reused 0 (delta 0) Unpacking objects: 100% (1/1), done. To /home/git/repositories/gitolite-admin.git 1474770..4c2b41d master -> master","title":"step 4"},{"location":"g2migr-example.html#step-5","text":"The only thing left is to fix up the gl-creater files: $ cd $HOME/repositories $ find . -type d -name \"*.git\" -prune | while read r > do > mv $r/gl-creater $r/gl-creator > done 2>/dev/null And we're done!","title":"step 5"},{"location":"g2migr-example.html#checking-things-out","text":"Let's see what repos u3 has: # as user 'u3' ssh git@server info hello u3, this is git@server running gitolite3 v3.0-11-g090b0f5 on git 1.7.7.6 C baz/..* R W baz/u3 R W baz/uthree R W gitolite-admin R W testing That's a combination of 'info' and 'expand', by the way. There is no expand command any more. How about adding a new repo and checking if the config entries made it? # as user u4 $ git ls-remote git@server:baz/ufour Initialized empty Git repository in /home/git/repositories/baz/ufour.git/ $ grep -A1 foo `find repositories -name \"config\" ` repositories/baz/u3.git/config:[foo] repositories/baz/u3.git/config- bar = baz -- repositories/baz/u4.git/config:[foo] repositories/baz/u4.git/config- bar = baz -- repositories/baz/ufour.git/config:[foo] repositories/baz/ufour.git/config- bar = baz -- repositories/baz/uthree.git/config:[foo] repositories/baz/uthree.git/config- bar = baz And there it is, in the second block of lines... And now we're really done.","title":"checking things out"},{"location":"git-config.html","text":"specifying \"git-config\" keys and values \uf0c1 (Original version thanks to teemu dot matilainen at iki dot fi.) Important : This won't work unless the rc file has the right settings; please see $GIT_CONFIG_KEYS in the rc file doc . basic syntax \uf0c1 The syntax is simple: config sectionname.keyname = value For example: repo gitolite config hooks.mailinglist = gitolite-commits@example.tld config hooks.emailprefix = \"[gitolite] \" config foo.bar = \"\" This does either a plain \"git config section.key value\" (for the first 2 examples above) or \"git config --unset-all section.key\" (for the last example). Other forms of the git config command ( --add , the value_regex , etc) are not supported. an important warning about deleting a config line \uf0c1 Simply deleting the config line from the conf/gitolite.conf file will not delete the variable from repo.git/config . You have to use the syntax in the last example to make gitolite execute a --unset-all operation on the given key. substituting the repo name and the creator name \uf0c1 You can also use the special values %GL_REPO and %GL_CREATOR in the string. The former is available to all repos, while the latter is only available to wild repos. repo foo bar baz config hooks.mailinglist = %GL_REPO-commits@example.tld config hooks.emailprefix = \"[%GL_REPO] \" (v3.6.7+) expanding a group name \uf0c1 If you add EXPAND_GROUPS_IN_CONFIG => 1, to the rc file (suggested location: just after the GIT_CONFIG_KEYS line), then the value of a config line will have groupnames expanded. For example: @admins = sitaramc @gmail.com jdoe @example.com ... repo foo ... config hooks.mailinglist = @admins will behave as if the two email addresses were explicitly listed in the config line. However, if there is no such group, the text will be left as-is. Also, for safety, only word characters (alphanumerics and underscore) are expected as part of the group name. overriding config values \uf0c1 You can repeat the 'config' line as many times as you like, and the last occurrence will be the one in effect. This allows you to override settings just for one project, as in this example: repo @all config hooks.mailinglist = %GL_REPO-commits@example.tld config hooks.emailprefix = \"[%GL_REPO] \" # ... later ... repo customer-project # different mailing list config hooks.mailinglist = announce@customer.tld The \"delete config variable\" syntax can also be used, if you wish: repo secret # no emails for this one please config hooks.mailinglist = \"\" config hooks.emailprefix = \"\" As you can see, the general idea is to place the most generic ones ( repo @all , or repo regex like repo foo.* ) first, and place more specific ones later to override the generic settings. compensating for UNSAFE_PATT \uf0c1 An important feature in gitolite is that you can share the admin load with more people, without having to give all of them shell access on the server. Thus there are some restrictions designed to prevent someone who can push the gitolite-admin repo, from somehow managing to run arbitrary commands on the server. This section is about one of these restrictions. Gitolite, by default, does not allow the following characters in the value of a config variable: ` ~ # $ & ( ) | ; < > . This is due to unspecified paranoia; see this discussion for some context. This restriction is enforced by a regex called UNSAFE_PATT , whose default value is [`~#\\$\\&()|;<>] . But let's say you need to do this, which fails due to the semicolon. config hooks.showrev = \"git show -C %s; echo\" There are two ways to fix this. If all your admins already have shell access , you can override this by placing a modified version in the rc file. For our example, you'd just put the following line at the very end of your rc file, just before the 1; line (notice there is no semicolon in the regex here): $UNSAFE_PATT = qr([`~#\\$\\&()|<>]); Similarly, you can remove other characters from that regex (to allow those characters in your config values). If all your admins do not have shell access , you need a more fine-grained method: In the rc file, add the following within the '%RC' hash (for example, just after the UMASK line would do fine): SAFE_CONFIG => { SHOWREV => \"git show -C %s; echo\" }, In your gitolite.conf file, add this instead of the line we saw earlier: config hooks.showrev = %SHOWREV This mechanism allows you to add any number of specific violations to the UNSAFE_PATT rule instead of denaturing the regex itself and potentially allowing something that could be (ab)used by a repo admin to obtain shell access at some later point in time. A similar problem arises with email addresses, which contain the < and > characters. Here's how to deal with that easily: In the rc file: SAFE_CONFIG => { LT => '<', GT => '>', }, In the gitolite.conf file: config hooks.mailinglist = \"Sitaram Chamarty %LTsitaramc@gmail.com%GT\" Admittedly, that looks a wee bit ugly, but it gets the job done without having to remove angle brackets from UNSAFE_PATT.","title":"setting git-config values"},{"location":"git-config.html#specifying-git-config-keys-and-values","text":"(Original version thanks to teemu dot matilainen at iki dot fi.) Important : This won't work unless the rc file has the right settings; please see $GIT_CONFIG_KEYS in the rc file doc .","title":"specifying \"git-config\" keys and values"},{"location":"git-config.html#basic-syntax","text":"The syntax is simple: config sectionname.keyname = value For example: repo gitolite config hooks.mailinglist = gitolite-commits@example.tld config hooks.emailprefix = \"[gitolite] \" config foo.bar = \"\" This does either a plain \"git config section.key value\" (for the first 2 examples above) or \"git config --unset-all section.key\" (for the last example). Other forms of the git config command ( --add , the value_regex , etc) are not supported.","title":"basic syntax"},{"location":"git-config.html#an-important-warning-about-deleting-a-config-line","text":"Simply deleting the config line from the conf/gitolite.conf file will not delete the variable from repo.git/config . You have to use the syntax in the last example to make gitolite execute a --unset-all operation on the given key.","title":"an important warning about deleting a config line"},{"location":"git-config.html#substituting-the-repo-name-and-the-creator-name","text":"You can also use the special values %GL_REPO and %GL_CREATOR in the string. The former is available to all repos, while the latter is only available to wild repos. repo foo bar baz config hooks.mailinglist = %GL_REPO-commits@example.tld config hooks.emailprefix = \"[%GL_REPO] \"","title":"substituting the repo name and the creator name"},{"location":"git-config.html#v367-expanding-a-group-name","text":"If you add EXPAND_GROUPS_IN_CONFIG => 1, to the rc file (suggested location: just after the GIT_CONFIG_KEYS line), then the value of a config line will have groupnames expanded. For example: @admins = sitaramc @gmail.com jdoe @example.com ... repo foo ... config hooks.mailinglist = @admins will behave as if the two email addresses were explicitly listed in the config line. However, if there is no such group, the text will be left as-is. Also, for safety, only word characters (alphanumerics and underscore) are expected as part of the group name.","title":"(v3.6.7+) expanding a group name"},{"location":"git-config.html#overriding-config-values","text":"You can repeat the 'config' line as many times as you like, and the last occurrence will be the one in effect. This allows you to override settings just for one project, as in this example: repo @all config hooks.mailinglist = %GL_REPO-commits@example.tld config hooks.emailprefix = \"[%GL_REPO] \" # ... later ... repo customer-project # different mailing list config hooks.mailinglist = announce@customer.tld The \"delete config variable\" syntax can also be used, if you wish: repo secret # no emails for this one please config hooks.mailinglist = \"\" config hooks.emailprefix = \"\" As you can see, the general idea is to place the most generic ones ( repo @all , or repo regex like repo foo.* ) first, and place more specific ones later to override the generic settings.","title":"overriding config values"},{"location":"git-config.html#compensating-for-unsafe_patt","text":"An important feature in gitolite is that you can share the admin load with more people, without having to give all of them shell access on the server. Thus there are some restrictions designed to prevent someone who can push the gitolite-admin repo, from somehow managing to run arbitrary commands on the server. This section is about one of these restrictions. Gitolite, by default, does not allow the following characters in the value of a config variable: ` ~ # $ & ( ) | ; < > . This is due to unspecified paranoia; see this discussion for some context. This restriction is enforced by a regex called UNSAFE_PATT , whose default value is [`~#\\$\\&()|;<>] . But let's say you need to do this, which fails due to the semicolon. config hooks.showrev = \"git show -C %s; echo\" There are two ways to fix this. If all your admins already have shell access , you can override this by placing a modified version in the rc file. For our example, you'd just put the following line at the very end of your rc file, just before the 1; line (notice there is no semicolon in the regex here): $UNSAFE_PATT = qr([`~#\\$\\&()|<>]); Similarly, you can remove other characters from that regex (to allow those characters in your config values). If all your admins do not have shell access , you need a more fine-grained method: In the rc file, add the following within the '%RC' hash (for example, just after the UMASK line would do fine): SAFE_CONFIG => { SHOWREV => \"git show -C %s; echo\" }, In your gitolite.conf file, add this instead of the line we saw earlier: config hooks.showrev = %SHOWREV This mechanism allows you to add any number of specific violations to the UNSAFE_PATT rule instead of denaturing the regex itself and potentially allowing something that could be (ab)used by a repo admin to obtain shell access at some later point in time. A similar problem arises with email addresses, which contain the < and > characters. Here's how to deal with that easily: In the rc file: SAFE_CONFIG => { LT => '<', GT => '>', }, In the gitolite.conf file: config hooks.mailinglist = \"Sitaram Chamarty %LTsitaramc@gmail.com%GT\" Admittedly, that looks a wee bit ugly, but it gets the job done without having to remove angle brackets from UNSAFE_PATT.","title":"compensating for UNSAFE_PATT"},{"location":"gitweb-daemon.html","text":"allowing access to gitweb and git-daemon \uf0c1 Gitolite does not install or configure gitweb/git-daemon -- that is a one-time setup you must do separately. gitweb \uf0c1 The following repos are deemed to be readable by gitweb: Any repos readable by the special user gitweb . Any repos containing one or more of the following types of lines: (actually, any config variable starting with gitweb ). config gitweb.owner = owner name config gitweb.description = some description config gitweb.category = some category Side note: the following shorter forms are available as syntactic sugar for the above longer forms: owner = owner name desc = some description category = some category The list of gitweb-readable repos is written to a file whose name is given by the rc file variable GITWEB_PROJECTS_LIST . The default value of this variable, if it is not specified or empty, is $HOME/projects.list . In addition, each of the config variables described above is written to the repo to which it pertains, so that gitweb can use them. changing the UMASK \uf0c1 Gitweb (or cgit, redmine, etc.) typically runs under a different userid, and the default permissions that gitolite sets make them unreadable. See the section on the UMASK variable in the page for the rc file . repo-specific authorisation in gitweb \uf0c1 Gitweb has a feature whereby it will call a (perl) function that you supply, passing it the full path to the repo being accessed. If the remote user is authenticated, the username will be available, so your function can take those two pieces of information and return true or false to allow or deny the repository access. If you want to use gitolite's access rules in making this determination, you will first have to ensure that the HTTP username (i.e., the username known to apache/gitweb) is the same as the gitolite username. If you're using gitolite's http mode, this is probably already true, but if you're using the more widely used ssh mode, you'll have to make sure they match. You then need to add this code to your gitweb.conf. git-daemon \uf0c1 Any repo readable by the special user daemon is deemed to be readable by git-daemon. For each of these repos, an empty file called git-daemon-export-ok is created in the repository (i.e., the repo.git directory inside $HOME/repositories ). tips \uf0c1 Setting descriptions en-masse usually does not make sense, but you can certainly do things like repo @all R = gitweb daemon assuming you have other means of setting 'gitweb.description' and 'gitweb.owner'. Also see this for a twist on that.","title":"gitweb and git-daemon"},{"location":"gitweb-daemon.html#allowing-access-to-gitweb-and-git-daemon","text":"Gitolite does not install or configure gitweb/git-daemon -- that is a one-time setup you must do separately.","title":"allowing access to gitweb and git-daemon"},{"location":"gitweb-daemon.html#gitweb","text":"The following repos are deemed to be readable by gitweb: Any repos readable by the special user gitweb . Any repos containing one or more of the following types of lines: (actually, any config variable starting with gitweb ). config gitweb.owner = owner name config gitweb.description = some description config gitweb.category = some category Side note: the following shorter forms are available as syntactic sugar for the above longer forms: owner = owner name desc = some description category = some category The list of gitweb-readable repos is written to a file whose name is given by the rc file variable GITWEB_PROJECTS_LIST . The default value of this variable, if it is not specified or empty, is $HOME/projects.list . In addition, each of the config variables described above is written to the repo to which it pertains, so that gitweb can use them.","title":"gitweb"},{"location":"gitweb-daemon.html#changing-the-umask","text":"Gitweb (or cgit, redmine, etc.) typically runs under a different userid, and the default permissions that gitolite sets make them unreadable. See the section on the UMASK variable in the page for the rc file .","title":"changing the UMASK"},{"location":"gitweb-daemon.html#repo-specific-authorisation-in-gitweb","text":"Gitweb has a feature whereby it will call a (perl) function that you supply, passing it the full path to the repo being accessed. If the remote user is authenticated, the username will be available, so your function can take those two pieces of information and return true or false to allow or deny the repository access. If you want to use gitolite's access rules in making this determination, you will first have to ensure that the HTTP username (i.e., the username known to apache/gitweb) is the same as the gitolite username. If you're using gitolite's http mode, this is probably already true, but if you're using the more widely used ssh mode, you'll have to make sure they match. You then need to add this code to your gitweb.conf.","title":"repo-specific authorisation in gitweb"},{"location":"gitweb-daemon.html#git-daemon","text":"Any repo readable by the special user daemon is deemed to be readable by git-daemon. For each of these repos, an empty file called git-daemon-export-ok is created in the repository (i.e., the repo.git directory inside $HOME/repositories ).","title":"git-daemon"},{"location":"gitweb-daemon.html#tips","text":"Setting descriptions en-masse usually does not make sense, but you can certainly do things like repo @all R = gitweb daemon assuming you have other means of setting 'gitweb.description' and 'gitweb.owner'. Also see this for a twist on that.","title":"tips"},{"location":"glssh.html","text":"how gitolite uses ssh \uf0c1 Although other forms of authentications exist (see the section on authentication versus authorisation ), ssh is the one that most git users use. Therefore, gitolite is (usually) heavily dependent on ssh . Most people didn't realise this, and even if they did they don't know ssh well enough to help themselves. If you don't understand how ssh public key authentication works, or how the ~/.ssh/authorized_keys file can be used to restrict users, etc., you will have endless amounts of trouble getting gitolite to work, because you'll be attacking the wrong problem. So please please please understand this before tearing your hair out and blaming git/gitolite for whatever is going wrong with your setup :-) ssh basics \uf0c1 Let's start with some basics, focusing only on the pieces relevant to gitolite . If this is not detailed enough, please use google and learn more from somewhere, or maybe buy the OReilly ssh book. You can login to an ssh server by typing a password, but ssh can also use public-private keys (also called \"key pairs\") for authentication. gitolite requires you to use this mechanism for your users -- they cannot log in using passwords. Hopefully by the time you finish reading this page you will understand why :-) The way you set this up is you generate a key pair on your workstation, and give the server the public key. (I need not add that the \"private\" key must be, well, kept private !) Generating a key pair on your workstation is done by running the command ssh-keygen -t rsa . This produces two files in ~/.ssh . One is id_rsa ; this is the private key -- never let it out of your machine. The other is id_rsa.pub , which is the corresponding public key. This public key is usually just one long line of text. On Windows machines with msysgit installed, you should do this from within a \"git bash\" window. The command will report the full path where the files have been written; make a note of this, and use those files in any of the description that follows. Adding your public key to the server 's ~/.ssh/authorized_keys file is how ssh uses pubkeys to authenticate users. Let's say sita@work.station is trying to log in as git@serv.er. What you have to do is take the ~/.ssh/id_rsa.pub file for user sita on work.station and append its contents (remember it's only one line) to ~/.ssh/authorized_keys for user git on serv.er. The authorized_keys file can have multiple public keys (from many different people) added to it so any of them can log in to git@serv.er. In the normal case (not gitolite, but your normal everyday shell access), there's a command that does this, ssh-copy-id , which also fixes up permissions etc., as needed, since sshd is a little picky about allowing pubkey access if permissions on the server are loose. Or you can do it manually, as long as you know what you're doing and you're careful not to erase or overwrite the existing contents of ~/.ssh/authorized_keys on the server! But with gitolite, it does this for you; see adding and removing users for more. Troubleshooting pubkey authentication failures : if you are unable to get ssh access to the server after doing all this, you'll have to look in /var/log/secure or /var/log/auth.log or some such file on the server to see what specific error sshd is complaining about. Restricting users to specific commands is very important for gitolite. If you read man sshd and look for authorized_keys file format , you'll see a lot of options you can add to the public key line, which restrict the incoming user in various ways. In particular, note the command= option, which means \"regardless of what the incoming user is asking to do, forcibly run this command instead\". Also note that when there are many public keys (i.e., lines) in the authorized_keys file, each line can have a different set of options and command= values. Without this command= option, the ssh daemon will simply give you a shell, which is not what we want for our gitolite keys (although we may well have other keys which we use to get a shell). This is the backbone of what makes gitolite work; please make sure you understand this . how does gitolite use all this ssh magic? \uf0c1 These are two different questions you ought to be having by now: How does it distinguish between me and someone else, since we're all logging in as the same remote user \"git\". How does it restrict what I can do within a repository. restricting shell access/distinguishing one user from another \uf0c1 The answer to the first question is the command= we talked about before. If you look in the authorized_keys file, you'll see entries like this (I chopped off the ends of course; they're pretty long lines): command=\"[path]/gitolite-shell sitaram\",[more options] ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA18S2t... command=\"[path]/gitolite-shell usertwo\",[more options] ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEArXtCT... First, it finds out which of the public keys in this file match the incoming login. That's crypto stuff, and I won't go into it. Once the match has been found, it will run the command given on that line; e.g., if I logged in, it would run [path]/gitolite-shell sitaram . So the first thing to note is that such users do not get \"shell access\", which is good! Before running the command, however, sshd sets up an environment variable called SSH_ORIGINAL_COMMAND which contains the actual git command that your workstation sent out. This is the command that would have run if you did not have the command= part in the authorised keys file. When gitolite-shell gets control, it looks at the first argument (\"sitaram\", \"usertwo\", etc) to determine who you are. It then looks at the SSH_ORIGINAL_COMMAND variable to find out which repository you want to access, and whether you're reading or writing. Now that it has a user, repository, and access requested (read/write), gitolite looks at its config file, and either allows or rejects the request. But this cannot differentiate between different branches within a repo; that has to be done separately. restricting branch level actions \uf0c1 [If you look inside the git source tree, there's a file among the \"howto\"s in there called update-hook-example.txt , which was the inspiration for this part of gitolite.] Git allows you to specify many \"hooks\", which get control as various events happen -- see git help hooks for details. One of those hooks is the update hook, which, if it is present, is invoked just before a branch or a tag is about to be updated. The hook is passed the name of the branch or tag, the old SHA1 value, and the new SHA1 value, as arguments. Hooks that are called before an action happens are allowed to prevent that action from happening by returning an error code. When gitolite is told to create a new repository (by the admin), it installs a special update hook. This hook takes all the information presented, looks at the config file, and decides to allow or reject the update. And that's basically it.","title":"how gitolite uses ssh"},{"location":"glssh.html#how-gitolite-uses-ssh","text":"Although other forms of authentications exist (see the section on authentication versus authorisation ), ssh is the one that most git users use. Therefore, gitolite is (usually) heavily dependent on ssh . Most people didn't realise this, and even if they did they don't know ssh well enough to help themselves. If you don't understand how ssh public key authentication works, or how the ~/.ssh/authorized_keys file can be used to restrict users, etc., you will have endless amounts of trouble getting gitolite to work, because you'll be attacking the wrong problem. So please please please understand this before tearing your hair out and blaming git/gitolite for whatever is going wrong with your setup :-)","title":"how gitolite uses ssh"},{"location":"glssh.html#ssh-basics","text":"Let's start with some basics, focusing only on the pieces relevant to gitolite . If this is not detailed enough, please use google and learn more from somewhere, or maybe buy the OReilly ssh book. You can login to an ssh server by typing a password, but ssh can also use public-private keys (also called \"key pairs\") for authentication. gitolite requires you to use this mechanism for your users -- they cannot log in using passwords. Hopefully by the time you finish reading this page you will understand why :-) The way you set this up is you generate a key pair on your workstation, and give the server the public key. (I need not add that the \"private\" key must be, well, kept private !) Generating a key pair on your workstation is done by running the command ssh-keygen -t rsa . This produces two files in ~/.ssh . One is id_rsa ; this is the private key -- never let it out of your machine. The other is id_rsa.pub , which is the corresponding public key. This public key is usually just one long line of text. On Windows machines with msysgit installed, you should do this from within a \"git bash\" window. The command will report the full path where the files have been written; make a note of this, and use those files in any of the description that follows. Adding your public key to the server 's ~/.ssh/authorized_keys file is how ssh uses pubkeys to authenticate users. Let's say sita@work.station is trying to log in as git@serv.er. What you have to do is take the ~/.ssh/id_rsa.pub file for user sita on work.station and append its contents (remember it's only one line) to ~/.ssh/authorized_keys for user git on serv.er. The authorized_keys file can have multiple public keys (from many different people) added to it so any of them can log in to git@serv.er. In the normal case (not gitolite, but your normal everyday shell access), there's a command that does this, ssh-copy-id , which also fixes up permissions etc., as needed, since sshd is a little picky about allowing pubkey access if permissions on the server are loose. Or you can do it manually, as long as you know what you're doing and you're careful not to erase or overwrite the existing contents of ~/.ssh/authorized_keys on the server! But with gitolite, it does this for you; see adding and removing users for more. Troubleshooting pubkey authentication failures : if you are unable to get ssh access to the server after doing all this, you'll have to look in /var/log/secure or /var/log/auth.log or some such file on the server to see what specific error sshd is complaining about. Restricting users to specific commands is very important for gitolite. If you read man sshd and look for authorized_keys file format , you'll see a lot of options you can add to the public key line, which restrict the incoming user in various ways. In particular, note the command= option, which means \"regardless of what the incoming user is asking to do, forcibly run this command instead\". Also note that when there are many public keys (i.e., lines) in the authorized_keys file, each line can have a different set of options and command= values. Without this command= option, the ssh daemon will simply give you a shell, which is not what we want for our gitolite keys (although we may well have other keys which we use to get a shell). This is the backbone of what makes gitolite work; please make sure you understand this .","title":"ssh basics"},{"location":"glssh.html#how-does-gitolite-use-all-this-ssh-magic","text":"These are two different questions you ought to be having by now: How does it distinguish between me and someone else, since we're all logging in as the same remote user \"git\". How does it restrict what I can do within a repository.","title":"how does gitolite use all this ssh magic?"},{"location":"glssh.html#restricting-shell-accessdistinguishing-one-user-from-another","text":"The answer to the first question is the command= we talked about before. If you look in the authorized_keys file, you'll see entries like this (I chopped off the ends of course; they're pretty long lines): command=\"[path]/gitolite-shell sitaram\",[more options] ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA18S2t... command=\"[path]/gitolite-shell usertwo\",[more options] ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEArXtCT... First, it finds out which of the public keys in this file match the incoming login. That's crypto stuff, and I won't go into it. Once the match has been found, it will run the command given on that line; e.g., if I logged in, it would run [path]/gitolite-shell sitaram . So the first thing to note is that such users do not get \"shell access\", which is good! Before running the command, however, sshd sets up an environment variable called SSH_ORIGINAL_COMMAND which contains the actual git command that your workstation sent out. This is the command that would have run if you did not have the command= part in the authorised keys file. When gitolite-shell gets control, it looks at the first argument (\"sitaram\", \"usertwo\", etc) to determine who you are. It then looks at the SSH_ORIGINAL_COMMAND variable to find out which repository you want to access, and whether you're reading or writing. Now that it has a user, repository, and access requested (read/write), gitolite looks at its config file, and either allows or rejects the request. But this cannot differentiate between different branches within a repo; that has to be done separately.","title":"restricting shell access/distinguishing one user from another"},{"location":"glssh.html#restricting-branch-level-actions","text":"[If you look inside the git source tree, there's a file among the \"howto\"s in there called update-hook-example.txt , which was the inspiration for this part of gitolite.] Git allows you to specify many \"hooks\", which get control as various events happen -- see git help hooks for details. One of those hooks is the update hook, which, if it is present, is invoked just before a branch or a tag is about to be updated. The hook is passed the name of the branch or tag, the old SHA1 value, and the new SHA1 value, as arguments. Hooks that are called before an action happens are allowed to prevent that action from happening by returning an error code. When gitolite is told to create a new repository (by the admin), it installs a special update hook. This hook takes all the information presented, looks at the config file, and decides to allow or reject the update. And that's basically it.","title":"restricting branch level actions"},{"location":"how.html","text":"% authentication and authorization in gitolite (viewing this slideshow) \uf0c1 This presentation uses HTML Slidy , a simple presentation software from the W3C. Although there's a help button in the footer of each presentation, it's missing some important stuff, so here's a smaller but more complete summary of the keyboard controls. .#d @@blue( Navigation )@@ | Next slide : right arrow, page down, space | Prev slide : left arrow, page up | Down within slide : down arrow | Up within slide : up arrow | First slide : home | Last slide : end .#d @@blue( Display )@@ | Smaller font : \"S\" or \"<\" key | Larger font : \"B\" or \">\" key | Toggle Current versus All slides : \"A\" key | Toggle Table of Contents popup : \"C\" key | Toggle footer : \"F\" key .#t @@blue( To search )@@ for stuff in the full document using your browser's Ctrl-F, first view all slides (press the \"A\" key). authentication versus authorisation \uf0c1 Before we start, we need to be clear about the difference between authentication and authorisation . .#d width=50% bgcolor=FFF0F0 Authentication checks user's identity (\"who are you?\") is NOT done by gitolite! although gitolite does help to set it up if you're using ssh is done by ssh server (or perhaps by http server if you are running gitolite in http mode) .#d bgcolor=#F0F0FF Authorisation check's user's access (\"now I know who you are, are you allowed to do what you want to do?\") This is what gitolite does .#t git over plain ssh \uf0c1 First, we'll recap how git works over plain ssh. .aa f0.png User Workstation Git Server ----------------------------+------------------------------------------------- git clone ---> ssh ---+---> sshd ------> git\u2010upload\u2010pack git fetch ---> ssh ---+---> sshd ------> git\u2010upload\u2010pack git push ---> ssh ---+---> sshd ------> git\u2010receive\u2010pack .end The client user authenticates herself to the server using any method supported by ssh -- password or ssh public key. It does not matter to either the git client or the git server how that happens; that's entirely between ssh and sshd (the ssh daemon or server). There is no authorisation in this mode, other than any file system permissions that the OS may enforce. how does gitolite work? \uf0c1 Gitolite adds an extra layer in between the sshd and the git-receive-pack (or git-upload-pack, for read operations), to check if the access is allowed and abort if needed. Gitolite also installs its own update hook (see man githooks ) in every repository to check branches being pushed. This means gitolite does two authorisation checks, as you will see. Gitolite also requires that the authentication must happen using an ssh public key. We'll see why as we go along. Here's a series of pictures that show how gitolite works. We're using a \"git push\" example; the only difference for a fetch or clone is that instead of git-receive-pack it'd call git-upload-pack , and the last check (update hook) does not apply. @@blue( Terminology reminder : \"ref\" in git parlance means \"branch or tag\". At least in this page that's what we mean :-))@@ the diagrams... \uf0c1 The diagrams were originally drawn to be self-contained. On a first pass you can simply ignore the text on each page, and come back to it later for the finer points. Experts: yes, I know I simplified the ssh part a lot. If you can find fault with these pictures, you're not the target audience :-) .aa f1.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client calls ssh v ssh client .end When the user runs a \"git push\" command, the git client calls ssh, passing it a command like git-receive-pack 'reponame' .aa f2.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client v ssh client reads ssh keypair v ~/.ssh/id_rsa ~/.ssh/id_rsa.pub .end The git client, before it starts talking to the server, looks for the user's ssh keys so it can use public key authentication (and not ask for a password). As you know, for gitolite to work, the user must already have an ssh key pair and the pub key already sent to the gitolite administrator who should have added it to gitolite (which in turn means it's part of ~/.ssh/authorized_keys on the server). .aa f3.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client calls v server ssh client -------------+--------> ssh server sends pubkey v ~/.ssh/id_rsa ~/.ssh/id_rsa.pub .end The ssh client sends the public key to the server to identify itself. .aa f4.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client v ssh client -------------+--------> ssh server v v ~/.ssh/id_rsa ~/.ssh/authorized_keys ~/.ssh/id_rsa.pub .end The server looks for the public key in its \"list of people who're allowed in\" ( ~/.ssh/authorized_keys ). If it finds it, things are good. @@red(If it doesn't find it, it tells the client and the client asks the user for a password. Which is BAD, because Gitolite doesn't work with passwords!)@@ .aa f5.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client v ssh client -------------+--------> ssh server v v ~/.ssh/id_rsa ~/.ssh/authorized_keys ~/.ssh/id_rsa.pub .end If authentication succeeds, the ssh server calls gitolite-shell, with the username as the first argument. Here's how that happens. When the administrator adds Alice's pubkey to gitolite, he names it \"alice.pub\", puts it in the \"keydir\" directory of a clone of the gitolite-admin repository, and pushes the new file to the server. When the Gitolite server receives that push, one of the things it does is add this key to ~/.ssh/authorized_keys file, but prefixed with a bunch of options, one of which is a \"command\" option that looks like this: command=\"/home/git/bin/gitolite-shell alice\" It is this \"command\" that the ssh daemon executes when the offered public key matches the public key in this line. For a different public key, from a different user, the command will have that user's name instead of \"alice\". This is how Gitolite distinguishes users from each other, even though they're all accessing the same ( git@host ) account. This is also why passwords won't work. When a user supplies a password, there's no additional information to help the ssh server distinguish one user from another. .aa f6.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client git\u2010receive\u2010pack v ssh client -------------+--------> ssh server v v ~/.ssh/id_rsa ~/.ssh/authorized_keys ~/.ssh/id_rsa.pub .end When the ssh daemon decided to execute /home/git/bin/gitolite-shell alice instead of the git-receive-pack 'reponame' command that the user's git client sent to the user's ssh client, it didn't simply discard the git-receive-pack command. It put it in an environment variable called SSH_ORIGINAL_COMMAND . Since that variable contains the repository name, and the username is the first argument passed to it, gitolite-shell now has enough information to decide \"is this user allowed to write to this repo\" (or \"read\", if the command was git-upload-pack). Assuming access is allowed, gitolite-shell then calls git-receive-pack (or git-upload-pack, as the case may be). This is the first authorisation check that gitolite does. Notice that git-receive-pack and git-upload-pack have NO idea that someone snuck in between them and the client calling them. Neither does the git client know. Gitolite is totally transparent to git clients unless access is denied for some reason. .aa f7.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- gitolite-installed update hook ^ : each ref pushed is checked Git client git\u2010receive\u2010pack v ssh client -------------+--------> ssh server v v ~/.ssh/id_rsa ~/.ssh/authorized_keys ~/.ssh/id_rsa.pub .end For a read (git-upload-pack), that is the end of the story. For a write, git will invoke the update hook for each branch or tag pushed. (See man githooks for details). This update hook, of course, has been installed by gitolite, and it proceeds to check if | - this user (alice, bob, ...) | - is allowed to do this (create, fast-forward push, non-fast-forward push, or delete) | - to this branch or tag (master, refs/tags/v1.0, ...) | - in this repo. This is the second authorisation check that gitolite does. If it is not allowed, the update hooks exits with an error, and git will abort the push (for that ref; other refs sent in the same push may be OK).","title":"How"},{"location":"how.html#viewing-this-slideshow","text":"This presentation uses HTML Slidy , a simple presentation software from the W3C. Although there's a help button in the footer of each presentation, it's missing some important stuff, so here's a smaller but more complete summary of the keyboard controls. .#d @@blue( Navigation )@@ | Next slide : right arrow, page down, space | Prev slide : left arrow, page up | Down within slide : down arrow | Up within slide : up arrow | First slide : home | Last slide : end .#d @@blue( Display )@@ | Smaller font : \"S\" or \"<\" key | Larger font : \"B\" or \">\" key | Toggle Current versus All slides : \"A\" key | Toggle Table of Contents popup : \"C\" key | Toggle footer : \"F\" key .#t @@blue( To search )@@ for stuff in the full document using your browser's Ctrl-F, first view all slides (press the \"A\" key).","title":"(viewing this slideshow)"},{"location":"how.html#authentication-versus-authorisation","text":"Before we start, we need to be clear about the difference between authentication and authorisation . .#d width=50% bgcolor=FFF0F0 Authentication checks user's identity (\"who are you?\") is NOT done by gitolite! although gitolite does help to set it up if you're using ssh is done by ssh server (or perhaps by http server if you are running gitolite in http mode) .#d bgcolor=#F0F0FF Authorisation check's user's access (\"now I know who you are, are you allowed to do what you want to do?\") This is what gitolite does .#t","title":"authentication versus authorisation"},{"location":"how.html#git-over-plain-ssh","text":"First, we'll recap how git works over plain ssh. .aa f0.png User Workstation Git Server ----------------------------+------------------------------------------------- git clone ---> ssh ---+---> sshd ------> git\u2010upload\u2010pack git fetch ---> ssh ---+---> sshd ------> git\u2010upload\u2010pack git push ---> ssh ---+---> sshd ------> git\u2010receive\u2010pack .end The client user authenticates herself to the server using any method supported by ssh -- password or ssh public key. It does not matter to either the git client or the git server how that happens; that's entirely between ssh and sshd (the ssh daemon or server). There is no authorisation in this mode, other than any file system permissions that the OS may enforce.","title":"git over plain ssh"},{"location":"how.html#how-does-gitolite-work","text":"Gitolite adds an extra layer in between the sshd and the git-receive-pack (or git-upload-pack, for read operations), to check if the access is allowed and abort if needed. Gitolite also installs its own update hook (see man githooks ) in every repository to check branches being pushed. This means gitolite does two authorisation checks, as you will see. Gitolite also requires that the authentication must happen using an ssh public key. We'll see why as we go along. Here's a series of pictures that show how gitolite works. We're using a \"git push\" example; the only difference for a fetch or clone is that instead of git-receive-pack it'd call git-upload-pack , and the last check (update hook) does not apply. @@blue( Terminology reminder : \"ref\" in git parlance means \"branch or tag\". At least in this page that's what we mean :-))@@","title":"how does gitolite work?"},{"location":"how.html#the-diagrams","text":"The diagrams were originally drawn to be self-contained. On a first pass you can simply ignore the text on each page, and come back to it later for the finer points. Experts: yes, I know I simplified the ssh part a lot. If you can find fault with these pictures, you're not the target audience :-) .aa f1.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client calls ssh v ssh client .end When the user runs a \"git push\" command, the git client calls ssh, passing it a command like git-receive-pack 'reponame' .aa f2.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client v ssh client reads ssh keypair v ~/.ssh/id_rsa ~/.ssh/id_rsa.pub .end The git client, before it starts talking to the server, looks for the user's ssh keys so it can use public key authentication (and not ask for a password). As you know, for gitolite to work, the user must already have an ssh key pair and the pub key already sent to the gitolite administrator who should have added it to gitolite (which in turn means it's part of ~/.ssh/authorized_keys on the server). .aa f3.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client calls v server ssh client -------------+--------> ssh server sends pubkey v ~/.ssh/id_rsa ~/.ssh/id_rsa.pub .end The ssh client sends the public key to the server to identify itself. .aa f4.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client v ssh client -------------+--------> ssh server v v ~/.ssh/id_rsa ~/.ssh/authorized_keys ~/.ssh/id_rsa.pub .end The server looks for the public key in its \"list of people who're allowed in\" ( ~/.ssh/authorized_keys ). If it finds it, things are good. @@red(If it doesn't find it, it tells the client and the client asks the user for a password. Which is BAD, because Gitolite doesn't work with passwords!)@@ .aa f5.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client v ssh client -------------+--------> ssh server v v ~/.ssh/id_rsa ~/.ssh/authorized_keys ~/.ssh/id_rsa.pub .end If authentication succeeds, the ssh server calls gitolite-shell, with the username as the first argument. Here's how that happens. When the administrator adds Alice's pubkey to gitolite, he names it \"alice.pub\", puts it in the \"keydir\" directory of a clone of the gitolite-admin repository, and pushes the new file to the server. When the Gitolite server receives that push, one of the things it does is add this key to ~/.ssh/authorized_keys file, but prefixed with a bunch of options, one of which is a \"command\" option that looks like this: command=\"/home/git/bin/gitolite-shell alice\" It is this \"command\" that the ssh daemon executes when the offered public key matches the public key in this line. For a different public key, from a different user, the command will have that user's name instead of \"alice\". This is how Gitolite distinguishes users from each other, even though they're all accessing the same ( git@host ) account. This is also why passwords won't work. When a user supplies a password, there's no additional information to help the ssh server distinguish one user from another. .aa f6.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- Git client git\u2010receive\u2010pack v ssh client -------------+--------> ssh server v v ~/.ssh/id_rsa ~/.ssh/authorized_keys ~/.ssh/id_rsa.pub .end When the ssh daemon decided to execute /home/git/bin/gitolite-shell alice instead of the git-receive-pack 'reponame' command that the user's git client sent to the user's ssh client, it didn't simply discard the git-receive-pack command. It put it in an environment variable called SSH_ORIGINAL_COMMAND . Since that variable contains the repository name, and the username is the first argument passed to it, gitolite-shell now has enough information to decide \"is this user allowed to write to this repo\" (or \"read\", if the command was git-upload-pack). Assuming access is allowed, gitolite-shell then calls git-receive-pack (or git-upload-pack, as the case may be). This is the first authorisation check that gitolite does. Notice that git-receive-pack and git-upload-pack have NO idea that someone snuck in between them and the client calling them. Neither does the git client know. Gitolite is totally transparent to git clients unless access is denied for some reason. .aa f7.png User Workstation Gitolite Server ----------------------------+------------------------------------------------- gitolite-installed update hook ^ : each ref pushed is checked Git client git\u2010receive\u2010pack v ssh client -------------+--------> ssh server v v ~/.ssh/id_rsa ~/.ssh/authorized_keys ~/.ssh/id_rsa.pub .end For a read (git-upload-pack), that is the end of the story. For a write, git will invoke the update hook for each branch or tag pushed. (See man githooks for details). This update hook, of course, has been installed by gitolite, and it proceeds to check if | - this user (alice, bob, ...) | - is allowed to do this (create, fast-forward push, non-fast-forward push, or delete) | - to this branch or tag (master, refs/tags/v1.0, ...) | - in this repo. This is the second authorisation check that gitolite does. If it is not allowed, the update hooks exits with an error, and git will abort the push (for that ref; other refs sent in the same push may be OK).","title":"the diagrams..."},{"location":"http.html","text":"installing on a smart http git server \uf0c1 Note: \"smart http\" refers to the feature that came with git 1.6.6, late 2009 or so. The base documentation for this is man git-http-backend . Do NOT read Documentation/howto/setup-git-server-over-http.txt and think that is the same or even relevant -- that is from 2006 and is quite different (and arguably obsolete). WARNINGS and important notes \uf0c1 Please read authentication versus authorisation first, and make sure you understand what is gitolite's responsibility and what isn't. I have tested this only on stock Fedora (whatever is the current version); YDMV. assumptions: \uf0c1 Apache 2.x and git installed. Httpd runs under the \"apache\" userid; adjust instructions below if not. Similarly for \"/var/www\" and other file names/locations. instructions \uf0c1 In place of detailed instructions, there is a script called t/smart-http.root-setup . Do NOT run this script as is -- it is actually meant for my testing setup and deletes stuff . However, it does provide an excellent (and working!) narration of what you need to do to install gitolite in smart http mode. Make a copy of the script, go through it carefully, (possibly removing lines that delete files etc.), change values per your system, and only then run it. Note: The GIT_PROJECT_ROOT variable (see \"man git-http-backend\") is no longer optional. Make sure you set it to some place outside apache's DOCUMENT_ROOT . allowing unauthenticated access \uf0c1 If you want users to see repos without performing any HTTP authentication, you should first decide what repos they should have unauthenticated access to: repo foo bar baz # or maybe '@all'? R = nobody Then in the rc file ( ~/.gitolite.rc ), in the section marked \"rc variables used by various features\", add this (including the trailing comma): HTTP_ANON_USER => 'nobody', Updated 2019-10-19 The above does not seem to work any more. The way it was supposed to work was that the user could supply a userid, or not. If he did not, then gitolite would notice (the environment variable REMOTE_USER would be empty) and would then use whatever was specified above (in this case, nobody ). This does not seem to happen any more. Apache seems to insist on a userid, period. Unfortunately I am very far from being an expert in apache configuration, so, if someone can make this work without requiring any userid at all, please let me know. Making repositories available to both ssh and http mode clients \uf0c1 This section has been contributed by Thomas Hager (duke at sigsegv dot at), and is available here . usage \uf0c1 client side \uf0c1 Git URLs look like https://user:password@server/git/reponame.git . The custom commands, like \"info\", \"expand\" should be handled as follows. The command name will come just after the /git/ , followed by a ? , followed by the arguments, with + representing a space. Here are some examples: # ssh git@server info curl https://user:password@server/git/info # ssh git@server info repopatt curl https://user:password@server/git/info?repopatt # ssh git@server info repopatt user1 user2 curl https://user:password@server/git/info?repopatt+user1+user2 With a few nice shell aliases, you won't even notice the horrible convolutions here ;-) See t/smart-http for a couple of useful ones. server side \uf0c1 The gitolite command (for example, gitolite compile , gitolite query-rc , and so on) can be run on the server, but it's not straightforward. Assuming you installed exactly as given in this page, you should get a shell by using, say, su -s /bin/bash - apache run export HOME=$HOME/gitolite-home run export PATH=$PATH:$HOME/bin and then you can run gitolite <subcommand>","title":"HTTP mode install"},{"location":"http.html#installing-on-a-smart-http-git-server","text":"Note: \"smart http\" refers to the feature that came with git 1.6.6, late 2009 or so. The base documentation for this is man git-http-backend . Do NOT read Documentation/howto/setup-git-server-over-http.txt and think that is the same or even relevant -- that is from 2006 and is quite different (and arguably obsolete).","title":"installing on a smart http git server"},{"location":"http.html#warnings-and-important-notes","text":"Please read authentication versus authorisation first, and make sure you understand what is gitolite's responsibility and what isn't. I have tested this only on stock Fedora (whatever is the current version); YDMV.","title":"WARNINGS and important notes"},{"location":"http.html#assumptions","text":"Apache 2.x and git installed. Httpd runs under the \"apache\" userid; adjust instructions below if not. Similarly for \"/var/www\" and other file names/locations.","title":"assumptions:"},{"location":"http.html#instructions","text":"In place of detailed instructions, there is a script called t/smart-http.root-setup . Do NOT run this script as is -- it is actually meant for my testing setup and deletes stuff . However, it does provide an excellent (and working!) narration of what you need to do to install gitolite in smart http mode. Make a copy of the script, go through it carefully, (possibly removing lines that delete files etc.), change values per your system, and only then run it. Note: The GIT_PROJECT_ROOT variable (see \"man git-http-backend\") is no longer optional. Make sure you set it to some place outside apache's DOCUMENT_ROOT .","title":"instructions"},{"location":"http.html#allowing-unauthenticated-access","text":"If you want users to see repos without performing any HTTP authentication, you should first decide what repos they should have unauthenticated access to: repo foo bar baz # or maybe '@all'? R = nobody Then in the rc file ( ~/.gitolite.rc ), in the section marked \"rc variables used by various features\", add this (including the trailing comma): HTTP_ANON_USER => 'nobody', Updated 2019-10-19 The above does not seem to work any more. The way it was supposed to work was that the user could supply a userid, or not. If he did not, then gitolite would notice (the environment variable REMOTE_USER would be empty) and would then use whatever was specified above (in this case, nobody ). This does not seem to happen any more. Apache seems to insist on a userid, period. Unfortunately I am very far from being an expert in apache configuration, so, if someone can make this work without requiring any userid at all, please let me know.","title":"allowing unauthenticated access"},{"location":"http.html#making-repositories-available-to-both-ssh-and-http-mode-clients","text":"This section has been contributed by Thomas Hager (duke at sigsegv dot at), and is available here .","title":"Making repositories available to both ssh and http mode clients"},{"location":"http.html#usage","text":"","title":"usage"},{"location":"http.html#client-side","text":"Git URLs look like https://user:password@server/git/reponame.git . The custom commands, like \"info\", \"expand\" should be handled as follows. The command name will come just after the /git/ , followed by a ? , followed by the arguments, with + representing a space. Here are some examples: # ssh git@server info curl https://user:password@server/git/info # ssh git@server info repopatt curl https://user:password@server/git/info?repopatt # ssh git@server info repopatt user1 user2 curl https://user:password@server/git/info?repopatt+user1+user2 With a few nice shell aliases, you won't even notice the horrible convolutions here ;-) See t/smart-http for a couple of useful ones.","title":"client side"},{"location":"http.html#server-side","text":"The gitolite command (for example, gitolite compile , gitolite query-rc , and so on) can be run on the server, but it's not straightforward. Assuming you installed exactly as given in this page, you should get a shell by using, say, su -s /bin/bash - apache run export HOME=$HOME/gitolite-home run export PATH=$PATH:$HOME/bin and then you can run gitolite <subcommand>","title":"server side"},{"location":"install.html","text":"install and setup \uf0c1 IMPORTANT Almost nothing in gitolite requires root (with some obvious exceptions). Unless the documentation says \"do this from root \", assume it is to be done from the hosting user account. This page is about an ssh mode installation. It should work for most people, but if you are an absolute newbie to Unix etc., you may want to click here for a very detailed, step-by-step, hopefully fool-proof set of instructions. If ssh is not your thing, there's a different page for http mode installation. before you start... (pre-requisites) \uf0c1 your skills \uf0c1 Please DO read the concepts and terminology page before doing anything here. If you're installing gitolite, you're a \"system admin\", like it or not. Since most people use the ssh mode, ssh is therefore a necessary skill. Please take the time to learn at least enough to get passwordless access working. You also need to be somewhat familiar with git itself. You cannot administer a whole bunch of git repositories if you don't know the basics of git. Please make sure you understand at least the following concepts: bare versus non-bare repos, cloning a repo, making changes and committing them, pushing commits to a 'remote', the special remote called 'origin', difference between a fast-forward push and a rewind push, 'refs' (i.e., branches and tags) . It also helps to understand git's hooks mechanism, git-config, and so on. Some familiarity with Unix and shells is probably required. Regular expressions are a big part of gitolite in many places but familiarity is not necessary to do basic access control. your server \uf0c1 Any Unix system with a posix compatible \"sh\" and a sane file system. Git version 1.6.6 or later. Perl 5.8.8 or later (see https://lwn.net/Articles/348084/ if this does not seem to be enough). Openssh (almost any version). Optional if you're using smart http . IMPORTANT : although a default openssh config will not do this (AFAIK), do not allow the user to set environment variables if you care about security at all. A dedicated Unix userid to be the hosting user, usually \"git\" but it can be any user, even your own normal one. (If you're using an RPM/DEB the install probably created one called \"gitolite\"). you and your users' clients \uf0c1 Openssh client. Git 1.6.6 or later. Almost any git client will work, as long as it knows how to use ssh keys and send the right one along. cautions and caveats \uf0c1 Please take note of the following points : If you're bringing existing repos into gitolite, please see this first. Gitolite expects all the directories and files it manages/uses to be owned by the hosting user and not have strange permissions and ownerships. Gitolite does NOT like it if you fiddle with files and directories it cares about in any way except as directed in the documentation. Gitolite depends on several system-installed packages: openssh, git, perl, sh being the main ones. They should all be configured sensibly and with most of the normal defaults. (For example, if your sshd config says the authorized keys file should be placed in some directory other than the default, expect trouble). trying out gitolite safely \uf0c1 If you're not sure if gitolite is right for you or your system, it's easy to take it for a trial run, in ssh mode, and play with all of its features (except mirroring). This is very safe, and does not affect anything on your system permanently. WARNING: this will clobber these files and directories in your $HOME . Ideally, you should use a throwaway userid . Just create a throw-away userid , log in to it, then run these commands: git clone https://github.com/sitaramc/gitolite cd gitolite prove t/ssh* You will get an error that forces you to read t/README and set an env var before the test can proceed. This is intentional; I've had people who don't pay attention to the \"data loss\" warning, and then complain that it was not prominent enough. Forcing them to read a much smaller page appears to focus their attention better! If it doesn't work, re-read this page to see if you may have missed something that gitolite requires, or ask for support . If it works, you get a gitolite installation with 7 gitolite users (\"admin\", and \"u1\" through \"u6\"). Don't forget that the client and the server are all on the same user on the same machine; we're simulating 7 gitolite users using ssh keys! (How? Maybe ~/.ssh/config will give you a hint). URLs look like user:repo , so for example you can clone the admin repo by git clone admin:gitolite-admin . Remote commands look like ssh u1 info . So start by cloning the admin repo, and try out whatever you want! install and setup \uf0c1 This section talks about installing the software manually (i.e., not using a package manager) and setting it up. The install step gets the code to where you want it. The setup step creates the files and directories gitolite needs, including the special gitolite-admin repo, and makes you an administrator so you can manage it remotely. If you install gitolite using a package manager, you should check your distro-standard mechanisms or distro-supplied documentation for how to complete the installation. Important: On package manager installs : make sure you get gitolite v3.x . The correct package you want may be called \"gitolite3\", even though \"gitolite\" also exists. If you want to know what the latest gitolite version is, the gitolite CHANGELOG will tell you. (a graphical overview) \uf0c1 Here's a graphical overview of what files/directories are affected by each step in the install+setup process. Alice is installing gitolite, with herself as the administrator. The files names you see there are only for information . You do not have to do anything to them yourself; in fact you should not! You only need the command for each numbered step shown: Copy the admin's pubkey to the server as \"alice.pub\". Run git clone https://github.com/sitaramc/gitolite or equivalent. Run gitolite/install -ln . Run gitolite setup -pk alice.pub . Note also that you only need ONE real user on the server. In our example it is git. In particular, you do NOT create Unix userids for your gitolite users. prepare for the install \uf0c1 The simplest, most foolproof, way of ensuring that your gitolite install + setup will succeed is to use a brand new userid as the hosting user. If that is not possible, make sure the following do NOT exist in that user's home directory: ~/.gitolite.rc , ~/.gitolite , ~/repositories , and ~/.ssh/authorized_keys . Before you go trashing that authorized keys file, please make sure you know the password to the 'git' user, or know the root password on the machine! The authorized keys file can exist, actually, as long as none of the keys you intend to use with gitolite are present in it. But again, if you're not an ssh guru, you should probably play safe. get the software \uf0c1 Get the software using git-clone: git clone https://github.com/sitaramc/gitolite You can use this as is, or you can check out the latest tag to make sure you're running a tagged version instead of just the current 'master'. install \uf0c1 Gitolite has one server side command: gitolite . You don't need to place it anywhere special; in the worst case you can run it with the full path. \"Installation\" consists of deciding where to put it: Keep the sources anywhere and use the full path to run the gitolite command. Keep the sources anywhere and symlink just the gitolite program to some directory on your $PATH . Copy the sources somewhere and use that path to run the gitolite command. Option 2 is the best for general use, but here's the scoop on all of them: # option 1 gitolite/install # option 2 gitolite/install -ln # defaults to $HOME/bin (which is assumed to exist) # ** or ** # or use a specific directory (please supply FULL path): gitolite/install -ln /usr/local/bin # option 3 # (again, please supply a FULL path) gitolite/install -to /usr/local/gitolite/bin Creating a symlink doesn't need a separate program but 'install' also runs git describe to create a VERSION file, which can be very important if you want support :-) setup \uf0c1 For the first-time setup, you need to have a public key file (usually from the admin's workstation) ready. If the main gitolite admin's username is \"alice\", this file should be named \"alice.pub\" and copied to the server. Once that is done, run: gitolite setup -pk alice.pub If that completes without any warnings, you are done. If it had a warning, you probably supplied a key which already has shell access to the server. That won't work; you'll have to generate and use a different key pair for gitolite access and use host aliases to distinguish between the two. While you're there, read both the ssh pages. Twice. upgrades \uf0c1 Update your clone of the gitolite source. Repeat the install command you used earlier (make sure you use the same arguments as before). Run gitolite setup . After you upgrade gitolite, you may also want to upgrade your rc file ( ~/.gitolite.rc ). See the rc file documentation for that. moving servers \uf0c1 Nothing in any of the gitolite install/setup/etc will ever touch the data in any repository except the gitolite-admin repo. The only thing it will normally touch is the update hook. So one fool-proof way of \"moving\" servers is this: Clone the latest gitolite-admin repo from the old server to your workstation. Make sure you have an admin key that has RW+ rights to the gitolite-admin repo; you will need this later. Install gitolite on the new server, using the same key for the admin as for the old server. Copy the rc file from the old server, overwriting this one. Disable the old server so people won't push to it. Copy all the repos over from the old server. Make sure the files end up with the right ownership and permissions; if not, chown/chmod them. The gitolite-admin repo already exists on the new server (it's just a bare bones conf file). Do NOT overwrite it. (Not because it contains anything useful, but because the next step will then fail!) Go to the clone you made in step 1, add a new remote (or change an existing one) to point to the new server, then git push -f to it. Run gitolite setup on the server.","title":"normal ssh mode install and setup"},{"location":"install.html#install-and-setup","text":"IMPORTANT Almost nothing in gitolite requires root (with some obvious exceptions). Unless the documentation says \"do this from root \", assume it is to be done from the hosting user account. This page is about an ssh mode installation. It should work for most people, but if you are an absolute newbie to Unix etc., you may want to click here for a very detailed, step-by-step, hopefully fool-proof set of instructions. If ssh is not your thing, there's a different page for http mode installation.","title":"install and setup"},{"location":"install.html#before-you-start-pre-requisites","text":"","title":"before you start... (pre-requisites)"},{"location":"install.html#your-skills","text":"Please DO read the concepts and terminology page before doing anything here. If you're installing gitolite, you're a \"system admin\", like it or not. Since most people use the ssh mode, ssh is therefore a necessary skill. Please take the time to learn at least enough to get passwordless access working. You also need to be somewhat familiar with git itself. You cannot administer a whole bunch of git repositories if you don't know the basics of git. Please make sure you understand at least the following concepts: bare versus non-bare repos, cloning a repo, making changes and committing them, pushing commits to a 'remote', the special remote called 'origin', difference between a fast-forward push and a rewind push, 'refs' (i.e., branches and tags) . It also helps to understand git's hooks mechanism, git-config, and so on. Some familiarity with Unix and shells is probably required. Regular expressions are a big part of gitolite in many places but familiarity is not necessary to do basic access control.","title":"your skills"},{"location":"install.html#your-server","text":"Any Unix system with a posix compatible \"sh\" and a sane file system. Git version 1.6.6 or later. Perl 5.8.8 or later (see https://lwn.net/Articles/348084/ if this does not seem to be enough). Openssh (almost any version). Optional if you're using smart http . IMPORTANT : although a default openssh config will not do this (AFAIK), do not allow the user to set environment variables if you care about security at all. A dedicated Unix userid to be the hosting user, usually \"git\" but it can be any user, even your own normal one. (If you're using an RPM/DEB the install probably created one called \"gitolite\").","title":"your server"},{"location":"install.html#you-and-your-users-clients","text":"Openssh client. Git 1.6.6 or later. Almost any git client will work, as long as it knows how to use ssh keys and send the right one along.","title":"you and your users' clients"},{"location":"install.html#cautions-and-caveats","text":"Please take note of the following points : If you're bringing existing repos into gitolite, please see this first. Gitolite expects all the directories and files it manages/uses to be owned by the hosting user and not have strange permissions and ownerships. Gitolite does NOT like it if you fiddle with files and directories it cares about in any way except as directed in the documentation. Gitolite depends on several system-installed packages: openssh, git, perl, sh being the main ones. They should all be configured sensibly and with most of the normal defaults. (For example, if your sshd config says the authorized keys file should be placed in some directory other than the default, expect trouble).","title":"cautions and caveats"},{"location":"install.html#trying-out-gitolite-safely","text":"If you're not sure if gitolite is right for you or your system, it's easy to take it for a trial run, in ssh mode, and play with all of its features (except mirroring). This is very safe, and does not affect anything on your system permanently. WARNING: this will clobber these files and directories in your $HOME . Ideally, you should use a throwaway userid . Just create a throw-away userid , log in to it, then run these commands: git clone https://github.com/sitaramc/gitolite cd gitolite prove t/ssh* You will get an error that forces you to read t/README and set an env var before the test can proceed. This is intentional; I've had people who don't pay attention to the \"data loss\" warning, and then complain that it was not prominent enough. Forcing them to read a much smaller page appears to focus their attention better! If it doesn't work, re-read this page to see if you may have missed something that gitolite requires, or ask for support . If it works, you get a gitolite installation with 7 gitolite users (\"admin\", and \"u1\" through \"u6\"). Don't forget that the client and the server are all on the same user on the same machine; we're simulating 7 gitolite users using ssh keys! (How? Maybe ~/.ssh/config will give you a hint). URLs look like user:repo , so for example you can clone the admin repo by git clone admin:gitolite-admin . Remote commands look like ssh u1 info . So start by cloning the admin repo, and try out whatever you want!","title":"trying out gitolite safely"},{"location":"install.html#install-and-setup_1","text":"This section talks about installing the software manually (i.e., not using a package manager) and setting it up. The install step gets the code to where you want it. The setup step creates the files and directories gitolite needs, including the special gitolite-admin repo, and makes you an administrator so you can manage it remotely. If you install gitolite using a package manager, you should check your distro-standard mechanisms or distro-supplied documentation for how to complete the installation. Important: On package manager installs : make sure you get gitolite v3.x . The correct package you want may be called \"gitolite3\", even though \"gitolite\" also exists. If you want to know what the latest gitolite version is, the gitolite CHANGELOG will tell you.","title":"install and setup"},{"location":"install.html#a-graphical-overview","text":"Here's a graphical overview of what files/directories are affected by each step in the install+setup process. Alice is installing gitolite, with herself as the administrator. The files names you see there are only for information . You do not have to do anything to them yourself; in fact you should not! You only need the command for each numbered step shown: Copy the admin's pubkey to the server as \"alice.pub\". Run git clone https://github.com/sitaramc/gitolite or equivalent. Run gitolite/install -ln . Run gitolite setup -pk alice.pub . Note also that you only need ONE real user on the server. In our example it is git. In particular, you do NOT create Unix userids for your gitolite users.","title":"(a graphical overview)"},{"location":"install.html#prepare-for-the-install","text":"The simplest, most foolproof, way of ensuring that your gitolite install + setup will succeed is to use a brand new userid as the hosting user. If that is not possible, make sure the following do NOT exist in that user's home directory: ~/.gitolite.rc , ~/.gitolite , ~/repositories , and ~/.ssh/authorized_keys . Before you go trashing that authorized keys file, please make sure you know the password to the 'git' user, or know the root password on the machine! The authorized keys file can exist, actually, as long as none of the keys you intend to use with gitolite are present in it. But again, if you're not an ssh guru, you should probably play safe.","title":"prepare for the install"},{"location":"install.html#get-the-software","text":"Get the software using git-clone: git clone https://github.com/sitaramc/gitolite You can use this as is, or you can check out the latest tag to make sure you're running a tagged version instead of just the current 'master'.","title":"get the software"},{"location":"install.html#install","text":"Gitolite has one server side command: gitolite . You don't need to place it anywhere special; in the worst case you can run it with the full path. \"Installation\" consists of deciding where to put it: Keep the sources anywhere and use the full path to run the gitolite command. Keep the sources anywhere and symlink just the gitolite program to some directory on your $PATH . Copy the sources somewhere and use that path to run the gitolite command. Option 2 is the best for general use, but here's the scoop on all of them: # option 1 gitolite/install # option 2 gitolite/install -ln # defaults to $HOME/bin (which is assumed to exist) # ** or ** # or use a specific directory (please supply FULL path): gitolite/install -ln /usr/local/bin # option 3 # (again, please supply a FULL path) gitolite/install -to /usr/local/gitolite/bin Creating a symlink doesn't need a separate program but 'install' also runs git describe to create a VERSION file, which can be very important if you want support :-)","title":"install"},{"location":"install.html#setup","text":"For the first-time setup, you need to have a public key file (usually from the admin's workstation) ready. If the main gitolite admin's username is \"alice\", this file should be named \"alice.pub\" and copied to the server. Once that is done, run: gitolite setup -pk alice.pub If that completes without any warnings, you are done. If it had a warning, you probably supplied a key which already has shell access to the server. That won't work; you'll have to generate and use a different key pair for gitolite access and use host aliases to distinguish between the two. While you're there, read both the ssh pages. Twice.","title":"setup"},{"location":"install.html#upgrades","text":"Update your clone of the gitolite source. Repeat the install command you used earlier (make sure you use the same arguments as before). Run gitolite setup . After you upgrade gitolite, you may also want to upgrade your rc file ( ~/.gitolite.rc ). See the rc file documentation for that.","title":"upgrades"},{"location":"install.html#moving-servers","text":"Nothing in any of the gitolite install/setup/etc will ever touch the data in any repository except the gitolite-admin repo. The only thing it will normally touch is the update hook. So one fool-proof way of \"moving\" servers is this: Clone the latest gitolite-admin repo from the old server to your workstation. Make sure you have an admin key that has RW+ rights to the gitolite-admin repo; you will need this later. Install gitolite on the new server, using the same key for the admin as for the old server. Copy the rc file from the old server, overwriting this one. Disable the old server so people won't push to it. Copy all the repos over from the old server. Make sure the files end up with the right ownership and permissions; if not, chown/chmod them. The gitolite-admin repo already exists on the new server (it's just a bare bones conf file). Do NOT overwrite it. (Not because it contains anything useful, but because the next step will then fail!) Go to the clone you made in step 1, add a new remote (or change an existing one) to point to the new server, then git push -f to it. Run gitolite setup on the server.","title":"moving servers"},{"location":"internals.html","text":"gitolite internals \uf0c1 This page is for people who may want to hack on core gitolite itself. This is not the page for people who merely want to customise their site (i.e., write their own VREFs, triggers, etc.); for that please start with the non-core page. This document assumes you're familiar with the material in the how does it work section in the \"overview\" document, as well as the concepts page. If you're not familiar with ssh, and in particular how programs like gitolite use ssh to simulate many users over one Unix user, the ssh page has useful info. what is \"core\" \uf0c1 The core code consists mainly of src/gitolite , src/gitolite-shell , and all the perl modules in src/lib/Gitolite except src/lib/Gitolite/Triggers . That said, there are parts of non-core that, in a default (ssh) install, are used frequently enough to be important (for example if you are reviewing gitolite): commands in src/commands : access, git-config, info, mirror, option, owns, perms triggers in src/lib/Gitolite/Triggers : Mirroring.pm, Shell.pm triggers in src/triggers and src/triggers/post-compile : ssh-authkeys, ssh-authkeys-shell-users, update-git-configs, set-default-roles, entry points \uf0c1 gitolite \uf0c1 Most server-side operations that gitolite supports are invoked via the gitolite command. This includes initial setup and maintenance, some built-in commands (run 'gitolite -h' to see them), and finally the commands in src/commands (run 'gitolite help' to get a list). gitolite-shell \uf0c1 All remote access is via the gitolite-shell command, (invoked, of course, by sshd). This includes both git operations (clone, fetch, push) as well as gitolite commands that have been enabled for remote invocation. For git operations, gitolite-shell does the initial access check (\"is the user even allowed to read/write this repo at all?\") and then calls git proper. Most of the code in this is housekeeping; the real action happens in one of the modules. the Conf module \uf0c1 The Conf module and its child modules deal with the gitolite.conf file. Conf is where the 'compile' command lands. The parser for the conf file is also in this module; each \"recognised\" line is passed to appropriate functions in Conf::Store . Please note the parser is a very simple line-oriented parser using simple regexes; the DSL for the gitolite.conf file is intentionally very simple. Conf::Explode \uf0c1 This deals with \"exploding\" the main gitolite.conf file into a single perl list with all 'include' files recursively expanded. Conf::Sugar \uf0c1 This calls Conf::Explode to get the full set of conf lines, then applies a series of \"syntactic sugar\" transformations to them. This keeps the main parser simple, while allowing the administrator to take some shortcuts in writing the rules. Some transformations are built-in and hardcoded, but a site can add their own site-local transformations if they like. Conf::Store \uf0c1 Conf::Store is one of the two workhorses of gitolite. It exports functions related to processing parsed lines and storing the parsed output for later use. It also exports functions that deal with creating and setting up new repos. The output of the compile step is essentially a set of perl hashes in Data::Dumper format. Rules that apply to more than one repo (i.e., the repo name was a regex pattern or a group name) go into a \"common\" output file ( ~/.gitolite/conf/gitolite.conf-compiled.pm ), while rules that apply to specific repos go into their own files ( ~/repositories/$REPONAME.git/gl-conf ). From a security perspective, dealing with 'subconf' (see delegation for details) happens in this module. Conf::Load \uf0c1 Conf::Load is the other of the two workhorses of gitolite. The most important function it exports is access , which is used by gitolite-shell as well as by the update hook code to check for permissions. This code has a few optimisations, including very simple, localised, caching of parsed conf files when needed. TODO: How the access function does its thing will be written up in more detail as I find time, but TLDR: it calls rules which builds up a list of the rules that apply. Also see this until I manage to write it up in more detail. Other functions are git_config , which returns a list of config values specified in the conf file. Finally, this is where all the \"list-\" commands that 'gitolite -h' shows you (e.g., 'gitolite list-repos') land up. the Rc module \uf0c1 The rc file ( ~/.gitolite.rc ) is processed here. In addition, it also declares a bunch of constants (like the all-important regex patterns to validate user inputs of various kinds; all ending in _PATT ). The only complicated part of this is how the non_core_expand function takes the $non_core variable (currently 63 lines long!) and converts it into a set of arrays, one for each of the triggers types. You can see the effect of this logic by uncommenting something in the ENABLE list in the rc file, then running gitolite query-rc PRE_GIT , etc. (From a security point of view this is irrelevant. Any inputs it receives come from totally trusted sources -- either the gitolite source code or the rc file). Finally, the trigger function is also exported by this module. This is the function that actually runs all the programs tied to each trigger. the Hooks module \uf0c1 This is where the code for the update hook (all repos) and the post-update hook (gitolite-admin repo only) can be found. The post-update hook code is fairly straightforward, consisting essentially of three shell commands. The update hook code has a lot more \"action\", since this is where all access checking for 'git push' goes. Even that would not be much if it weren't for VREFs, because then it's just one call to the access function (from the Conf::Load module). The only other thing of note in this module is how the \"attempted access\" is determined. Externally, we only know it's a \"push\" (i.e., a \"W\" in gitolite permission terms). We need to compare the old and the new SHAs in various ways to determine if it's a rewind, or a delete, or a create, etc., which may make a difference to the access. TODO: expand on VREF handling. For now please read vref to get the general idea of what it does, while I find time to write up the how . the rest... \uf0c1 ...is TBD (to be done). Briefly, the Test module is for testing, the Common module contains a whole bunch of common routines used all over -- many of them not gitolite specific at all, Cache is not to be used for now (sorry, bitrotted by now I think... I may need to take it out behind the woodshed one of these days). security notes \uf0c1 All security issues should be reported directly to me (sitaramc@gmail.com), and not to the mailing list. (In the following text, the words MUST, SHOULD, etc. are loosely as defined in RFC 2119). Gitolite MUST protect everything in ~/repositories from people who do not have command line access to the user hosting the service, and do not have \"push\" access rights to the gitolite-admin repository. Specifically, gitolite MUST prevent such users from doing anything except the following: perform git operations they are allowed to by gitolite.conf run gitolite commands that are enabled for remote use People who have command line access are considered to be \"in\"; nothing in gitolite attempts to protect from them (it's impossible anyway!) But someone who does not have command line access, but does have push access rights to the gitolite-admin repo (a \"gitolite admin\"), is a special case. Gitolite SHOULD prevent a gitolite admin from using that to pivot to executing arbitrary commands on the server. (This is why, for example, the gitolite-admin repo can't have arbitrary \"config\" lines.) However, many sites don't care about this distinction -- all their gitolite admins already have shell access. Thus, a violation of this is important and should be fixed, but not considered critical. Gitolite SHOULD try to make sure that the gitolite commands shipped with gitolite do not indirectly enable violation of the restrictions in the first bullet. The seriousness of failing this depends on the command in question (is the command enabled in the default setup, or even if it is not, is it a popular and widely used command, etc.) Gitolite SHOULD protect the local sysadmin from his own errors to some extent. For example, it should be possible to write a new \"command\" in shell, without worrying about shell meta-characters sneaking in and executing something; gitolite should prevent this from happening. As you probably knew already, gitolite does not do authentication; it only deals with authorisation. Still, gitolite MAY help the administrator to setup authentication (as the default setup does when used in ssh mode), but it is not mandatory. In particular, use in http-mode leaves gitolite completely out of the authentication picture. In order to achieve these goals, gitolite expects the files and directories on the server to have sane permissions and ownerships. A decent POSIX file system, and a reasonable sshd config are also expected. Finally, a note on a couple of related items: Gitolite's stance on DOS (by authenticated users) is that if it is fixable, it will be fixed, but it is not a critical issue, as long as the log files cannot be tampered with. A DOS by un-authenticated users is completely out of scope. Gitolite cannot benefit from perl's taint mode, which was made for a different threat model. Gitolite's threat model implicitly trusts anyone who has shell access to the server, including all programs already on the server. It's only remote users that are considered a threat. Perl's taint mode treats anything outside the program itself as suspect. So, the rc file, the compiled config, the various internal files gitolite stores housekeeping information in, etc., would all need to be untainted. Since gitolite gets \"suspicious\" input only in one place, it's easier to check that rigorously enough rather than use taint mode. appendix A: accessing the documentation offline \uf0c1 The source code for the documentation is in https://github.com/sitaramc/gitolite-doc . Rendering it requires some work (TBD: details). For most purposes, it's simpler to clone https://github.com/sitaramc/sitaramc.github.com and use the 'gitolite' subdirectory within as your pre-rendered document base. Open it in a JS-enabled browser and you can even do searches.","title":"internals"},{"location":"internals.html#gitolite-internals","text":"This page is for people who may want to hack on core gitolite itself. This is not the page for people who merely want to customise their site (i.e., write their own VREFs, triggers, etc.); for that please start with the non-core page. This document assumes you're familiar with the material in the how does it work section in the \"overview\" document, as well as the concepts page. If you're not familiar with ssh, and in particular how programs like gitolite use ssh to simulate many users over one Unix user, the ssh page has useful info.","title":"gitolite internals"},{"location":"internals.html#what-is-core","text":"The core code consists mainly of src/gitolite , src/gitolite-shell , and all the perl modules in src/lib/Gitolite except src/lib/Gitolite/Triggers . That said, there are parts of non-core that, in a default (ssh) install, are used frequently enough to be important (for example if you are reviewing gitolite): commands in src/commands : access, git-config, info, mirror, option, owns, perms triggers in src/lib/Gitolite/Triggers : Mirroring.pm, Shell.pm triggers in src/triggers and src/triggers/post-compile : ssh-authkeys, ssh-authkeys-shell-users, update-git-configs, set-default-roles,","title":"what is \"core\""},{"location":"internals.html#entry-points","text":"","title":"entry points"},{"location":"internals.html#gitolite","text":"Most server-side operations that gitolite supports are invoked via the gitolite command. This includes initial setup and maintenance, some built-in commands (run 'gitolite -h' to see them), and finally the commands in src/commands (run 'gitolite help' to get a list).","title":"gitolite"},{"location":"internals.html#gitolite-shell","text":"All remote access is via the gitolite-shell command, (invoked, of course, by sshd). This includes both git operations (clone, fetch, push) as well as gitolite commands that have been enabled for remote invocation. For git operations, gitolite-shell does the initial access check (\"is the user even allowed to read/write this repo at all?\") and then calls git proper. Most of the code in this is housekeeping; the real action happens in one of the modules.","title":"gitolite-shell"},{"location":"internals.html#the-conf-module","text":"The Conf module and its child modules deal with the gitolite.conf file. Conf is where the 'compile' command lands. The parser for the conf file is also in this module; each \"recognised\" line is passed to appropriate functions in Conf::Store . Please note the parser is a very simple line-oriented parser using simple regexes; the DSL for the gitolite.conf file is intentionally very simple.","title":"the Conf module"},{"location":"internals.html#confexplode","text":"This deals with \"exploding\" the main gitolite.conf file into a single perl list with all 'include' files recursively expanded.","title":"Conf::Explode"},{"location":"internals.html#confsugar","text":"This calls Conf::Explode to get the full set of conf lines, then applies a series of \"syntactic sugar\" transformations to them. This keeps the main parser simple, while allowing the administrator to take some shortcuts in writing the rules. Some transformations are built-in and hardcoded, but a site can add their own site-local transformations if they like.","title":"Conf::Sugar"},{"location":"internals.html#confstore","text":"Conf::Store is one of the two workhorses of gitolite. It exports functions related to processing parsed lines and storing the parsed output for later use. It also exports functions that deal with creating and setting up new repos. The output of the compile step is essentially a set of perl hashes in Data::Dumper format. Rules that apply to more than one repo (i.e., the repo name was a regex pattern or a group name) go into a \"common\" output file ( ~/.gitolite/conf/gitolite.conf-compiled.pm ), while rules that apply to specific repos go into their own files ( ~/repositories/$REPONAME.git/gl-conf ). From a security perspective, dealing with 'subconf' (see delegation for details) happens in this module.","title":"Conf::Store"},{"location":"internals.html#confload","text":"Conf::Load is the other of the two workhorses of gitolite. The most important function it exports is access , which is used by gitolite-shell as well as by the update hook code to check for permissions. This code has a few optimisations, including very simple, localised, caching of parsed conf files when needed. TODO: How the access function does its thing will be written up in more detail as I find time, but TLDR: it calls rules which builds up a list of the rules that apply. Also see this until I manage to write it up in more detail. Other functions are git_config , which returns a list of config values specified in the conf file. Finally, this is where all the \"list-\" commands that 'gitolite -h' shows you (e.g., 'gitolite list-repos') land up.","title":"Conf::Load"},{"location":"internals.html#the-rc-module","text":"The rc file ( ~/.gitolite.rc ) is processed here. In addition, it also declares a bunch of constants (like the all-important regex patterns to validate user inputs of various kinds; all ending in _PATT ). The only complicated part of this is how the non_core_expand function takes the $non_core variable (currently 63 lines long!) and converts it into a set of arrays, one for each of the triggers types. You can see the effect of this logic by uncommenting something in the ENABLE list in the rc file, then running gitolite query-rc PRE_GIT , etc. (From a security point of view this is irrelevant. Any inputs it receives come from totally trusted sources -- either the gitolite source code or the rc file). Finally, the trigger function is also exported by this module. This is the function that actually runs all the programs tied to each trigger.","title":"the Rc module"},{"location":"internals.html#the-hooks-module","text":"This is where the code for the update hook (all repos) and the post-update hook (gitolite-admin repo only) can be found. The post-update hook code is fairly straightforward, consisting essentially of three shell commands. The update hook code has a lot more \"action\", since this is where all access checking for 'git push' goes. Even that would not be much if it weren't for VREFs, because then it's just one call to the access function (from the Conf::Load module). The only other thing of note in this module is how the \"attempted access\" is determined. Externally, we only know it's a \"push\" (i.e., a \"W\" in gitolite permission terms). We need to compare the old and the new SHAs in various ways to determine if it's a rewind, or a delete, or a create, etc., which may make a difference to the access. TODO: expand on VREF handling. For now please read vref to get the general idea of what it does, while I find time to write up the how .","title":"the Hooks module"},{"location":"internals.html#the-rest","text":"...is TBD (to be done). Briefly, the Test module is for testing, the Common module contains a whole bunch of common routines used all over -- many of them not gitolite specific at all, Cache is not to be used for now (sorry, bitrotted by now I think... I may need to take it out behind the woodshed one of these days).","title":"the rest..."},{"location":"internals.html#security-notes","text":"All security issues should be reported directly to me (sitaramc@gmail.com), and not to the mailing list. (In the following text, the words MUST, SHOULD, etc. are loosely as defined in RFC 2119). Gitolite MUST protect everything in ~/repositories from people who do not have command line access to the user hosting the service, and do not have \"push\" access rights to the gitolite-admin repository. Specifically, gitolite MUST prevent such users from doing anything except the following: perform git operations they are allowed to by gitolite.conf run gitolite commands that are enabled for remote use People who have command line access are considered to be \"in\"; nothing in gitolite attempts to protect from them (it's impossible anyway!) But someone who does not have command line access, but does have push access rights to the gitolite-admin repo (a \"gitolite admin\"), is a special case. Gitolite SHOULD prevent a gitolite admin from using that to pivot to executing arbitrary commands on the server. (This is why, for example, the gitolite-admin repo can't have arbitrary \"config\" lines.) However, many sites don't care about this distinction -- all their gitolite admins already have shell access. Thus, a violation of this is important and should be fixed, but not considered critical. Gitolite SHOULD try to make sure that the gitolite commands shipped with gitolite do not indirectly enable violation of the restrictions in the first bullet. The seriousness of failing this depends on the command in question (is the command enabled in the default setup, or even if it is not, is it a popular and widely used command, etc.) Gitolite SHOULD protect the local sysadmin from his own errors to some extent. For example, it should be possible to write a new \"command\" in shell, without worrying about shell meta-characters sneaking in and executing something; gitolite should prevent this from happening. As you probably knew already, gitolite does not do authentication; it only deals with authorisation. Still, gitolite MAY help the administrator to setup authentication (as the default setup does when used in ssh mode), but it is not mandatory. In particular, use in http-mode leaves gitolite completely out of the authentication picture. In order to achieve these goals, gitolite expects the files and directories on the server to have sane permissions and ownerships. A decent POSIX file system, and a reasonable sshd config are also expected. Finally, a note on a couple of related items: Gitolite's stance on DOS (by authenticated users) is that if it is fixable, it will be fixed, but it is not a critical issue, as long as the log files cannot be tampered with. A DOS by un-authenticated users is completely out of scope. Gitolite cannot benefit from perl's taint mode, which was made for a different threat model. Gitolite's threat model implicitly trusts anyone who has shell access to the server, including all programs already on the server. It's only remote users that are considered a threat. Perl's taint mode treats anything outside the program itself as suspect. So, the rc file, the compiled config, the various internal files gitolite stores housekeeping information in, etc., would all need to be untainted. Since gitolite gets \"suspicious\" input only in one place, it's easier to check that rigorously enough rather than use taint mode.","title":"security notes"},{"location":"internals.html#appendix-a-accessing-the-documentation-offline","text":"The source code for the documentation is in https://github.com/sitaramc/gitolite-doc . Rendering it requires some work (TBD: details). For most purposes, it's simpler to clone https://github.com/sitaramc/sitaramc.github.com and use the 'gitolite' subdirectory within as your pre-rendered document base. Open it in a JS-enabled browser and you can even do searches.","title":"appendix A: accessing the documentation offline"},{"location":"list-non-core.html","text":"non-core features shipped with gitolite \uf0c1 Important Notes on \"non-core\" features : The \"non-core\" gitolite page is the starting point for all information about ... non-core gitolite :) This page decribes many of the non-core features that come with gitolite. If a non-core feature is shipped with gitolite, but information about it is not found in this page, it can be found within the source code; please look there. Commands , however, have some extra magic, which is not available to the other types of non-core programs: Running the command with a single -h option (i.e., gitolite <command> -h or ssh git@host <command> -h ), will display a suitable message. Please report a bug to me if one of them doesn't. Running 'help', (either as gitolite help on the server, or ssh git@host help remotely), will give you a list of commands you are allowed to run. Non-core code is meant to be localised for your site if you don't like what the shipped version does. You can even maintain it within your gitolite-admin repo if you wish. commands \uf0c1 This is a list of commands that are available in gitolite, with brief descriptions and, if available, a link to more detailed information. Note that in most cases running it with -h will give you enough to work with. Also note that not all of these commands are available remotely. (The more common/important commands are in bold). access -- print or test access rights for repo/user config (v3.6.3+) -- allow limited remote use of 'git config' create -- create a wild repo creator -- print or test creator name for wild repo D -- lets you D elete wild repos created using the C permission :) desc -- show/set description for wild repo fork -- fork a repo on the server. This uses the -l option to git clone, so it runs really fast git-config -- print (or text existence of) 'config' values in the repo. (Don't forget that option foo.bar = 1 is merely syntactic sugar for config gitolite-options.foo.bar = 1 , so this can be used to query gitolite options also help -- see note 1 at the top of this page htpasswd -- sets your htpasswd info -- print git/gitolite version, list repos you have access to lock -- lock binary files for exclusive use (in combination with the 'lock' VREF) mirror -- manually mirror a repo to a copy motd (v3.6.1+) -- set/remove a message of the day, per repo or for the whole system option (v3.6.3+) -- allow repo owner to set options for a repo perms -- list or set permissions for wild repo push -- push a gitolite repo locally, bypassing gitolite readme (v3.6.1+) -- show, remove or set the README.html file for repo. rsync -- resumable downloads of git bundles (bundles are auto-created as needed) sshkeys-lint -- look for potential problems in ssh keys sskm -- self-service key management sudo -- allows an admin (i.e., someone who has push rights to the 'gitolite-admin' repo) to run any remote command as some other user. This is useful, for example, when a user claims he is unable to access a repo, and you need to check the 'info' output for him, etc. However, it does not work the other way, sorry! symbolic-ref -- run git symbolic-ref on a repo, remotely who-pushed -- determine who pushed a given commit writable -- disable/enable writes to specific repo (or all repos, if you're an admin) syntactic sugar \uf0c1 The following \"sugar\" programs are available: continuation-lines -- allow C-style backslash escaped continuation lines in the conf file keysubdirs-as-groups -- use the last component of the sub-directory name within keydir as a group name macros -- simple line-wise macro processor triggers \uf0c1 Here's a list of features that are enabled by triggers , or a combination of a trigger and something else, like a command. Alias -- allow repos to have aliases AutoCreate -- deny auto-create of wild repos on R or RW access bg -- allow long running post-compile/post-create jobs to be backgrounded CpuTime -- CPU and elapsed times for gitolite+git Mirroring -- mirroring all or some repos Motd (v3.6.1+) -- allows printing a message of the day to STDERR in ssh mode partial-copy -- simulated read control for branches (in combination with the partial-copy VREF) RefexExpr -- (in combination with VREF/refex-expr) logical expressions over refexes, like \"refex-1 and not refex-2\". (Example: changing file 'foo' but not on 'master' branch) renice -- renice the git operation RepoUmask -- repo-specific umask settings Shell -- see \"giving shell access to gitolite users\" in the ssh troubleshooting and tips page. (Internally enables the 'ssh-authkeys-shell-users' trigger also). ssh-authkeys-split -- split pubkey files with multiple keys into separate files with one pubkey each update-description-file -- if you want the 'description' file to be updated instead of the 'gitweb.description' config entry (e.g. cgit users) upstream -- manage local, gitolite-controlled, copies of read-only upstream repos In addition, the following post-compile trigger scripts are enabled by default, so are included here only for completeness and in case you wish to disable them: ssh-authkeys -- process keys in keydir/ and add/update appropriate lines to the authorized keys file update-git-configs -- run git config in each repo to add/update entries as needed update-git-daemon-access-list -- create/delete the 'git-daemon-export-ok' files in each repo as needed update-gitweb-access-list -- create the \"projects.list\" file that gitweb uses to determine what repos to show/not show VREFs \uf0c1 VREFs are a complex topic and have their own page with lots more details. However, here's a list of VREFs shipped with gitolite: COUNT -- restrict pushes by number of changed or new files pushed EMAIL-CHECK -- check if all new commits are authored by the person pushing lock -- lock binary files for exclusive use (in combination with the 'lock' command) MAX_NEWBIN_SIZE -- restrict by size of new binary files (helps catch people checking in random PDFs, JARs, WARs, etc.) NAME -- restrict pushes by dir/file name partial-copy -- simulated read control for branches (in combination with the partial-copy trigger) refex-expr -- (in combination with the refex-expr trigger) logical expressions over refexes, like \"refex-1 and not refex-2\". (Example: changing file 'foo' but not on 'master' branch) VOTES -- voting on commits a la gerrit details on some non-core programs \uf0c1 These non-core programs needed more detail than could be provided in the source code, but did not fit anywhere else neatly enough. partial-copy: selective read control for branches \uf0c1 Git (and therefore gitolite) cannot do selective read control -- allowing someone to read branch A but not branch B. It's the entire repo or nothing. Gerrit Code Review can do that, but that is because they have their own git (as well as their own sshd, and so on). If code review is part of your access control decision, you really should consider Gerrit anyway. The standard answer you get when you ask is \"use separate repos\" (where one contains all the branches, and one contains a subset of the branches). This is nice in theory but in practice, when people are potentially pushing to both repos, you need to figure out how to keep them in sync. Gitolite can now help you do this. Note that this is only for branches; you can't do this for files and directories. Here's how: enable 'partial-copy' in the ENABLE list in the rc file. for each repo \"foo\" which has secret branches that a certain set of developers (we'll use a group called @temp-emp as an example) are not supposed to see, do this: repo foo # rules should allow @temp-emp NO ACCESS repo foo-partialcopy-1 # first, a deny rule that allows no access to secret-branch - secret-branch = @all # # other rules; see notes below # - VREF/partial-copy = @all config gitolite.partialCopyOf = foo IMPORTANT NOTES : if you're using other VREFs, make sure this one is placed at the end, after all the others. remember that any change allowed to be made to the partial-copy repo will propagate to the main repo so make sure you use other rules to restrict pushes to other branches and tags as needed. And that should be it. Please test it and let me know if it doesn't work! WARNINGS: If you change the config to disallow something that used to be allowed, you should delete the partial repo on the server and then run gitolite compile; gitolite trigger POST_COMPILE to let it build again. Not tested with smart http; probably won't work. Also not tested with mirroring, or with wild card repos.","title":"list of non-core programs shipped with gitolite"},{"location":"list-non-core.html#non-core-features-shipped-with-gitolite","text":"Important Notes on \"non-core\" features : The \"non-core\" gitolite page is the starting point for all information about ... non-core gitolite :) This page decribes many of the non-core features that come with gitolite. If a non-core feature is shipped with gitolite, but information about it is not found in this page, it can be found within the source code; please look there. Commands , however, have some extra magic, which is not available to the other types of non-core programs: Running the command with a single -h option (i.e., gitolite <command> -h or ssh git@host <command> -h ), will display a suitable message. Please report a bug to me if one of them doesn't. Running 'help', (either as gitolite help on the server, or ssh git@host help remotely), will give you a list of commands you are allowed to run. Non-core code is meant to be localised for your site if you don't like what the shipped version does. You can even maintain it within your gitolite-admin repo if you wish.","title":"non-core features shipped with gitolite"},{"location":"list-non-core.html#commands","text":"This is a list of commands that are available in gitolite, with brief descriptions and, if available, a link to more detailed information. Note that in most cases running it with -h will give you enough to work with. Also note that not all of these commands are available remotely. (The more common/important commands are in bold). access -- print or test access rights for repo/user config (v3.6.3+) -- allow limited remote use of 'git config' create -- create a wild repo creator -- print or test creator name for wild repo D -- lets you D elete wild repos created using the C permission :) desc -- show/set description for wild repo fork -- fork a repo on the server. This uses the -l option to git clone, so it runs really fast git-config -- print (or text existence of) 'config' values in the repo. (Don't forget that option foo.bar = 1 is merely syntactic sugar for config gitolite-options.foo.bar = 1 , so this can be used to query gitolite options also help -- see note 1 at the top of this page htpasswd -- sets your htpasswd info -- print git/gitolite version, list repos you have access to lock -- lock binary files for exclusive use (in combination with the 'lock' VREF) mirror -- manually mirror a repo to a copy motd (v3.6.1+) -- set/remove a message of the day, per repo or for the whole system option (v3.6.3+) -- allow repo owner to set options for a repo perms -- list or set permissions for wild repo push -- push a gitolite repo locally, bypassing gitolite readme (v3.6.1+) -- show, remove or set the README.html file for repo. rsync -- resumable downloads of git bundles (bundles are auto-created as needed) sshkeys-lint -- look for potential problems in ssh keys sskm -- self-service key management sudo -- allows an admin (i.e., someone who has push rights to the 'gitolite-admin' repo) to run any remote command as some other user. This is useful, for example, when a user claims he is unable to access a repo, and you need to check the 'info' output for him, etc. However, it does not work the other way, sorry! symbolic-ref -- run git symbolic-ref on a repo, remotely who-pushed -- determine who pushed a given commit writable -- disable/enable writes to specific repo (or all repos, if you're an admin)","title":"commands"},{"location":"list-non-core.html#syntactic-sugar","text":"The following \"sugar\" programs are available: continuation-lines -- allow C-style backslash escaped continuation lines in the conf file keysubdirs-as-groups -- use the last component of the sub-directory name within keydir as a group name macros -- simple line-wise macro processor","title":"syntactic sugar"},{"location":"list-non-core.html#triggers","text":"Here's a list of features that are enabled by triggers , or a combination of a trigger and something else, like a command. Alias -- allow repos to have aliases AutoCreate -- deny auto-create of wild repos on R or RW access bg -- allow long running post-compile/post-create jobs to be backgrounded CpuTime -- CPU and elapsed times for gitolite+git Mirroring -- mirroring all or some repos Motd (v3.6.1+) -- allows printing a message of the day to STDERR in ssh mode partial-copy -- simulated read control for branches (in combination with the partial-copy VREF) RefexExpr -- (in combination with VREF/refex-expr) logical expressions over refexes, like \"refex-1 and not refex-2\". (Example: changing file 'foo' but not on 'master' branch) renice -- renice the git operation RepoUmask -- repo-specific umask settings Shell -- see \"giving shell access to gitolite users\" in the ssh troubleshooting and tips page. (Internally enables the 'ssh-authkeys-shell-users' trigger also). ssh-authkeys-split -- split pubkey files with multiple keys into separate files with one pubkey each update-description-file -- if you want the 'description' file to be updated instead of the 'gitweb.description' config entry (e.g. cgit users) upstream -- manage local, gitolite-controlled, copies of read-only upstream repos In addition, the following post-compile trigger scripts are enabled by default, so are included here only for completeness and in case you wish to disable them: ssh-authkeys -- process keys in keydir/ and add/update appropriate lines to the authorized keys file update-git-configs -- run git config in each repo to add/update entries as needed update-git-daemon-access-list -- create/delete the 'git-daemon-export-ok' files in each repo as needed update-gitweb-access-list -- create the \"projects.list\" file that gitweb uses to determine what repos to show/not show","title":"triggers"},{"location":"list-non-core.html#vrefs","text":"VREFs are a complex topic and have their own page with lots more details. However, here's a list of VREFs shipped with gitolite: COUNT -- restrict pushes by number of changed or new files pushed EMAIL-CHECK -- check if all new commits are authored by the person pushing lock -- lock binary files for exclusive use (in combination with the 'lock' command) MAX_NEWBIN_SIZE -- restrict by size of new binary files (helps catch people checking in random PDFs, JARs, WARs, etc.) NAME -- restrict pushes by dir/file name partial-copy -- simulated read control for branches (in combination with the partial-copy trigger) refex-expr -- (in combination with the refex-expr trigger) logical expressions over refexes, like \"refex-1 and not refex-2\". (Example: changing file 'foo' but not on 'master' branch) VOTES -- voting on commits a la gerrit","title":"VREFs"},{"location":"list-non-core.html#details-on-some-non-core-programs","text":"These non-core programs needed more detail than could be provided in the source code, but did not fit anywhere else neatly enough.","title":"details on some non-core programs"},{"location":"list-non-core.html#partial-copy-selective-read-control-for-branches","text":"Git (and therefore gitolite) cannot do selective read control -- allowing someone to read branch A but not branch B. It's the entire repo or nothing. Gerrit Code Review can do that, but that is because they have their own git (as well as their own sshd, and so on). If code review is part of your access control decision, you really should consider Gerrit anyway. The standard answer you get when you ask is \"use separate repos\" (where one contains all the branches, and one contains a subset of the branches). This is nice in theory but in practice, when people are potentially pushing to both repos, you need to figure out how to keep them in sync. Gitolite can now help you do this. Note that this is only for branches; you can't do this for files and directories. Here's how: enable 'partial-copy' in the ENABLE list in the rc file. for each repo \"foo\" which has secret branches that a certain set of developers (we'll use a group called @temp-emp as an example) are not supposed to see, do this: repo foo # rules should allow @temp-emp NO ACCESS repo foo-partialcopy-1 # first, a deny rule that allows no access to secret-branch - secret-branch = @all # # other rules; see notes below # - VREF/partial-copy = @all config gitolite.partialCopyOf = foo IMPORTANT NOTES : if you're using other VREFs, make sure this one is placed at the end, after all the others. remember that any change allowed to be made to the partial-copy repo will propagate to the main repo so make sure you use other rules to restrict pushes to other branches and tags as needed. And that should be it. Please test it and let me know if it doesn't work! WARNINGS: If you change the config to disallow something that used to be allowed, you should delete the partial repo on the server and then run gitolite compile; gitolite trigger POST_COMPILE to let it build again. Not tested with smart http; probably won't work. Also not tested with mirroring, or with wild card repos.","title":"partial-copy: selective read control for branches"},{"location":"locking.html","text":"locking binary files \uf0c1 Locking is useful to make sure that binary files (office docs, images, ...) don't get into a merge state. ( If you think it's not a big deal, you have never manually merged independent changes to an ODT or something! ) When git is used in a truly distributed fashion, locking is impossible. However, in most corporate setups, there is a single central server acting as the canonical source of truth and collaboration point for all developers. In this situation it should be possible to at least prevent commits from being pushed that contains changes to files locked by someone else. The two \"lock\" programs (one a command that a user uses, and one a VREF that the admin adds to a repo's access rules) together attempt to achieve this. Of course, locking by itself is not quite enough. You may still get into merge situations if you make changes in branches. For best results you should actually keep all the binary files in their own branch, separate from the ones containing source code. problem description \uf0c1 Our users are alice, bob, and carol. Our repo is foo. It has some \"odt\" files in the \"doc/\" directory. We want to make sure these odt files never get into a \"merge\" situation. admin/setup \uf0c1 First, someone with shell access to the server must add 'lock' to the ENABLE list in the rc file. Next, the gitolite.conf file should have something like this: repo foo ...other rules... - VREF/lock = @all However, see below for the difference between \"RW\" and \"RW+\" from the point of view of this feature and adjust permissions accordingly. user view \uf0c1 Here's a summary: Any user with \"W\" permissions to any branch in the repo can \"lock\" any file. Once locked, no other user can push changes to that file, in any branch , until it is unlocked. Any user with \"+\" permissions to any branch in the repo can \"break\" a lock held by someone else if needed. For best results, everyone on the team should: Switch to the branch containing the binary files when wanting to make a change. Run 'git pull' or eqvt, then lock the binary file(s) before editing them. Finish the editing task as quickly as possible, then commit, push, and unlock the file(s) so others are not needlessly blocked. Understand that breaking a lock require additional, (out of band) communication. It is upto the team's policies what that entails. detailed example \uf0c1 Alice declares her intent to work on \"d1.odt\": $ git pull $ ssh git@host lock -l foo doc/d1.odt Similarly Bob starts on \"d2.odt\" $ git pull $ ssh git@host lock -l foo doc/d2.odt Carol makes some changes to d2.odt ( without attempting to lock the file or checking to see if it is already locked ) and pushes: $ ooffice doc/d2.odt $ git add doc/d2.odt $ git commit -m 'added footnotes to d2 in klingon' $ git push <...normal push progress output...> remote: FATAL: W VREF/lock testing carol DENIED by VREF/lock remote: 'doc/d2.odt' locked by 'bob' remote: error: hook declined to update refs/heads/master To u2:testing ! [remote rejected] master -> master (hook declined) error: failed to push some refs to 'carol:foo' Carol backs out her changes, but saves them away for a \"manual merge\" later. git reset HEAD^ git stash save 'klingon changes to d2.odt saved for possible manual merge later' Note that this still represents wasted work in some sense, because Carol would have to somehow re-apply the same changes to the new version of d2.odt after pulling it down. This is because she did not lock the file before making changes on her local repo. Educating users in doing this is important if this scheme is to help you. She now decides to work on \"d1.odt\". However, she has learned her lesson and decides to follow the protocol described above: $ git pull $ ssh git@host lock -l foo doc/d1.odt FATAL: 'doc/d1.odt' locked by 'alice' since Sun May 27 17:59:59 2012 Oh damn; can't work on that either. Carol now decides to see what else there may be. Instead of checking each file to see if she can lock it, she starts with a list of what is already locked: $ ssh git@host lock -ls foo # locks held: alice doc/d1.odt (Sun May 27 17:59:59 2012) bob doc/d2.odt (Sun May 27 18:00:06 2012) # locks broken: Aha, looks like only d1 and d2 are locked. She picks d3.odt to work on. This time, she starts by locking it: $ ssh git@host lock -l foo doc/d3.odt $ ooffice doc/d3.odt <...etc...> Meanwhile, in a parallel universe where d3.odt doesn't exist, and Alice has gone on vacation while keeping d1.odt locked, Carol breaks the lock. Carol can do this because she has RW+ permissions for the repository itself. However, protocol in this team requires that she get email approval from the team lead before doing this and that Alice be in CC in those emails, so she does that first, and then she breaks the lock: $ git pull $ ssh git@host lock --break foo doc/d1.odt She then locks d1.odt for herself: $ ssh git@host lock -l foo doc/d1.odt When Alice comes back, she can tell who broke her lock and when: $ ssh git@host lock -ls foo # locks held: carol doc/d1.odt (Sun May 27 18:17:29 2012) bob doc/d2.odt (Sun May 27 18:00:06 2012) # locks broken: carol doc/d1.odt (Sun May 27 18:17:03 2012) (locked by alice at Sun May 27 17:59:59 2012)","title":"locking binary files"},{"location":"locking.html#locking-binary-files","text":"Locking is useful to make sure that binary files (office docs, images, ...) don't get into a merge state. ( If you think it's not a big deal, you have never manually merged independent changes to an ODT or something! ) When git is used in a truly distributed fashion, locking is impossible. However, in most corporate setups, there is a single central server acting as the canonical source of truth and collaboration point for all developers. In this situation it should be possible to at least prevent commits from being pushed that contains changes to files locked by someone else. The two \"lock\" programs (one a command that a user uses, and one a VREF that the admin adds to a repo's access rules) together attempt to achieve this. Of course, locking by itself is not quite enough. You may still get into merge situations if you make changes in branches. For best results you should actually keep all the binary files in their own branch, separate from the ones containing source code.","title":"locking binary files"},{"location":"locking.html#problem-description","text":"Our users are alice, bob, and carol. Our repo is foo. It has some \"odt\" files in the \"doc/\" directory. We want to make sure these odt files never get into a \"merge\" situation.","title":"problem description"},{"location":"locking.html#adminsetup","text":"First, someone with shell access to the server must add 'lock' to the ENABLE list in the rc file. Next, the gitolite.conf file should have something like this: repo foo ...other rules... - VREF/lock = @all However, see below for the difference between \"RW\" and \"RW+\" from the point of view of this feature and adjust permissions accordingly.","title":"admin/setup"},{"location":"locking.html#user-view","text":"Here's a summary: Any user with \"W\" permissions to any branch in the repo can \"lock\" any file. Once locked, no other user can push changes to that file, in any branch , until it is unlocked. Any user with \"+\" permissions to any branch in the repo can \"break\" a lock held by someone else if needed. For best results, everyone on the team should: Switch to the branch containing the binary files when wanting to make a change. Run 'git pull' or eqvt, then lock the binary file(s) before editing them. Finish the editing task as quickly as possible, then commit, push, and unlock the file(s) so others are not needlessly blocked. Understand that breaking a lock require additional, (out of band) communication. It is upto the team's policies what that entails.","title":"user view"},{"location":"locking.html#detailed-example","text":"Alice declares her intent to work on \"d1.odt\": $ git pull $ ssh git@host lock -l foo doc/d1.odt Similarly Bob starts on \"d2.odt\" $ git pull $ ssh git@host lock -l foo doc/d2.odt Carol makes some changes to d2.odt ( without attempting to lock the file or checking to see if it is already locked ) and pushes: $ ooffice doc/d2.odt $ git add doc/d2.odt $ git commit -m 'added footnotes to d2 in klingon' $ git push <...normal push progress output...> remote: FATAL: W VREF/lock testing carol DENIED by VREF/lock remote: 'doc/d2.odt' locked by 'bob' remote: error: hook declined to update refs/heads/master To u2:testing ! [remote rejected] master -> master (hook declined) error: failed to push some refs to 'carol:foo' Carol backs out her changes, but saves them away for a \"manual merge\" later. git reset HEAD^ git stash save 'klingon changes to d2.odt saved for possible manual merge later' Note that this still represents wasted work in some sense, because Carol would have to somehow re-apply the same changes to the new version of d2.odt after pulling it down. This is because she did not lock the file before making changes on her local repo. Educating users in doing this is important if this scheme is to help you. She now decides to work on \"d1.odt\". However, she has learned her lesson and decides to follow the protocol described above: $ git pull $ ssh git@host lock -l foo doc/d1.odt FATAL: 'doc/d1.odt' locked by 'alice' since Sun May 27 17:59:59 2012 Oh damn; can't work on that either. Carol now decides to see what else there may be. Instead of checking each file to see if she can lock it, she starts with a list of what is already locked: $ ssh git@host lock -ls foo # locks held: alice doc/d1.odt (Sun May 27 17:59:59 2012) bob doc/d2.odt (Sun May 27 18:00:06 2012) # locks broken: Aha, looks like only d1 and d2 are locked. She picks d3.odt to work on. This time, she starts by locking it: $ ssh git@host lock -l foo doc/d3.odt $ ooffice doc/d3.odt <...etc...> Meanwhile, in a parallel universe where d3.odt doesn't exist, and Alice has gone on vacation while keeping d1.odt locked, Carol breaks the lock. Carol can do this because she has RW+ permissions for the repository itself. However, protocol in this team requires that she get email approval from the team lead before doing this and that Alice be in CC in those emails, so she does that first, and then she breaks the lock: $ git pull $ ssh git@host lock --break foo doc/d1.odt She then locks d1.odt for herself: $ ssh git@host lock -l foo doc/d1.odt When Alice comes back, she can tell who broke her lock and when: $ ssh git@host lock -ls foo # locks held: carol doc/d1.odt (Sun May 27 18:17:29 2012) bob doc/d2.odt (Sun May 27 18:00:06 2012) # locks broken: carol doc/d1.odt (Sun May 27 18:17:03 2012) (locked by alice at Sun May 27 17:59:59 2012)","title":"detailed example"},{"location":"migr.html","text":"migrating from gitolite v2 \uf0c1 Gitolite v3 came out in April 2012. Until now, my policy was that I would not support it except for critical issues, but I think by now (I am writing this in Feb 2017), it's time to cut it completely. As such, migration is also not supported. Please perform a clean install of the latest gitolite and bring your existing repos into this new installation. Details below. The old, detailed, migration document is still available in the archive directory of the gitolite-doc repo, if you really need it, but you're on your own. After five years, it makes little sense to maintain all that in the active document hierarchy. Despite all that, this document does list some of the more important issues, mainly those that cause a significant change in behaviour. step 1: backups \uf0c1 take a backup of all ~/repositories from the v2 server take an extra backup, in the form of a normal git clone , of the gitolite-admin repository take a backup of ~/.gitolite.rc and keep it handy ( optional but suggested ) take a backup of ~/.gitolite and ~/.ssh step 2: install gitolite \uf0c1 Important: If you are reusing the same hosting user on the same server, for the new setup, you will need to clean out the old one as much as you can so its artefacts don't interfere with the new installation. This means all the files and directories you backed up above, including the optional ones. To install, use one or more of the links in the \"install\" section in the navigation bar at the top. Important: Do NOT change the gitolite.conf from the minimal one that a fresh install creates at this stage. Smoke test the installation by cloning the testing repo and pushing some minor change to it. step 3: add existing repos \uf0c1 Once the install is done, follow the instructions here to bring in existing repos. At the point where it talks about adding repos to the gitolite.conf file, you can copy relevant bits from your old gitolite-admin repo. step 4: identify any remaining changes needed \uf0c1 If you're using any of the following features in your old (v2) setup, please make the appropriate changes as indicated. NAME rules \uf0c1 NAME/ rules must be changed to VREF/NAME/ . Also, fallthru on all VREFs is \"success\" now, so any NAME/ rules you have MUST change the rule list in some way to maintain the same restrictions. The simplest is to add the following line to the end of each repo's rule list: - VREF/NAME/ = @all subconf command \uf0c1 (This is also affected by the previous issue, 'NAME rules'; please read that as well). If you're using delegation in your admin conf setup, please add the following lines to the end of the gitolite-admin rules in your conf/gitolite.conf file: repo gitolite-admin - VREF/NAME/ = @all subconf \"fragments/*.conf\" The first part compensates for fallthru now being a success when processing VREF rules (NAME rules are just one specific VREF). Although, ideally , you should change your rule list so that you no longer require that line. The second part explicitly says when and where to include the subconf files. (Before subconf was invented, this used to happen implicitly at the end of the main conf file, and was hardcoded to that specific glob.) mirroring \uf0c1 There are several important differences in mirroring; if you're using mirroring please start from a clean slate on all copies , using the v3 documentation on mirroring . If you're not willing to do that, you may be able to use the older, more detailed, documentation here to manage the migration. However, I cannot support that (mainly due to lack of time). rc file settings \uf0c1 Many rc file settings have been dropped. You should be able to get by without most of them, but some of them cause a significant change to behaviour: GL_ALL_INCLUDES_SPECIAL : @all always includes gitweb and daemon now. Use deny-rules if you want to say R = @all but not have the repo(s) be visible to gitweb or daemon. GL_NO_DAEMON_NO_GITWEB : the default will clobber your projects.list file and git-daemon-export-ok files. Comment out the 'daemon' and 'gitweb' lines in the ENABLE list in the rc file. Gitweb and daemon can now be separately disabled, instead of both being tied to the same setting. GL_NO_SETUP_AUTHKEYS : default will clobber your authkeys file. Comment out all the line(s) that call ssh-authkeys in the rc file. ADMIN_POST_UPDATE_CHAINS_TO and UPDATE_CHAINS_TO : For the former, add your script to the POST_COMPILE trigger chain. For the latter, use a vref . Don't forget to add a rule that references the new VREF! wild repos \uf0c1 gl-creater files: these files need to be renamed to gl-creator (the correct spelling at last, hooray!). Suggested command sequence: cd $HOME /repositories find . -type d -name \" *.git \" -prune | while read r do mv $r /gl-creater $r /gl-creator done 2 > /dev/null gl-perms files: setting perms of R and RW will no longer work; you have to say READERS and WRITERS now. Suggested command: find ` gitolite query-rc GL_REPO_BASE ` -name gl-perms | xargs perl -pi -e ' s/\\bR\\b/READERS/;s/\\bRW\\b/WRITERS/ '","title":"migrating from v2"},{"location":"migr.html#migrating-from-gitolite-v2","text":"Gitolite v3 came out in April 2012. Until now, my policy was that I would not support it except for critical issues, but I think by now (I am writing this in Feb 2017), it's time to cut it completely. As such, migration is also not supported. Please perform a clean install of the latest gitolite and bring your existing repos into this new installation. Details below. The old, detailed, migration document is still available in the archive directory of the gitolite-doc repo, if you really need it, but you're on your own. After five years, it makes little sense to maintain all that in the active document hierarchy. Despite all that, this document does list some of the more important issues, mainly those that cause a significant change in behaviour.","title":"migrating from gitolite v2"},{"location":"migr.html#step-1-backups","text":"take a backup of all ~/repositories from the v2 server take an extra backup, in the form of a normal git clone , of the gitolite-admin repository take a backup of ~/.gitolite.rc and keep it handy ( optional but suggested ) take a backup of ~/.gitolite and ~/.ssh","title":"step 1: backups"},{"location":"migr.html#step-2-install-gitolite","text":"Important: If you are reusing the same hosting user on the same server, for the new setup, you will need to clean out the old one as much as you can so its artefacts don't interfere with the new installation. This means all the files and directories you backed up above, including the optional ones. To install, use one or more of the links in the \"install\" section in the navigation bar at the top. Important: Do NOT change the gitolite.conf from the minimal one that a fresh install creates at this stage. Smoke test the installation by cloning the testing repo and pushing some minor change to it.","title":"step 2: install gitolite"},{"location":"migr.html#step-3-add-existing-repos","text":"Once the install is done, follow the instructions here to bring in existing repos. At the point where it talks about adding repos to the gitolite.conf file, you can copy relevant bits from your old gitolite-admin repo.","title":"step 3: add existing repos"},{"location":"migr.html#step-4-identify-any-remaining-changes-needed","text":"If you're using any of the following features in your old (v2) setup, please make the appropriate changes as indicated.","title":"step 4: identify any remaining changes needed"},{"location":"migr.html#name-rules","text":"NAME/ rules must be changed to VREF/NAME/ . Also, fallthru on all VREFs is \"success\" now, so any NAME/ rules you have MUST change the rule list in some way to maintain the same restrictions. The simplest is to add the following line to the end of each repo's rule list: - VREF/NAME/ = @all","title":"NAME rules"},{"location":"migr.html#subconf-command","text":"(This is also affected by the previous issue, 'NAME rules'; please read that as well). If you're using delegation in your admin conf setup, please add the following lines to the end of the gitolite-admin rules in your conf/gitolite.conf file: repo gitolite-admin - VREF/NAME/ = @all subconf \"fragments/*.conf\" The first part compensates for fallthru now being a success when processing VREF rules (NAME rules are just one specific VREF). Although, ideally , you should change your rule list so that you no longer require that line. The second part explicitly says when and where to include the subconf files. (Before subconf was invented, this used to happen implicitly at the end of the main conf file, and was hardcoded to that specific glob.)","title":"subconf command"},{"location":"migr.html#mirroring","text":"There are several important differences in mirroring; if you're using mirroring please start from a clean slate on all copies , using the v3 documentation on mirroring . If you're not willing to do that, you may be able to use the older, more detailed, documentation here to manage the migration. However, I cannot support that (mainly due to lack of time).","title":"mirroring"},{"location":"migr.html#rc-file-settings","text":"Many rc file settings have been dropped. You should be able to get by without most of them, but some of them cause a significant change to behaviour: GL_ALL_INCLUDES_SPECIAL : @all always includes gitweb and daemon now. Use deny-rules if you want to say R = @all but not have the repo(s) be visible to gitweb or daemon. GL_NO_DAEMON_NO_GITWEB : the default will clobber your projects.list file and git-daemon-export-ok files. Comment out the 'daemon' and 'gitweb' lines in the ENABLE list in the rc file. Gitweb and daemon can now be separately disabled, instead of both being tied to the same setting. GL_NO_SETUP_AUTHKEYS : default will clobber your authkeys file. Comment out all the line(s) that call ssh-authkeys in the rc file. ADMIN_POST_UPDATE_CHAINS_TO and UPDATE_CHAINS_TO : For the former, add your script to the POST_COMPILE trigger chain. For the latter, use a vref . Don't forget to add a rule that references the new VREF!","title":"rc file settings"},{"location":"migr.html#wild-repos","text":"gl-creater files: these files need to be renamed to gl-creator (the correct spelling at last, hooray!). Suggested command sequence: cd $HOME /repositories find . -type d -name \" *.git \" -prune | while read r do mv $r /gl-creater $r /gl-creator done 2 > /dev/null gl-perms files: setting perms of R and RW will no longer work; you have to say READERS and WRITERS now. Suggested command: find ` gitolite query-rc GL_REPO_BASE ` -name gl-perms | xargs perl -pi -e ' s/\\bR\\b/READERS/;s/\\bRW\\b/WRITERS/ '","title":"wild repos"},{"location":"mirroring.html","text":"mirroring using gitolite \uf0c1 v2 mirroring users: There are several important differences in mirroring; it's best to start from a clean slate on all copies , using this documentation. If you're not willing to do that, you may be able to use the older, more detailed, documentation here to manage the migration. However, I cannot support that (mainly due to lack of time). terminology change NOTE This documentation is current with the just -released (as of 2pm UTC on 2020-08-04), v3.6.12. For most people, until you upgrade, this documentation will have some terminology differences. quick intro \uf0c1 Mirroring is simple: you have one \"master\" server and one or more \"copy\" servers. The copies get updates only from the master; to the rest of the world they are at best read-only. In the following picture, each box (A, B, C, ...) is a repo. The master server for a repo is colored red, copies are green. Users only push to a master server (red), and the master server then does a git push --mirror to the copies. The arrows show this mirror push. Here's a more complete description of what gitolite can do: Different masters and sets of copies for different repos. This lets you do things like: Use the server closest to most of its developers as the master for that repo. Mirror a repo to only some of the servers. Have repos that are purely local to a server (not mirrored at all). Push to a copy on demand or via cron (helps deal with bandwidth or connectivity constraints). All this is possible whether or not the gitolite-admin repo is mirrored -- that is, all servers have the exact same gitolite-admin repo or not. Pushes to a copy can be transparently forwarded to the real master. Your developers need not worry about where a repo's master is -- they just write to their local mirror for all repos, even if their local mirror is only a copy for some. caveats \uf0c1 Mirroring by itself will never create a repo on a copy; it has to exist and be prepared to receive updates from the master. The simplest way to ensure your repos exist on the copies also is to mirror the special gitolite-admin repo as well, and this is what most sites do. There is limited support for auto-creating wild card repos and sending 'perms' info across, with the following caveats at present. (Some of this text won't make sense unless you know what those features are). WARNING : it does NOT make sense to mirror wild repos in setups where the authentication data is not the same (i.e., where \"alice\" on the master and \"alice\" on a copy maybe totally different people) . This has only been minimally tested. For example, complex setups or asymmetric configs on master and copy, etc. have NOT been tested. Permission changes will only propagate on the next 'git push'. Of course, if you know the name of the copy server, you can run ssh git@host mirror push copy-server-name repo-name Using 'perms' on a copy is allowed but will neither propagate nor persist. They will be overwritten by whatever perms the master has (even if it is an empty set) on the next 'git push'. As with lots of extra features in gitolite, smart http support is not on my radar. Don't ask. Please test it out and let me know if something surprising happens. Be aware that I have been known to claim bugs are features if I don't have time to fix them immediately :-) Mirroring is only for git repos. Ancillary files like gl-creator and gl-perms in the repo directory are not mirrored; you must do that separately. Files in the admin directory (like log files) are also not mirrored. If you ever do a bypass push , mirroring will not work. Mirroring checks also will not work -- for example, you can push to a copy, which is not usually a good idea. So don't bypass gitolite if the repo is mirrored! From v3.5.3 on, gitolite uses an asynchronous push to the copies, so that the main push returns immediately, without waiting for the copy pushes to complete. Keep this in mind if you're writing scripts that do a push, and then read one of the copies immediately -- you will need to add a few seconds of sleep in your script. setting up mirroring \uf0c1 This is in two parts: the initial setup and the rc file, followed by the conf file settings and syntax. the initial setup and the rc file \uf0c1 For each server: Install gitolite normally. Make clones of the server's 'gitolite-admin' repo on your workstation so you can admin them all from one place. Give the server a short, simple, \"hostname\" and set the HOSTNAME in the rc file (i.e., ~/.gitolite.rc on the server) to this name, for example 'mars'. Note: this has nothing to do with the hostname of the server in networking or DNS terms, or in OS terms. This is internal to gitolite . Run ssh-keygen if needed and get an ssh key pair for the server. Copy the public key to a common area (accessible to your workstation for copying) and name it after the host, but with 'server-' prefixed. For example, the pubkey for server 'mars' must be stored as 'server-mars.pub'. Copy all these pubkeys (i.e., one from each server) to all the admin repo clones on your workstation and add them as usual. This is an O(N^2) operation ;-) Don't forget to push the changes! You may have guessed that the prefix 'server-' is special, and distinguishes a human user from a mirroring peer. Create \"host\" aliases to refer to all other machines. See here for what/how. The host alias for a host (in all other machines' ~/.ssh/config files) MUST be the same as the HOSTNAME in the referred host's ~/.gitolite.rc . Gitolite mirroring requires this consistency in naming; things will NOT work otherwise. Normally you should be able to build one common file and append it to all the servers' ~/.ssh/config files. The following MUST work for each pair of servers that must talk to each other: # on server mars ssh phobos info # the response MUST start with \"hello, server-mars...\" Note the exact syntax used; variations like \"ssh git@phobos.example.com info\" are NOT sufficient. That is why you need the ssh host aliases. Check this command from everywhere to everywhere else , and make sure you get expected results. Do NOT proceed otherwise. Setup the gitolite.conf file on all the servers. If the copies are to be exact copies of the master, you need to do the complete configuration only on the master; the copies can have just this because on the first push to the master it will update all the copies anyway: repo gitolite-admin RW+ = some-local-admin # possibly other rules option mirror.master = mars option mirror.copies = phobos When that is all done and tested, enable mirroring by going through the rc file and uncommenting all the lines mentioning Mirroring . If you wish to allow your users to run the mirror command remotely (usually not required), you need to enable it just like any other command that is not enabled by default; see gitolite commands for how. conf file settings and syntax \uf0c1 Mirroring is defined by the following options . You can have different settings for different repos, and of course some repos may not have any mirror options at all -- they are then purely local. repo foo ...access rules... option mirror.master = mars option mirror.copies = phobos deimos option mirror.redirectOK = all The first line is easy, since a repo can have only one master. The second is a space separated list of hosts that are all copies. You can have several copy lists, as long as the config key starts with 'mirror.copies' and is unique. For example. option mirror.copies-1 = phobos deimos option mirror.copies-2 = io europa option mirror.copies-3 = ganymede callisto Do not repeat a key; then only the last line for that key will be effective. (v3.6+) preventing automatic sync \uf0c1 Sometimes you don't want a repo to be mirrored automatically (as soon as someone pushes to the master) to all the copies. For whatever reasons, you have some copies for whom you would like to trigger the sync later (and you don't mind the fact that those copies are out of sync until then). To make that happen, use option lines like this instead of those shown above: option mirror.copies.nosync-1 = phobos deimos Except for the addition of a .nosync just after copies , all the other rules are the same as before. (v3.6.1+) mirroring failures \uf0c1 Since mirror pushes happen asynchronously (i.e, the user who originally pushed does not have to wait for the mirrors to be synced), any mirror push failures are not immediately visible to a human being, although you will find them if you look in gitolite's log files. Note: since only a successful push can clear the error status, it follows that if a mirror push failed due to an invalid hostname, that status file will need to be manually deleted from the server. Look in the bare repo directory on the server, for one or more files whose names start with 'gl-copy' and delete the appropriate one. Therefore, when the output of the mirror push to some copy contains the word \"fatal\", gitolite saves the output. This saved output is printed to STDERR when any user attempts to clone/fetch/push the repo on the master server for that repo. The hope is that someone will alert an admin to look at the problem. This will continue to happen until the error condition is cleared (i.e., a successful mirror push happens to that specific copy). If you don't want these unexpected reports confusing users (or programs!), simply create a new rc variable called HUSH_MIRROR_STATUS and set it to 1. (If you're not sure where in the rc file this should go, I suggest putting it right after the HOSTNAME variable). You can see the mirror status of any repo using the 'mirror status' command; the command line help for the mirror command ('gitolite mirror -h' or 'ssh git@host mirror -h') has details. manually synchronising a copy repo \uf0c1 You can use the gitolite mirror push command on a master to manually synchronise any of its copies. Try it with -h to get usage info. Tip: if you want to do this to all the copies, try this: for s in `gitolite mirror list copies reponame` do gitolite mirror push $s reponame done This command can also be run remotely; run ssh git@host mirror -h for details. Note: if your version of the mirror command does not support 'list copies', use gitolite git-config -r reponame mirror.copies | cut -f3 instead. redirected pushes \uf0c1 Please read carefully; there are security implications if you enable this for mirrors NOT under your control . Normally, a master, (and only a master), pushes to a copy, and the copies are \"read-only\" to the users. Gitolite allows a copy to receive pushes from a user and transparently redirect them to the master . This simplifies things for users in complex setups, letting them use their local mirror for both fetch and push access to all repos. Note: Just to be clear, the actual push will still happen only on the master, which needs to be up (the redirection is at the ssh level). It's main use is in geographically distributed setups, where users are encouraged to use a nearer node as their \"fetch\" remote, but, without this feature, they'd have to use the actual master node as the \"push\" remote. This allows users to use the same (nearby) node as the \"push\" remote also. It is also useful if the master dies, and the administrator redesignates some other node as the master. In that situation, only users who had the original master as a remote need to update their remote URLs. The syntax for enabling this is one of these: option mirror.redirectOK = all option mirror.redirectOK = phobos deimos The first syntax trusts all valid copies to redirect user pushes, while the second one trusts only some copies. IMPORTANT NOTES This only works for ssh-based setups; you cannot use this feature in http mode. Authentication happens on the copy, but authorisation is on the master. The master is trusting the copy to authenticate the user correctly, even though the actual push is going to the master. This means that user alice on the copy must be guaranteed to be the same as user alice on the master. The part of the authorisation that happens before passing control to git-receive-pack (see access rules ) will happen on the copy as well. You cannot redirect gitolite commands (like perms, etc). appendix A: HOSTNAME substitution \uf0c1 Wherever gitolite sees the word %HOSTNAME , it will replace it with the HOSTNAME supplied in the rc file, if one was supplied. This lets you maintain configurations for all servers in one repo, yet have them act differently on different servers, by saying something like: include \"%HOSTNAME/*.conf\" (See include for more on the 'include' command). You can use it in other places also, for example: RW+ VREF/ NAME/ subs/%HOST NAME/ = @%HOSTNAME-admins (you still have to define @mars-admins, @phobos-admins, etc., but the actual VREF is now one line instead of one for each server!) appendix B: efficiency versus paranoia \uf0c1 If you're paranoid enough to use mirrors, you should be paranoid enough to set this on each server, despite the possible CPU overhead: git config --global receive.fsckObjects true appendix C: moving the admin repo to a different master \uf0c1 Moving only some repos (other than the gitolite-admin repo) to a different master is easy. Just make the change in the gitolite.conf file, add, commit, and push. Even for the gitolite-admin repo, if the current master is ok, it's the same thing; just make the change and push to the current master . Subsequent pushes will go to the new master, of course. But if the current master is already dead, there's a bit of a catch-22. You can't push to the master because it is dead, and you can't push to any copy because they won't accept updates from anywhere but the server they think is the master. Here's how to resolve this: On each copy: Edit ~/.gitolite/conf/gitolite.conf to change the master and copy options for the gitolite-admin repo. Run gitolite setup . Now clone the admin repo from the new master to your workstation, change the options for the rest of the repos (if needed), then add/commit/push. And that should be all you need to do. appendix D: fixing a broken copy \uf0c1 Let's say you had option mirror.master = mars option mirror.copies = phobos deimos and you then accidentally removed phobos and pushed. You quickly realise your error and put the line back, then push again, only to realise that phobos is now unreachable. It took the previous push to heart and updated its internal state accordingly, and any subsequent attempts to touch the gitolite-admin repo on phobos results in the message: FATAL: phobos: 'gitolite-admin' is mirrored but not here This is basically saying, \"yes I see that repo in the config, but I (phobos) am neither the master nor one of the copies for it, so please don't ask me about it!\". You're basically locked out of phobos now. The solution is this: log on to phobos' gitolite shell account edit ~/.gitolite/conf/gitolite.conf to fix the mirroring options for the gitolite-admin repo. run gitolite setup . That should do it.","title":"mirroring"},{"location":"mirroring.html#mirroring-using-gitolite","text":"v2 mirroring users: There are several important differences in mirroring; it's best to start from a clean slate on all copies , using this documentation. If you're not willing to do that, you may be able to use the older, more detailed, documentation here to manage the migration. However, I cannot support that (mainly due to lack of time). terminology change NOTE This documentation is current with the just -released (as of 2pm UTC on 2020-08-04), v3.6.12. For most people, until you upgrade, this documentation will have some terminology differences.","title":"mirroring using gitolite"},{"location":"mirroring.html#quick-intro","text":"Mirroring is simple: you have one \"master\" server and one or more \"copy\" servers. The copies get updates only from the master; to the rest of the world they are at best read-only. In the following picture, each box (A, B, C, ...) is a repo. The master server for a repo is colored red, copies are green. Users only push to a master server (red), and the master server then does a git push --mirror to the copies. The arrows show this mirror push. Here's a more complete description of what gitolite can do: Different masters and sets of copies for different repos. This lets you do things like: Use the server closest to most of its developers as the master for that repo. Mirror a repo to only some of the servers. Have repos that are purely local to a server (not mirrored at all). Push to a copy on demand or via cron (helps deal with bandwidth or connectivity constraints). All this is possible whether or not the gitolite-admin repo is mirrored -- that is, all servers have the exact same gitolite-admin repo or not. Pushes to a copy can be transparently forwarded to the real master. Your developers need not worry about where a repo's master is -- they just write to their local mirror for all repos, even if their local mirror is only a copy for some.","title":"quick intro"},{"location":"mirroring.html#caveats","text":"Mirroring by itself will never create a repo on a copy; it has to exist and be prepared to receive updates from the master. The simplest way to ensure your repos exist on the copies also is to mirror the special gitolite-admin repo as well, and this is what most sites do. There is limited support for auto-creating wild card repos and sending 'perms' info across, with the following caveats at present. (Some of this text won't make sense unless you know what those features are). WARNING : it does NOT make sense to mirror wild repos in setups where the authentication data is not the same (i.e., where \"alice\" on the master and \"alice\" on a copy maybe totally different people) . This has only been minimally tested. For example, complex setups or asymmetric configs on master and copy, etc. have NOT been tested. Permission changes will only propagate on the next 'git push'. Of course, if you know the name of the copy server, you can run ssh git@host mirror push copy-server-name repo-name Using 'perms' on a copy is allowed but will neither propagate nor persist. They will be overwritten by whatever perms the master has (even if it is an empty set) on the next 'git push'. As with lots of extra features in gitolite, smart http support is not on my radar. Don't ask. Please test it out and let me know if something surprising happens. Be aware that I have been known to claim bugs are features if I don't have time to fix them immediately :-) Mirroring is only for git repos. Ancillary files like gl-creator and gl-perms in the repo directory are not mirrored; you must do that separately. Files in the admin directory (like log files) are also not mirrored. If you ever do a bypass push , mirroring will not work. Mirroring checks also will not work -- for example, you can push to a copy, which is not usually a good idea. So don't bypass gitolite if the repo is mirrored! From v3.5.3 on, gitolite uses an asynchronous push to the copies, so that the main push returns immediately, without waiting for the copy pushes to complete. Keep this in mind if you're writing scripts that do a push, and then read one of the copies immediately -- you will need to add a few seconds of sleep in your script.","title":"caveats"},{"location":"mirroring.html#setting-up-mirroring","text":"This is in two parts: the initial setup and the rc file, followed by the conf file settings and syntax.","title":"setting up mirroring"},{"location":"mirroring.html#the-initial-setup-and-the-rc-file","text":"For each server: Install gitolite normally. Make clones of the server's 'gitolite-admin' repo on your workstation so you can admin them all from one place. Give the server a short, simple, \"hostname\" and set the HOSTNAME in the rc file (i.e., ~/.gitolite.rc on the server) to this name, for example 'mars'. Note: this has nothing to do with the hostname of the server in networking or DNS terms, or in OS terms. This is internal to gitolite . Run ssh-keygen if needed and get an ssh key pair for the server. Copy the public key to a common area (accessible to your workstation for copying) and name it after the host, but with 'server-' prefixed. For example, the pubkey for server 'mars' must be stored as 'server-mars.pub'. Copy all these pubkeys (i.e., one from each server) to all the admin repo clones on your workstation and add them as usual. This is an O(N^2) operation ;-) Don't forget to push the changes! You may have guessed that the prefix 'server-' is special, and distinguishes a human user from a mirroring peer. Create \"host\" aliases to refer to all other machines. See here for what/how. The host alias for a host (in all other machines' ~/.ssh/config files) MUST be the same as the HOSTNAME in the referred host's ~/.gitolite.rc . Gitolite mirroring requires this consistency in naming; things will NOT work otherwise. Normally you should be able to build one common file and append it to all the servers' ~/.ssh/config files. The following MUST work for each pair of servers that must talk to each other: # on server mars ssh phobos info # the response MUST start with \"hello, server-mars...\" Note the exact syntax used; variations like \"ssh git@phobos.example.com info\" are NOT sufficient. That is why you need the ssh host aliases. Check this command from everywhere to everywhere else , and make sure you get expected results. Do NOT proceed otherwise. Setup the gitolite.conf file on all the servers. If the copies are to be exact copies of the master, you need to do the complete configuration only on the master; the copies can have just this because on the first push to the master it will update all the copies anyway: repo gitolite-admin RW+ = some-local-admin # possibly other rules option mirror.master = mars option mirror.copies = phobos When that is all done and tested, enable mirroring by going through the rc file and uncommenting all the lines mentioning Mirroring . If you wish to allow your users to run the mirror command remotely (usually not required), you need to enable it just like any other command that is not enabled by default; see gitolite commands for how.","title":"the initial setup and the rc file"},{"location":"mirroring.html#conf-file-settings-and-syntax","text":"Mirroring is defined by the following options . You can have different settings for different repos, and of course some repos may not have any mirror options at all -- they are then purely local. repo foo ...access rules... option mirror.master = mars option mirror.copies = phobos deimos option mirror.redirectOK = all The first line is easy, since a repo can have only one master. The second is a space separated list of hosts that are all copies. You can have several copy lists, as long as the config key starts with 'mirror.copies' and is unique. For example. option mirror.copies-1 = phobos deimos option mirror.copies-2 = io europa option mirror.copies-3 = ganymede callisto Do not repeat a key; then only the last line for that key will be effective.","title":"conf file settings and syntax"},{"location":"mirroring.html#v36-preventing-automatic-sync","text":"Sometimes you don't want a repo to be mirrored automatically (as soon as someone pushes to the master) to all the copies. For whatever reasons, you have some copies for whom you would like to trigger the sync later (and you don't mind the fact that those copies are out of sync until then). To make that happen, use option lines like this instead of those shown above: option mirror.copies.nosync-1 = phobos deimos Except for the addition of a .nosync just after copies , all the other rules are the same as before.","title":"(v3.6+) preventing automatic sync"},{"location":"mirroring.html#v361-mirroring-failures","text":"Since mirror pushes happen asynchronously (i.e, the user who originally pushed does not have to wait for the mirrors to be synced), any mirror push failures are not immediately visible to a human being, although you will find them if you look in gitolite's log files. Note: since only a successful push can clear the error status, it follows that if a mirror push failed due to an invalid hostname, that status file will need to be manually deleted from the server. Look in the bare repo directory on the server, for one or more files whose names start with 'gl-copy' and delete the appropriate one. Therefore, when the output of the mirror push to some copy contains the word \"fatal\", gitolite saves the output. This saved output is printed to STDERR when any user attempts to clone/fetch/push the repo on the master server for that repo. The hope is that someone will alert an admin to look at the problem. This will continue to happen until the error condition is cleared (i.e., a successful mirror push happens to that specific copy). If you don't want these unexpected reports confusing users (or programs!), simply create a new rc variable called HUSH_MIRROR_STATUS and set it to 1. (If you're not sure where in the rc file this should go, I suggest putting it right after the HOSTNAME variable). You can see the mirror status of any repo using the 'mirror status' command; the command line help for the mirror command ('gitolite mirror -h' or 'ssh git@host mirror -h') has details.","title":"(v3.6.1+) mirroring failures"},{"location":"mirroring.html#manually-synchronising-a-copy-repo","text":"You can use the gitolite mirror push command on a master to manually synchronise any of its copies. Try it with -h to get usage info. Tip: if you want to do this to all the copies, try this: for s in `gitolite mirror list copies reponame` do gitolite mirror push $s reponame done This command can also be run remotely; run ssh git@host mirror -h for details. Note: if your version of the mirror command does not support 'list copies', use gitolite git-config -r reponame mirror.copies | cut -f3 instead.","title":"manually synchronising a copy repo"},{"location":"mirroring.html#redirected-pushes","text":"Please read carefully; there are security implications if you enable this for mirrors NOT under your control . Normally, a master, (and only a master), pushes to a copy, and the copies are \"read-only\" to the users. Gitolite allows a copy to receive pushes from a user and transparently redirect them to the master . This simplifies things for users in complex setups, letting them use their local mirror for both fetch and push access to all repos. Note: Just to be clear, the actual push will still happen only on the master, which needs to be up (the redirection is at the ssh level). It's main use is in geographically distributed setups, where users are encouraged to use a nearer node as their \"fetch\" remote, but, without this feature, they'd have to use the actual master node as the \"push\" remote. This allows users to use the same (nearby) node as the \"push\" remote also. It is also useful if the master dies, and the administrator redesignates some other node as the master. In that situation, only users who had the original master as a remote need to update their remote URLs. The syntax for enabling this is one of these: option mirror.redirectOK = all option mirror.redirectOK = phobos deimos The first syntax trusts all valid copies to redirect user pushes, while the second one trusts only some copies. IMPORTANT NOTES This only works for ssh-based setups; you cannot use this feature in http mode. Authentication happens on the copy, but authorisation is on the master. The master is trusting the copy to authenticate the user correctly, even though the actual push is going to the master. This means that user alice on the copy must be guaranteed to be the same as user alice on the master. The part of the authorisation that happens before passing control to git-receive-pack (see access rules ) will happen on the copy as well. You cannot redirect gitolite commands (like perms, etc).","title":"redirected pushes"},{"location":"mirroring.html#appendix-a-hostname-substitution","text":"Wherever gitolite sees the word %HOSTNAME , it will replace it with the HOSTNAME supplied in the rc file, if one was supplied. This lets you maintain configurations for all servers in one repo, yet have them act differently on different servers, by saying something like: include \"%HOSTNAME/*.conf\" (See include for more on the 'include' command). You can use it in other places also, for example: RW+ VREF/ NAME/ subs/%HOST NAME/ = @%HOSTNAME-admins (you still have to define @mars-admins, @phobos-admins, etc., but the actual VREF is now one line instead of one for each server!)","title":"appendix A: HOSTNAME substitution"},{"location":"mirroring.html#appendix-b-efficiency-versus-paranoia","text":"If you're paranoid enough to use mirrors, you should be paranoid enough to set this on each server, despite the possible CPU overhead: git config --global receive.fsckObjects true","title":"appendix B: efficiency versus paranoia"},{"location":"mirroring.html#appendix-c-moving-the-admin-repo-to-a-different-master","text":"Moving only some repos (other than the gitolite-admin repo) to a different master is easy. Just make the change in the gitolite.conf file, add, commit, and push. Even for the gitolite-admin repo, if the current master is ok, it's the same thing; just make the change and push to the current master . Subsequent pushes will go to the new master, of course. But if the current master is already dead, there's a bit of a catch-22. You can't push to the master because it is dead, and you can't push to any copy because they won't accept updates from anywhere but the server they think is the master. Here's how to resolve this: On each copy: Edit ~/.gitolite/conf/gitolite.conf to change the master and copy options for the gitolite-admin repo. Run gitolite setup . Now clone the admin repo from the new master to your workstation, change the options for the rest of the repos (if needed), then add/commit/push. And that should be all you need to do.","title":"appendix C: moving the admin repo to a different master"},{"location":"mirroring.html#appendix-d-fixing-a-broken-copy","text":"Let's say you had option mirror.master = mars option mirror.copies = phobos deimos and you then accidentally removed phobos and pushed. You quickly realise your error and put the line back, then push again, only to realise that phobos is now unreachable. It took the previous push to heart and updated its internal state accordingly, and any subsequent attempts to touch the gitolite-admin repo on phobos results in the message: FATAL: phobos: 'gitolite-admin' is mirrored but not here This is basically saying, \"yes I see that repo in the config, but I (phobos) am neither the master nor one of the copies for it, so please don't ask me about it!\". You're basically locked out of phobos now. The solution is this: log on to phobos' gitolite shell account edit ~/.gitolite/conf/gitolite.conf to fix the mirroring options for the gitolite-admin repo. run gitolite setup . That should do it.","title":"appendix D: fixing a broken copy"},{"location":"namespaces.html","text":"namespace support in gitolite \uf0c1 This feature is only available in the 'namespaces' branch until enough people test it and tell me it works fine . AVOID NASTY SURPRISES! Please read the entire page before attempting to use or install this. Most non-core features of gitolite do not work with namespaces, and, worse, many of them will fail silently . There are also security issues you need to be aware of. background \uf0c1 In many projects, developers need to push their work to some central place for others to fetch. Namespaces allow you to give each developer what looks like her own repo or set of repos, while combining all these logical repos into one physical repo on the server. This saves a lot of disk space if they all share a lot of common history. The logical repos look like normal repos to a git client ; all the magic is on the server side. (But see the \"WARNINGS\" section). terminology \uf0c1 There is one repo that is special, and several others that depend upon it or use it. Depending on context, we use one of the following names: Storage context: backing repo/real repo, and logical repos Workflow context: blessed repo and developer repos In addition, in the gitolite context you could say that the blessed repo is a normal (not \"wild\") repo and the logical repos are wild repos, since that is the most convenient way to set this up. However, it is not mandatory -- you can have a wild repo as a backing repo, and/or a normal repo as a logical repo if you wish. setup \uf0c1 First, add the following lines to the rc file, as indicated: # add this line as the *last* item in the PRE_GIT trigger list. In # particular, it should be *after* the Mirroring::pre_git line if you're # using mirroring. 'Namespaces::pre_git', # add this line as the *first* item in the POST_GIT trigger list. In # particular, it should be *before* the Mirroring::post_git line if you're # using mirroring. 'Namespaces::post_git', Then use the following example conf below as a guide and roll your own. This example is from a mail to the gitolite list by Javier Domingo (\"Mirroring forks\", 13-11-2012), modified slightly. # backing repos, normal (non-wild), serving as blessed repos repo linux git gitolite [...other projects...] RW+ = integration-manager R = @all # logical repos, wild, created by devs as needed repo CREATOR/[a-zA-Z0-9].* C = @all RW+ = CREATOR R = READERS @all option namespace.pattern = %/* is @1 in @2 use \uf0c1 A developer doesn't have to do anything differently. She will still run, e.g., git clone git@host:alice/linux to auto-create and clone a wild repo for herself, then add a remote to the \"backing\" repo, fetch it, start working, and eventually push her work to alice/linux. However, she might notice some differences. To begin with, her first push of an enormous code base, to what she thought was an empty repo on the server, might go surprisingly fast :) Secondly, a lot of gitolite commands (and other features) won't work. See the \"WARNINGS\" section below for more. details \uf0c1 The option line above has 3 parts separated by the words \"is\" and \"in\": <pattern> is <namespace> in <backing repo> When a user attempts to access a logical repo (say \"alice/linux\"), the namespace pattern for that repo is applied to the repo name as follows: a percent sign matches a single component in the repo name an asterisk matches one or more components Once the matching is done, each \"at-digit\" combination is replaced by the corresponding matched segment to derive the namespace and the backing repo name. Some examples may help: Here's a simple one that separate the first component from the rest: option namespace.pattern = %/* is @1 in @2 A reponame of 'alice/linux' gives you a namespace of 'alice' and a backing reponame of 'linux'. Similarly, 'alice/linux/2.2' gives you 'alice' and 'linux/2.2' (which means a repo of that name has to exist!); notice how the asterisk grabs up all the remaining components in the repo name. This one separates the first, the second, and all the rest, but combines them in a different order: option namespace.pattern = %/%/* is @1/@3 in @2 A reponame of 'alice/linux/2.2' gives you 'alice/2.2' and 'linux', while a reponame of 'alice/linux/2.2/smp' gives you 'alice/2.2/smp' and 'linux'. Here's another example on the same lines: option namespace.pattern = %/%/%/* is @3/@2/@4 in @1 A reponame of 'linux/kernel/torvalds/linux-2.6' gives you a namespace of 'torvalds/kernel/linux-2.6' and a backing repo name of 'linux'. Here's an interesting example, given in full to explain better. The basic problem is that one of our backing repos is not a simple name (like 'git' or 'linux'); it is 'sitaramc/gitolite'. In addition, any developer-owned repo that has 3 or more components is not a fork of anything at all, and should not be subject to namespace processing (i.e., it's just a normal repo) # backing repos repo sitaramc/gitolite linux git ...access rules for backing repos... # logical repos repo CREATOR/..* C = @team RW+ = CREATOR R = @all option namespace.pattern-1 = %/gitolite is @1 in sitaramc/gitolite option namespace.pattern-2 = %/% is @1 in @2 option namespace.pattern-3 = %/%/* is none in @1/@2/@3 Firstly, this shows how to specify more than one namespace pattern. Each pattern is tried in lexically sorted order until a match is found. (Warning: \"lexically sorted\" means 'namespace.pattern-10' sorts before 'namespace.pattern-2'!) Secondly, the example shows that you can hardcode anything, like we did for the backing reponame in pattern 1. Thirdly, it shows how you can specify a pattern that disables namespacing, like the last pattern. When the backing repo name ends up being exactly the same as the original repo name, gitolite notices this and treats it as a real repo, not as a logical repo. (If this confuses you, ignore it and use some other pattern, say CREATOR/personal/..* for developers personal repos, and don't give them namespace pattern options). Here are some example results from this setup: alice/gitolite -> alice, sitaramc/gitolite (pattern 1) alice/linux -> alice, linux (pattern 2) alice/linux/2.2 -> (namespace processing disabled) alice/personal/foo -> (namespace processing disabled) Here's an example with some errors: option namespace.pattern-1 = %/gitolite is @1 in sitaramc/gitolite option namespace.pattern-2 = %/% is @1 in @2 option namespace.pattern-3 = %/%/* is @1/@3 in @2 If you try 'alice/gitolite/foo' in this setup, it will only match the 3rd pattern. The backing repo name will be 'gitolite', which probably doesn't exist, and git will complain. Also, without rule 3, trying a repo with more than 2 components won't work. Gitolite will complain that no namespace options matched. This would indicate a discrepancy between the repo [...] line governing those options and the options themselves; you need to fine tune one or the others to fix things. WARNINGS \uf0c1 SECURITY \uf0c1 First and most important , please read 'man gitnamespaces' for important security information about namespaces. Secondly, please note that gitolite's access control decisions are made based on the repo name that the user supplies, even if that is only a logical repo. E.g., in a sequence like this: git clone git@server:alice/linux # 1 cd alice git remote add backing git@server:linux git fetch backing # 2 git checkout master git push origin master # 3 Lines 1 and 3 use the access list for the logical repo (\"alice/linux\") to allow or reject a push, while line 2, which is directly contacting the \"backing\" repo, use that repo's access rules. In particular, Alice does not need write access to the backing repo for the push to succeed! gitolite functionality \uf0c1 Most things you're used to in gitolite won't work with logical repos. From the client point of view, the only features guaranteed to work on logical repos are : normal git operations (clone, fetch, push) creating a new wild repo the perms command (except the \"-c\" flag) From a server/admin point of view, the following will not work for logical repos, and may even fail silently! : smart-http mode the 'config' line in gitolite.conf any 'option's affecting a physical repo, like RepoUmask anything that expects to be recorded somewhere in the bare repo directory. ...and anything else not explicitly listed as \"working\" in this doc ;-) gitolite functionality -- mirroring \uf0c1 Mirroring works, but all the logical repos and the backing repo should have the same mirroring setup . I.e., which server is the master, who are the copies, are redirects allowed, if so from where, etc., etc., etc., should all have the same values for all of them. I cannot over-emphasise the importance of this for proper mirroring. other notes \uf0c1 The \"backing repo\" needs to exist. If it is itself a wild repo, it must be auto-created before a logical repo that hangs off of it is accessed. The logical repo must also be mentioned in the gitolite.conf file in some way, as you saw in the example. Access control decisions are made based on this one, not the backing repo. One quirk is that, if the logical repo is a wild repo, then an actual repo with that name is created on disk. Gitolite needs a place to keep its repo-specific permissions so it has to do that. You will find, however, that the objects directory is pretty much empty, even after a lot of activity.","title":"using git namespaces"},{"location":"namespaces.html#namespace-support-in-gitolite","text":"This feature is only available in the 'namespaces' branch until enough people test it and tell me it works fine . AVOID NASTY SURPRISES! Please read the entire page before attempting to use or install this. Most non-core features of gitolite do not work with namespaces, and, worse, many of them will fail silently . There are also security issues you need to be aware of.","title":"namespace support in gitolite"},{"location":"namespaces.html#background","text":"In many projects, developers need to push their work to some central place for others to fetch. Namespaces allow you to give each developer what looks like her own repo or set of repos, while combining all these logical repos into one physical repo on the server. This saves a lot of disk space if they all share a lot of common history. The logical repos look like normal repos to a git client ; all the magic is on the server side. (But see the \"WARNINGS\" section).","title":"background"},{"location":"namespaces.html#terminology","text":"There is one repo that is special, and several others that depend upon it or use it. Depending on context, we use one of the following names: Storage context: backing repo/real repo, and logical repos Workflow context: blessed repo and developer repos In addition, in the gitolite context you could say that the blessed repo is a normal (not \"wild\") repo and the logical repos are wild repos, since that is the most convenient way to set this up. However, it is not mandatory -- you can have a wild repo as a backing repo, and/or a normal repo as a logical repo if you wish.","title":"terminology"},{"location":"namespaces.html#setup","text":"First, add the following lines to the rc file, as indicated: # add this line as the *last* item in the PRE_GIT trigger list. In # particular, it should be *after* the Mirroring::pre_git line if you're # using mirroring. 'Namespaces::pre_git', # add this line as the *first* item in the POST_GIT trigger list. In # particular, it should be *before* the Mirroring::post_git line if you're # using mirroring. 'Namespaces::post_git', Then use the following example conf below as a guide and roll your own. This example is from a mail to the gitolite list by Javier Domingo (\"Mirroring forks\", 13-11-2012), modified slightly. # backing repos, normal (non-wild), serving as blessed repos repo linux git gitolite [...other projects...] RW+ = integration-manager R = @all # logical repos, wild, created by devs as needed repo CREATOR/[a-zA-Z0-9].* C = @all RW+ = CREATOR R = READERS @all option namespace.pattern = %/* is @1 in @2","title":"setup"},{"location":"namespaces.html#use","text":"A developer doesn't have to do anything differently. She will still run, e.g., git clone git@host:alice/linux to auto-create and clone a wild repo for herself, then add a remote to the \"backing\" repo, fetch it, start working, and eventually push her work to alice/linux. However, she might notice some differences. To begin with, her first push of an enormous code base, to what she thought was an empty repo on the server, might go surprisingly fast :) Secondly, a lot of gitolite commands (and other features) won't work. See the \"WARNINGS\" section below for more.","title":"use"},{"location":"namespaces.html#details","text":"The option line above has 3 parts separated by the words \"is\" and \"in\": <pattern> is <namespace> in <backing repo> When a user attempts to access a logical repo (say \"alice/linux\"), the namespace pattern for that repo is applied to the repo name as follows: a percent sign matches a single component in the repo name an asterisk matches one or more components Once the matching is done, each \"at-digit\" combination is replaced by the corresponding matched segment to derive the namespace and the backing repo name. Some examples may help: Here's a simple one that separate the first component from the rest: option namespace.pattern = %/* is @1 in @2 A reponame of 'alice/linux' gives you a namespace of 'alice' and a backing reponame of 'linux'. Similarly, 'alice/linux/2.2' gives you 'alice' and 'linux/2.2' (which means a repo of that name has to exist!); notice how the asterisk grabs up all the remaining components in the repo name. This one separates the first, the second, and all the rest, but combines them in a different order: option namespace.pattern = %/%/* is @1/@3 in @2 A reponame of 'alice/linux/2.2' gives you 'alice/2.2' and 'linux', while a reponame of 'alice/linux/2.2/smp' gives you 'alice/2.2/smp' and 'linux'. Here's another example on the same lines: option namespace.pattern = %/%/%/* is @3/@2/@4 in @1 A reponame of 'linux/kernel/torvalds/linux-2.6' gives you a namespace of 'torvalds/kernel/linux-2.6' and a backing repo name of 'linux'. Here's an interesting example, given in full to explain better. The basic problem is that one of our backing repos is not a simple name (like 'git' or 'linux'); it is 'sitaramc/gitolite'. In addition, any developer-owned repo that has 3 or more components is not a fork of anything at all, and should not be subject to namespace processing (i.e., it's just a normal repo) # backing repos repo sitaramc/gitolite linux git ...access rules for backing repos... # logical repos repo CREATOR/..* C = @team RW+ = CREATOR R = @all option namespace.pattern-1 = %/gitolite is @1 in sitaramc/gitolite option namespace.pattern-2 = %/% is @1 in @2 option namespace.pattern-3 = %/%/* is none in @1/@2/@3 Firstly, this shows how to specify more than one namespace pattern. Each pattern is tried in lexically sorted order until a match is found. (Warning: \"lexically sorted\" means 'namespace.pattern-10' sorts before 'namespace.pattern-2'!) Secondly, the example shows that you can hardcode anything, like we did for the backing reponame in pattern 1. Thirdly, it shows how you can specify a pattern that disables namespacing, like the last pattern. When the backing repo name ends up being exactly the same as the original repo name, gitolite notices this and treats it as a real repo, not as a logical repo. (If this confuses you, ignore it and use some other pattern, say CREATOR/personal/..* for developers personal repos, and don't give them namespace pattern options). Here are some example results from this setup: alice/gitolite -> alice, sitaramc/gitolite (pattern 1) alice/linux -> alice, linux (pattern 2) alice/linux/2.2 -> (namespace processing disabled) alice/personal/foo -> (namespace processing disabled) Here's an example with some errors: option namespace.pattern-1 = %/gitolite is @1 in sitaramc/gitolite option namespace.pattern-2 = %/% is @1 in @2 option namespace.pattern-3 = %/%/* is @1/@3 in @2 If you try 'alice/gitolite/foo' in this setup, it will only match the 3rd pattern. The backing repo name will be 'gitolite', which probably doesn't exist, and git will complain. Also, without rule 3, trying a repo with more than 2 components won't work. Gitolite will complain that no namespace options matched. This would indicate a discrepancy between the repo [...] line governing those options and the options themselves; you need to fine tune one or the others to fix things.","title":"details"},{"location":"namespaces.html#warnings","text":"","title":"WARNINGS"},{"location":"namespaces.html#security","text":"First and most important , please read 'man gitnamespaces' for important security information about namespaces. Secondly, please note that gitolite's access control decisions are made based on the repo name that the user supplies, even if that is only a logical repo. E.g., in a sequence like this: git clone git@server:alice/linux # 1 cd alice git remote add backing git@server:linux git fetch backing # 2 git checkout master git push origin master # 3 Lines 1 and 3 use the access list for the logical repo (\"alice/linux\") to allow or reject a push, while line 2, which is directly contacting the \"backing\" repo, use that repo's access rules. In particular, Alice does not need write access to the backing repo for the push to succeed!","title":"SECURITY"},{"location":"namespaces.html#gitolite-functionality","text":"Most things you're used to in gitolite won't work with logical repos. From the client point of view, the only features guaranteed to work on logical repos are : normal git operations (clone, fetch, push) creating a new wild repo the perms command (except the \"-c\" flag) From a server/admin point of view, the following will not work for logical repos, and may even fail silently! : smart-http mode the 'config' line in gitolite.conf any 'option's affecting a physical repo, like RepoUmask anything that expects to be recorded somewhere in the bare repo directory. ...and anything else not explicitly listed as \"working\" in this doc ;-)","title":"gitolite functionality"},{"location":"namespaces.html#gitolite-functionality-mirroring","text":"Mirroring works, but all the logical repos and the backing repo should have the same mirroring setup . I.e., which server is the master, who are the copies, are redirects allowed, if so from where, etc., etc., etc., should all have the same values for all of them. I cannot over-emphasise the importance of this for proper mirroring.","title":"gitolite functionality -- mirroring"},{"location":"namespaces.html#other-notes","text":"The \"backing repo\" needs to exist. If it is itself a wild repo, it must be auto-created before a logical repo that hangs off of it is accessed. The logical repo must also be mentioned in the gitolite.conf file in some way, as you saw in the example. Access control decisions are made based on this one, not the backing repo. One quirk is that, if the logical repo is a wild repo, then an actual repo with that name is created on disk. Gitolite needs a place to keep its repo-specific permissions so it has to do that. You will find, however, that the objects directory is pretty much empty, even after a lot of activity.","title":"other notes"},{"location":"no-way.html","text":"no way! \uf0c1 For the entertainment of the sensible majority, and as a way of thanking all of you, here are some examples of requests (demands in some cases) I have received over the last couple of years. deleting environment variables copied from client session demand: add code to delete certain environment variables at startup because \"the openssh servers in the linux distribution that [he] use[s], are configured to copy GIT_* variables to the remote session\". This is wrong on so many levels it's almost plonk-able! using cp instead of ln Guy has an NTFS file system mounted on Linux. So... no symlinks (an NTFS file system on Windows works fine because msysgit/cygwin manage to simulate them. NTFS mounted on Linux won't do that!) He wanted all the symlink stuff to be replaced by copies. No. Way. non-bare repos on the server Some guy gave me a complicated spiel about git-svn not liking bare repos or whatever. I tuned off at the first mention of those 3 letters so I don't really know what the actual problem was. But it doesn't matter. Even if someone (Ralf H) had not chipped in with a workable solution, I still would not do it. A server repo should be bare. Period. incomplete ownership of GL_REPO_BASE This guy had a repo-base directory where not all of the files were owned by the git user. As a result, some of the hooks did not get created. He claimed my code should detect OS-permissions issues while it's doing its stuff. No. I refuse to have the code constantly look over its shoulder making sure fundamental assumptions are being met. empty template directory (See man git-init for what a template directory is). The same guy with the environment variables had an empty template directory because he \"does not like to have sample hooks in every repository\". So naturally, the hooks directory does not get created when you run a git init . He expects gitolite to compensate for it. Granted, it's only a 1-line change. But again, this falls under \"constantly looking over your shoulder to double check fundamental assumptions\". Where does it end? [update 2014-07: I believe I read somewhere that git itself may be removing those \"sample\" hooks. If that also means the hooks directory will not be created when you \"git init --bare\", then I guess I'd have to do something!]","title":"no way!"},{"location":"no-way.html#no-way","text":"For the entertainment of the sensible majority, and as a way of thanking all of you, here are some examples of requests (demands in some cases) I have received over the last couple of years. deleting environment variables copied from client session demand: add code to delete certain environment variables at startup because \"the openssh servers in the linux distribution that [he] use[s], are configured to copy GIT_* variables to the remote session\". This is wrong on so many levels it's almost plonk-able! using cp instead of ln Guy has an NTFS file system mounted on Linux. So... no symlinks (an NTFS file system on Windows works fine because msysgit/cygwin manage to simulate them. NTFS mounted on Linux won't do that!) He wanted all the symlink stuff to be replaced by copies. No. Way. non-bare repos on the server Some guy gave me a complicated spiel about git-svn not liking bare repos or whatever. I tuned off at the first mention of those 3 letters so I don't really know what the actual problem was. But it doesn't matter. Even if someone (Ralf H) had not chipped in with a workable solution, I still would not do it. A server repo should be bare. Period. incomplete ownership of GL_REPO_BASE This guy had a repo-base directory where not all of the files were owned by the git user. As a result, some of the hooks did not get created. He claimed my code should detect OS-permissions issues while it's doing its stuff. No. I refuse to have the code constantly look over its shoulder making sure fundamental assumptions are being met. empty template directory (See man git-init for what a template directory is). The same guy with the environment variables had an empty template directory because he \"does not like to have sample hooks in every repository\". So naturally, the hooks directory does not get created when you run a git init . He expects gitolite to compensate for it. Granted, it's only a 1-line change. But again, this falls under \"constantly looking over your shoulder to double check fundamental assumptions\". Where does it end? [update 2014-07: I believe I read somewhere that git itself may be removing those \"sample\" hooks. If that also means the hooks directory will not be created when you \"git init --bare\", then I guess I'd have to do something!]","title":"no way!"},{"location":"non-core.html","text":"\"non-core\" gitolite \uf0c1 Much of gitolite's functionality comes from programs and scripts that are not considered \"core\". This keeps the core simpler, and allows you to enhance gitolite for your own site without too much fuss. Documentation for non-core gitolite is organised as follows: This page describes the types of non-core programs and how/where to install code that is specific to your site. The developer notes page tells you how to write your own non-core programs. The list of non-core programs talks about what's already shipped with gitolite, with a brief description of each. core versus non-core \uf0c1 Gitolite has five types of non-core code: Commands can be run from the shell command line. Among those, the ones in the ENABLE list in the rc file can also be run remotely. Hooks are standard git hooks. Sugar scripts change the conf language for your convenience. The word sugar comes from \"syntactic sugar\". Triggers are to gitolite what hooks are to git. I just chose a different name to avoid confusion and constant disambiguation in the docs. VREFs are extensions to the access control check part of gitolite. locations... \uf0c1 ...for non-core programs shipped with gitolite \uf0c1 . \u251c\u2500\u2500 commands \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 Gitolite \u2502 \u251c\u2500\u2500 Conf \u2502 \u251c\u2500\u2500 Hooks \u2502 \u251c\u2500\u2500 Test \u2502 \u2514\u2500\u2500 Triggers \u251c\u2500\u2500 syntactic-sugar \u251c\u2500\u2500 triggers \u2514\u2500\u2500 VREF gitolite query-rc GL_BINDIR will tell you where gitolite's code has been installed. That directory should look like this. Among these, the directories in green are considered \"non-core\", while the ones in red are considered \"core\". In addition, the two files \"gitolite\" and \"gitolite-shell\" in src are also considered \"core\" You might notice that there are two locations for triggers ; that is simply because there are two types of them. You might also notice that there is no place for hooks -- gitolite doesn't ship with any hooks that are non-core. ...for your non-core programs \uf0c1 . \u251c\u2500\u2500 commands \u251c\u2500\u2500 hooks \u2502 \u2514\u2500\u2500 common \u2502 \u2514\u2500\u2500 repo-specific \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 Gitolite \u2502 \u2514\u2500\u2500 Triggers \u251c\u2500\u2500 syntactic-sugar \u251c\u2500\u2500 triggers \u2514\u2500\u2500 VREF If you want to add your own non-core programs, or even override the shipped ones with your own, you can. Put your programs in some convenient directory and use the LOCAL_CODE rc variable to tell gitolite where that is. Please supply the FULL path to this variable. (You'll find the rc file already has examples lines, commented out, so it's easy to know where to put it and what syntax to use). Within that directory, you can use any or all of the subdirectories shown here. If you add a program in your local code directory with the same name as a shipped program, gitolite uses your version. Notice that there are two directories related to hooks here, neither of which exist in the shipped non-core code. Also, the hooks/common directory is a bit special. If you add new hooks to this, you must run gitolite setup , or at least gitolite setup --hooks-only , for it to take effect. using the gitolite-admin repo to manage non-core code \uf0c1 Important security note: In this mode, anyone who can push changes to the admin repo will effectively be able to run any arbitrary command on the server. See gitolite admin and shell access for more background. The location given in LOCAL_CODE could be anywhere on disk, like say $ENV{HOME}/local . However, some administrators find it convenient to use the admin repo to manage this code as well, getting the benefits of versioning them as well as making changes to them without having to log on to the server. To do this, simply point LOCAL_CODE to someplace inside $GL_ADMIN_BASE in the rc file. I strongly suggest: LOCAL_CODE => \" $rc { GL_ADMIN_BASE } /local \" , Then you create a directory called \"local\" in your gitolite clone, and create the directory structure (shown in the previous section) within that directory. Thus, when you push the admin repo, the files will land up, with the correct paths, in the location pointed to by LOCAL_CODE. (Note: when you do this, gitolite takes care of running gitolite setup --hooks-only when you change any hooks and push). types of non-core programs \uf0c1 gitolite \"commands\" \uf0c1 Gitolite comes with several commands that users can run. Remote users run commands by saying: ssh git@host command [args...] while on the server you can run gitolite command [args...] Very few commands are designed to be run both ways, but it can be done, by checking for the presence of env var GL_USER . All commands respond to a single -h option with a suitable message. You can get a list of available commands by using the help command. Naturally, a remote user will see a much smaller list than the server user. You allow a command to be run from remote clients by adding its name to (or uncommenting it if it's already added but commented out) the ENABLE list in the rc file. hooks and gitolite \uf0c1 You can install any hooks except these: (all repos) Gitolite reserves the update hook. See the \"hooks\" section in dev-notes if you want additional update hook functionality. (gitolite-admin repo only) Gitolite reserves the post-update hook. How/where to install them is described in detail in the \"locations\" section above, especially this and this . The summary is that you put them in the \"hooks/common\" sub-directory within the directory whose name is given in the LOCAL_CODE rc variable, then run gitolite setup . repo-specific hooks \uf0c1 Important security note: If you enable this, anyone who can push changes to the admin repo will effectively be able to run any arbitrary command on the server. See gitolite admin and shell access for more background. If you want to add hooks only to specific repos, you can just do it manually if you wish -- just log on to the server and add hooks (except the update hook and, for the special gitolite-admin repo, the post-update hook -- touch these and all bets on gitolite's functionality are off). However, if you want to do that from within gitolite, and thus keep everything together, you can do that also. Here's how. Create a directory called hooks/repo-specific in whatever location you decided to use for your non-core code (i.e., direct on the server, or within the gitolite-admin repo). Add your hooks here, with descriptive names (i.e., not \"post-receive\", etc., but maybe \"jenkins\" or \"deploy\" or whatever). As of v3.6.7, you can also put them in subdirectories for convenience (like if you have too many repo specific hooks). For instance, you could put some hook code in foo/bar ; the symlink in the repo's hooks directory will be created as if you had called it foo_bar . Uncomment the 'repo-specific-hooks' line in the rc file or add it to the ENABLE list if it doesn't exist. If your rc file does not have an ENABLE list, you need to add this to the POST_COMPILE and the POST_CREATE lists. Click here for more on all this. Now add lines like this to your conf file: repo foo option hook.post-receive = deploy The syntax should be fairly obvious, but just to be clear, in this case a symlink called \"post-receive\" will be placed in foo.git/hooks, pointing to the executable called \"deploy\" in hooks/repo-specific in the local-code area. WARNING : if the hook already exists, it is silently overwritten. WARNING : (v3.5.x or below) once the hook is placed, you can't remove it through gitolite. That is, removing the option line won't do anything. You'll have to go to the server and remove it manually. (v3.6+) You can assign multiple targets for each hook. For example, you could say repo foo option hook.post-receive = deploy mail-admins where \"deploy\" and \"mail-admins\" are pieces of code that do whatever their names suggest, and both are, independently, candidates for being run from a post-receive hook. When you do this, gitolite does whatever is needed to run each of them as independent post-receive hooks (including sending them info over their STDIN as documented in 'man githooks'). For pre-receive or pre-auto-gc you should not use more than one hook. If you really need more than one, ask on the mailing list. (v3.6+) You can change these hooks by saying: repo foo option hook.post-receive = deploy mail-admins or delete all of them by saying: repo foo option hook.post-receive = \"\" (v3.6.5+) You can add hooks incrementally. For example: repo @all option hook.post-receive.00 = mail-admins option hook.post-receive.01 = deploy # (and later) repo foo option hook.post-receive.00 = mail-users #1 option hook.post-receive.01 = \"\" #2 # (and maybe still later) repo @foss option hook.post-receive.02 = save-push-sigs Assuming foo is a member of @foss , this declares 2 post-receive hooks for it: mail-users and save-push-sigs. The suffix (in this example, \"00\", \"01\") can actually be any simple word. Using a suffix keeps the option names unique, which allows you to override or delete specific options, as we did in the lines marked '#1' and '#2'. The suffix also determines the order in which the options are used in applying hooks to the repo. If the order doesn't matter to you, just make sure they're unique. syntactic sugar \uf0c1 Sugar scripts help you change the perceived syntax of the conf language. The base syntax of the language is very simple, so sugar scripts take something else and convert it into that. That way, the admin sees additional features (like allowing continuation lines), while the parser in the core gitolite engine does not change. If you want to write your own sugar scripts, please read the \"your own sugar\" section in dev-notes first then email me. You enable a sugar script by uncommenting the feature name in the ENABLE list in the rc file. triggers \uf0c1 Triggers have their own page . VREFs \uf0c1 VREFs also have their own page .","title":"core and \"non-core\" gitolite"},{"location":"non-core.html#non-core-gitolite","text":"Much of gitolite's functionality comes from programs and scripts that are not considered \"core\". This keeps the core simpler, and allows you to enhance gitolite for your own site without too much fuss. Documentation for non-core gitolite is organised as follows: This page describes the types of non-core programs and how/where to install code that is specific to your site. The developer notes page tells you how to write your own non-core programs. The list of non-core programs talks about what's already shipped with gitolite, with a brief description of each.","title":"\"non-core\" gitolite"},{"location":"non-core.html#core-versus-non-core","text":"Gitolite has five types of non-core code: Commands can be run from the shell command line. Among those, the ones in the ENABLE list in the rc file can also be run remotely. Hooks are standard git hooks. Sugar scripts change the conf language for your convenience. The word sugar comes from \"syntactic sugar\". Triggers are to gitolite what hooks are to git. I just chose a different name to avoid confusion and constant disambiguation in the docs. VREFs are extensions to the access control check part of gitolite.","title":"core versus non-core"},{"location":"non-core.html#locations","text":"","title":"locations..."},{"location":"non-core.html#for-non-core-programs-shipped-with-gitolite","text":". \u251c\u2500\u2500 commands \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 Gitolite \u2502 \u251c\u2500\u2500 Conf \u2502 \u251c\u2500\u2500 Hooks \u2502 \u251c\u2500\u2500 Test \u2502 \u2514\u2500\u2500 Triggers \u251c\u2500\u2500 syntactic-sugar \u251c\u2500\u2500 triggers \u2514\u2500\u2500 VREF gitolite query-rc GL_BINDIR will tell you where gitolite's code has been installed. That directory should look like this. Among these, the directories in green are considered \"non-core\", while the ones in red are considered \"core\". In addition, the two files \"gitolite\" and \"gitolite-shell\" in src are also considered \"core\" You might notice that there are two locations for triggers ; that is simply because there are two types of them. You might also notice that there is no place for hooks -- gitolite doesn't ship with any hooks that are non-core.","title":"...for non-core programs shipped with gitolite"},{"location":"non-core.html#for-your-non-core-programs","text":". \u251c\u2500\u2500 commands \u251c\u2500\u2500 hooks \u2502 \u2514\u2500\u2500 common \u2502 \u2514\u2500\u2500 repo-specific \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 Gitolite \u2502 \u2514\u2500\u2500 Triggers \u251c\u2500\u2500 syntactic-sugar \u251c\u2500\u2500 triggers \u2514\u2500\u2500 VREF If you want to add your own non-core programs, or even override the shipped ones with your own, you can. Put your programs in some convenient directory and use the LOCAL_CODE rc variable to tell gitolite where that is. Please supply the FULL path to this variable. (You'll find the rc file already has examples lines, commented out, so it's easy to know where to put it and what syntax to use). Within that directory, you can use any or all of the subdirectories shown here. If you add a program in your local code directory with the same name as a shipped program, gitolite uses your version. Notice that there are two directories related to hooks here, neither of which exist in the shipped non-core code. Also, the hooks/common directory is a bit special. If you add new hooks to this, you must run gitolite setup , or at least gitolite setup --hooks-only , for it to take effect.","title":"...for your non-core programs"},{"location":"non-core.html#using-the-gitolite-admin-repo-to-manage-non-core-code","text":"Important security note: In this mode, anyone who can push changes to the admin repo will effectively be able to run any arbitrary command on the server. See gitolite admin and shell access for more background. The location given in LOCAL_CODE could be anywhere on disk, like say $ENV{HOME}/local . However, some administrators find it convenient to use the admin repo to manage this code as well, getting the benefits of versioning them as well as making changes to them without having to log on to the server. To do this, simply point LOCAL_CODE to someplace inside $GL_ADMIN_BASE in the rc file. I strongly suggest: LOCAL_CODE => \" $rc { GL_ADMIN_BASE } /local \" , Then you create a directory called \"local\" in your gitolite clone, and create the directory structure (shown in the previous section) within that directory. Thus, when you push the admin repo, the files will land up, with the correct paths, in the location pointed to by LOCAL_CODE. (Note: when you do this, gitolite takes care of running gitolite setup --hooks-only when you change any hooks and push).","title":"using the gitolite-admin repo to manage non-core code"},{"location":"non-core.html#types-of-non-core-programs","text":"","title":"types of non-core programs"},{"location":"non-core.html#gitolite-commands","text":"Gitolite comes with several commands that users can run. Remote users run commands by saying: ssh git@host command [args...] while on the server you can run gitolite command [args...] Very few commands are designed to be run both ways, but it can be done, by checking for the presence of env var GL_USER . All commands respond to a single -h option with a suitable message. You can get a list of available commands by using the help command. Naturally, a remote user will see a much smaller list than the server user. You allow a command to be run from remote clients by adding its name to (or uncommenting it if it's already added but commented out) the ENABLE list in the rc file.","title":"gitolite \"commands\""},{"location":"non-core.html#hooks-and-gitolite","text":"You can install any hooks except these: (all repos) Gitolite reserves the update hook. See the \"hooks\" section in dev-notes if you want additional update hook functionality. (gitolite-admin repo only) Gitolite reserves the post-update hook. How/where to install them is described in detail in the \"locations\" section above, especially this and this . The summary is that you put them in the \"hooks/common\" sub-directory within the directory whose name is given in the LOCAL_CODE rc variable, then run gitolite setup .","title":"hooks and gitolite"},{"location":"non-core.html#repo-specific-hooks","text":"Important security note: If you enable this, anyone who can push changes to the admin repo will effectively be able to run any arbitrary command on the server. See gitolite admin and shell access for more background. If you want to add hooks only to specific repos, you can just do it manually if you wish -- just log on to the server and add hooks (except the update hook and, for the special gitolite-admin repo, the post-update hook -- touch these and all bets on gitolite's functionality are off). However, if you want to do that from within gitolite, and thus keep everything together, you can do that also. Here's how. Create a directory called hooks/repo-specific in whatever location you decided to use for your non-core code (i.e., direct on the server, or within the gitolite-admin repo). Add your hooks here, with descriptive names (i.e., not \"post-receive\", etc., but maybe \"jenkins\" or \"deploy\" or whatever). As of v3.6.7, you can also put them in subdirectories for convenience (like if you have too many repo specific hooks). For instance, you could put some hook code in foo/bar ; the symlink in the repo's hooks directory will be created as if you had called it foo_bar . Uncomment the 'repo-specific-hooks' line in the rc file or add it to the ENABLE list if it doesn't exist. If your rc file does not have an ENABLE list, you need to add this to the POST_COMPILE and the POST_CREATE lists. Click here for more on all this. Now add lines like this to your conf file: repo foo option hook.post-receive = deploy The syntax should be fairly obvious, but just to be clear, in this case a symlink called \"post-receive\" will be placed in foo.git/hooks, pointing to the executable called \"deploy\" in hooks/repo-specific in the local-code area. WARNING : if the hook already exists, it is silently overwritten. WARNING : (v3.5.x or below) once the hook is placed, you can't remove it through gitolite. That is, removing the option line won't do anything. You'll have to go to the server and remove it manually. (v3.6+) You can assign multiple targets for each hook. For example, you could say repo foo option hook.post-receive = deploy mail-admins where \"deploy\" and \"mail-admins\" are pieces of code that do whatever their names suggest, and both are, independently, candidates for being run from a post-receive hook. When you do this, gitolite does whatever is needed to run each of them as independent post-receive hooks (including sending them info over their STDIN as documented in 'man githooks'). For pre-receive or pre-auto-gc you should not use more than one hook. If you really need more than one, ask on the mailing list. (v3.6+) You can change these hooks by saying: repo foo option hook.post-receive = deploy mail-admins or delete all of them by saying: repo foo option hook.post-receive = \"\" (v3.6.5+) You can add hooks incrementally. For example: repo @all option hook.post-receive.00 = mail-admins option hook.post-receive.01 = deploy # (and later) repo foo option hook.post-receive.00 = mail-users #1 option hook.post-receive.01 = \"\" #2 # (and maybe still later) repo @foss option hook.post-receive.02 = save-push-sigs Assuming foo is a member of @foss , this declares 2 post-receive hooks for it: mail-users and save-push-sigs. The suffix (in this example, \"00\", \"01\") can actually be any simple word. Using a suffix keeps the option names unique, which allows you to override or delete specific options, as we did in the lines marked '#1' and '#2'. The suffix also determines the order in which the options are used in applying hooks to the repo. If the order doesn't matter to you, just make sure they're unique.","title":"repo-specific hooks"},{"location":"non-core.html#syntactic-sugar","text":"Sugar scripts help you change the perceived syntax of the conf language. The base syntax of the language is very simple, so sugar scripts take something else and convert it into that. That way, the admin sees additional features (like allowing continuation lines), while the parser in the core gitolite engine does not change. If you want to write your own sugar scripts, please read the \"your own sugar\" section in dev-notes first then email me. You enable a sugar script by uncommenting the feature name in the ENABLE list in the rc file.","title":"syntactic sugar"},{"location":"non-core.html#triggers","text":"Triggers have their own page .","title":"triggers"},{"location":"non-core.html#vrefs","text":"VREFs also have their own page .","title":"VREFs"},{"location":"odds-and-ends.html","text":"miscellaneous features \uf0c1 This page has a bunch of features that didn't seem to fit anywhere. disabling pushes to take backups \uf0c1 The writable command allows you to disable pushes to all repos or just the named repo, in order to do file-system level things to the repo directory that require it not to change, like using normal backup software. Run gitolite writable -h for more info. putting 'repositories' and '.gitolite' elsewhere \uf0c1 Gitolite insists that the \"repositories\" and \".gitolite\" directories be in $HOME . If you want them somewhere else: do the install as normal, then move those directories to wherever you want and replace them with symlinks pointing to the new location. using pubkeys obtained from elsewhere \uf0c1 If you're not managing keys via the gitolite-admin repo, but getting them from somewhere else, you'll want to periodically \"update\" the keys. To do that, first edit your rc file and add something like this: SSH_AUTHKEYS => [ 'post-compile/ssh-authkeys', ], Then write a script that gets all the keys and dumps them into $HOME/.gitolite/keydir (or into a subdirectory of it), and runs gitolite trigger SSH_AUTHKEYS . Run this from cron or however you want. giving users their own repos \uf0c1 (Please see this for background on the ideas in this section). It's very easy to give users their own set of repos to create, with the username at the top level. The simplest setup is: repo CREATOR/..* C = @all RW+ = CREATOR RW = WRITERS R = READERS Now users can create any repo under their own name simply by cloning it or pushing to it, then use the perms command to add other users to their WRITERS and READERS lists. Of course you can get much more creative if you add a few more roles . (I prefer using some prefix, say \"u\", as in repo u/CREATOR/..* . This helps to keep user-created repos separate, and avoid name clashes in some far-fetched scenarios). administering gitolite directly on the server \uf0c1 The main use of managing gitolite via the admin repo is that you get to version control the access rules. But for large sites, there's another use: you can share the admin load with more people, without having to give all of them shell access on the server. However, people who use puppet and similar systems already have a conf versioning and management system. And they'd like to continue to use that to manage gitolite repos and users, rather than be forced to do it through the gitolite-admin repo. Such sites don't really need the admin repo at all, so here's how to get rid of it and run things directly on the server (which you can script into your puppet or similar software quite easily). First the one-time stuff: install the software as normal run gitolite setup -a dummy instead of the normal setup command delete (or move away) ~/repositories/gitolite-admin.git edit ~/.gitolite/conf/gitolite.conf and remove the gitolite-admin repo and its access line. mkdir ~/.gitolite/keydir (because \"setup -a\" does not create it, but you will need it later to add keys). run gitolite compile; gitolite trigger POST_COMPILE To manage gitolite, you can directly edit files in ~/.gitolite (or cause puppet to place files there), and then run the commands in the last step above. For example: copy someone's pubkey file to ~/.gitolite/keydir edit ~/.gitolite/conf/gitolite.conf and add a repo or three, giving access to some user(s) run gitolite compile; gitolite trigger POST_COMPILE That's it.","title":"miscellaneous features"},{"location":"odds-and-ends.html#miscellaneous-features","text":"This page has a bunch of features that didn't seem to fit anywhere.","title":"miscellaneous features"},{"location":"odds-and-ends.html#disabling-pushes-to-take-backups","text":"The writable command allows you to disable pushes to all repos or just the named repo, in order to do file-system level things to the repo directory that require it not to change, like using normal backup software. Run gitolite writable -h for more info.","title":"disabling pushes to take backups"},{"location":"odds-and-ends.html#putting-repositories-and-gitolite-elsewhere","text":"Gitolite insists that the \"repositories\" and \".gitolite\" directories be in $HOME . If you want them somewhere else: do the install as normal, then move those directories to wherever you want and replace them with symlinks pointing to the new location.","title":"putting 'repositories' and '.gitolite' elsewhere"},{"location":"odds-and-ends.html#using-pubkeys-obtained-from-elsewhere","text":"If you're not managing keys via the gitolite-admin repo, but getting them from somewhere else, you'll want to periodically \"update\" the keys. To do that, first edit your rc file and add something like this: SSH_AUTHKEYS => [ 'post-compile/ssh-authkeys', ], Then write a script that gets all the keys and dumps them into $HOME/.gitolite/keydir (or into a subdirectory of it), and runs gitolite trigger SSH_AUTHKEYS . Run this from cron or however you want.","title":"using pubkeys obtained from elsewhere"},{"location":"odds-and-ends.html#giving-users-their-own-repos","text":"(Please see this for background on the ideas in this section). It's very easy to give users their own set of repos to create, with the username at the top level. The simplest setup is: repo CREATOR/..* C = @all RW+ = CREATOR RW = WRITERS R = READERS Now users can create any repo under their own name simply by cloning it or pushing to it, then use the perms command to add other users to their WRITERS and READERS lists. Of course you can get much more creative if you add a few more roles . (I prefer using some prefix, say \"u\", as in repo u/CREATOR/..* . This helps to keep user-created repos separate, and avoid name clashes in some far-fetched scenarios).","title":"giving users their own repos"},{"location":"odds-and-ends.html#administering-gitolite-directly-on-the-server","text":"The main use of managing gitolite via the admin repo is that you get to version control the access rules. But for large sites, there's another use: you can share the admin load with more people, without having to give all of them shell access on the server. However, people who use puppet and similar systems already have a conf versioning and management system. And they'd like to continue to use that to manage gitolite repos and users, rather than be forced to do it through the gitolite-admin repo. Such sites don't really need the admin repo at all, so here's how to get rid of it and run things directly on the server (which you can script into your puppet or similar software quite easily). First the one-time stuff: install the software as normal run gitolite setup -a dummy instead of the normal setup command delete (or move away) ~/repositories/gitolite-admin.git edit ~/.gitolite/conf/gitolite.conf and remove the gitolite-admin repo and its access line. mkdir ~/.gitolite/keydir (because \"setup -a\" does not create it, but you will need it later to add keys). run gitolite compile; gitolite trigger POST_COMPILE To manage gitolite, you can directly edit files in ~/.gitolite (or cause puppet to place files there), and then run the commands in the last step above. For example: copy someone's pubkey file to ~/.gitolite/keydir edit ~/.gitolite/conf/gitolite.conf and add a repo or three, giving access to some user(s) run gitolite compile; gitolite trigger POST_COMPILE That's it.","title":"administering gitolite directly on the server"},{"location":"options.html","text":"gitolite options \uf0c1 Some gitolite features are enabled, or gitolite's behaviour changed, by setting \"options\". A line like option foo = 1 is really just syntactic sugar for config gitolite-options.foo = 1 , so everything in the git-config page also applies here (especially the bit about overriding config values . However , these values are not written into git's own config file, so git (or other programs running git config ) will not see them. You can only query them using gitolite git-config , where they will appear in full in the output. Options are set by repo. The syntax is very simple: option foo.bar = baz Of course this is useless if some other part of gitolite, or some external command, is not querying for the option key 'foo.bar'! Options are therefore documented in the section/page they belong in, not here. Here are some examples, although this list is not exhaustive: Ask gitolite to honor deny rules during the pre-git check also. Options related to mirroring -- tell gitolite who is the master server, and who are the copies, for each repo. The optional post-compile trigger update-gitweb-daemon-from-options allows you to use options instead of special usernames gitweb and daemon to determine access for those tools. You can set repo-specific environment variables for triggers and hooks to test, which is very useful. Here's how to disable an option from a single repo if it was enabled earlier in a group (which you might guess from reading the git-config page): @g = r1 r2 r3 repo @g option gitweb = 1 # but repo r2 should not be accessible by gitweb repo r2 option gitweb = \"\"","title":"gitolite options"},{"location":"options.html#gitolite-options","text":"Some gitolite features are enabled, or gitolite's behaviour changed, by setting \"options\". A line like option foo = 1 is really just syntactic sugar for config gitolite-options.foo = 1 , so everything in the git-config page also applies here (especially the bit about overriding config values . However , these values are not written into git's own config file, so git (or other programs running git config ) will not see them. You can only query them using gitolite git-config , where they will appear in full in the output. Options are set by repo. The syntax is very simple: option foo.bar = baz Of course this is useless if some other part of gitolite, or some external command, is not querying for the option key 'foo.bar'! Options are therefore documented in the section/page they belong in, not here. Here are some examples, although this list is not exhaustive: Ask gitolite to honor deny rules during the pre-git check also. Options related to mirroring -- tell gitolite who is the master server, and who are the copies, for each repo. The optional post-compile trigger update-gitweb-daemon-from-options allows you to use options instead of special usernames gitweb and daemon to determine access for those tools. You can set repo-specific environment variables for triggers and hooks to test, which is very useful. Here's how to disable an option from a single repo if it was enabled earlier in a group (which you might guess from reading the git-config page): @g = r1 r2 r3 repo @g option gitweb = 1 # but repo r2 should not be accessible by gitweb repo r2 option gitweb = \"\"","title":"gitolite options"},{"location":"overview.html","text":"gitolite overview \uf0c1 Gitolite allows you to setup git hosting on a central server, with fine-grained access control and many more powerful features. what is gitolite? \uf0c1 Gitolite is an access control layer on top of git. Here are the features that most people see: Use a single unix user (\"real\" user) on the server. Provide access to many gitolite users: they are not \"real\" users, so they do not get shell access. Control access to many git repositories: read access controlled at the repo level, write access controlled at the branch/tag/file/directory level, including who can rewind, create, and delete branches/tags. Can be installed without root access, assuming git and perl are already installed. Authentication is most commonly done using sshd, but you can also use \"smart http\" mode if you prefer (this may require root access for the initial setup). why might you need it? \uf0c1 access control \uf0c1 Git by itself does not do any access control -- it relies on the transport medium to do authentication (\"who are you?\"), and on OS file permissions to do authorisation (\"what are you allowed to do?\"). Git also comes with a program called \"git-shell\" which can act as a restricted login shell if you don't want users getting a proper shell. Using this and judicious use of Unix groups, you can allow some people read-only access while others get read-write access, etc. This is probably sufficient if your needs are simple and don't change too often. However, gitolite does this much better, and offers many more features. basic use case \uf0c1 Gitolite is useful in any server that is going to host multiple git repositories, each with many developers, where \"anyone can do anything to any repo\" is not a good idea. Here're two examples to illustrate. This first example has 3 repos and 3 developers with different levels of access to each repo. It's a very simple, readable, syntax, and makes it easy to answer questions like \"what repos can bob push to\" (answer: only 'bar'). repo foo RW+ = alice RW = carol repo bar RW+ = bob R = alice repo baz RW+ = carol R = alice bob This second example allows different levels of access to different branches and tags for different developers: repo foo RW+ = alice RW master = bob RW+ dev/ = bob RW refs/heads/tags/v[0-9] = ashok other features \uf0c1 Gitolite has many more features, as you might guess from the amount of documentation (see links in the nav bar at the top). Here's a quick sample: Very powerful rule language (rules most often based on branch/tag name, or files/directories touched, but many other factors can be used, such as size of changed files, number of changed files, etc.). Convenience features for writing the rules (repo groups, user groups, get user group info from LDAP, include files, macros...) Highly customisable and scriptable, especially custom commands for users. Many built-in commands and options. Powerful and flexible mirroring system. Users can create their own repos and set access rights (if you allow them). alternatives to gitolite \uf0c1 unix permissions and ACLs \uf0c1 If you're a masochist, you could probably do example 1 with Unix permissions and facls. But you can't do example 2 -- git is not designed to allow that! Here are some other disadvantages of the Unix ACL method: Every user needs a userid and password on the server. Changing access rights involves complex usermod -G ... mumblings (I.e., the \"pain\" mentioned above is not a one-time pain!) Viewing the current set of permissions requires running multiple commands to list directories and their permissions/ownerships, users and their group memberships, and then correlating all these manually. Auditing historical permissions or permission changes is impossible. Gerrit Code Review \uf0c1 The best real alternative to gitolite is Gerrit Code Review. If code review is an essential part of your workflow, you should use Gerrit. Here're some high level differences between gitolite and Gerrit (as of about mid-2012 or so): Size : 3000+ lines of perl versus of 56,000+ lines of Java Architecture : Gitolite sits on top of \"standard\" git and openssh, which are assumed to already be installed. Gerrit includes its own git stack (jgit) and sshd (Apache Mina). In Java tradition, they all come bundled together. (Corollary: As far as I know jgit does not support the same hooks that 'man githooks' talks about). Gitolite uses a plain text config file; gerrit uses a database. User view : Gitolite is invisible to users except when access is denied. Gerrit is much more visible to devs because of its role in enforcing code review, approvals, and workflow. On a related note, gitolite does not do anything special with signed or annotated tags, nor does it check author/committer identity. However, it is trivial to add your own code to do either (or if someone contributes it, to just \"enable\" what ships with gitolite in a disabled state). gitlab, gogs, gitblit, and others \uf0c1 There are several alternatives which offer a full web-based GUI, for administrators or users or both. They also offer a lot of enterprise features (for example LDAP integration), and social coding features (issue trackers, discussions, comments on code, pull requests, etc.) However, they are unlikely to be as customisable as gitolite is, if you care about that sort of thing. how does it work? \uf0c1 At a very high level, gitolite relies on sshd (or httpd if you're using the smart http mode) to authenticate the user and supply the username. Based on this, and the command given, it decides whether to allow or deny the request. Consider a push command in ssh mode. Normally (i.e., without gitolite) this would invoke git-receive-pack on the server, and the flow would be somewhat like this (left side is client, right side is server): When you install gitolite and setup the user, gitolite sets up ssh to force the gitolite-shell command to run first, instead of the command requested: The gitolite-shell program uses the username supplied by ssh, and the repo name in the command, to decide if the user has write access to the repo or not. If he does have some write access, git-receive-pack is called, but that's not the end of the story. The branch/tag/file(s) he is pushing also need to be checked, and gitolite sets up the update hook on the repo to do that. A more detailed explanation, with figures, is here . who uses it? \uf0c1 If you're using gitolite and find it very useful in some way, I would love to describe your use of it or add a link to your own description of it here. Of course, you can anonymise it as much as you need to. The Fedora Project controls access to over 10,000 package management repositories accessed by over 1,000 package maintainers using gitolite . This is probably the largest confirmed gitolite installation anywhere. The whole \"big-config\" option back in v2 (in v3 this is the default!) was initially done for them (their config file was so big that without the big-config changes gitolite would just run out of memory and die!). The KDE project uses gitolite (in combination with redmine for issue tracking and reviewboard for code review). Apart from the usual access control, the KDE folks are heavy users of the \"ad hoc repo creation\" features enabled by wildrepos and the accompanying commands. Several of the changes to the \"admin defined commands\" were also inspired by KDE's needs. See section 5 and section 6 of the above linked page for details. Prof. Hiren Patel of the University of Waterloo is responsible for the existence of the fairly popular \" wildrepos \" feature. The documentation was pretty much written with his use case in mind, but of course it turns out to be useful for a lot of people, as you can see from the previous para on KDE's use of gitolite. In fact, he surprised the heck out of me once by saying that if it hadn't been for this feature, he might not have used git itself -- which is a pretty serious compliment if you think about the magnitude of the git project and my little one-man show! He explains his use of it here . Gentoo Linux has just moved their git repositories from gitosis to gitolite. There are about 200 repositories, some of them are the so called overlays , official and unofficial/user overlays, plus several developer and project repositories, used by more than 1000 people. That number will be increased in the near future, as they are going to migrate some of their CVS/SVN repositories there, plus they are offering overlays hosting for users as well. kernel.org , the official distribution point for the Linux kernel, is the latest (as of 2011-10) high-visibility installation. According to this email to the lkml, kernel.org decided to use gitolite for access controlling their git repos. Their FAQ entry describes at a high level why they chose gitolite. This move also prompted the first ever security audit of gitolite by an outside party. Gitolite did great; see here for details. [NOTE: v3 has not had such an audit yet; if you did one, please let me know what you found. If you want to do one and need clarifications on anything or general background let me know]. In addition, kernel.org was responsible for a serious rethink of a few rough edges in gitolite, and smoothing them out was fun (the \"playing with gitolite\" stuff, making the test suite simpler, \"deny\" rules for the entire repo). The Mageia Project is using gitolite 3 to manage its git repositories and access control. The repositories are defined in yaml files. A tool called mgagit has been created and is repsonsible for the generation of the gitolite configuration from the yaml repos definitions, and the extraction of users' ssh keys from an ldap directory into the gitolite configuration. Gitolite and mgagit are installed using rpm packages and a puppet module . A general note: if you see the list of high-profile users above, you will see that gitolite benefits as much as they do; possibly more. Note: GIT is a trademark of Software Freedom Conservancy and my use of \"Gitolite\" is under license.","title":"overview"},{"location":"overview.html#gitolite-overview","text":"Gitolite allows you to setup git hosting on a central server, with fine-grained access control and many more powerful features.","title":"gitolite overview"},{"location":"overview.html#what-is-gitolite","text":"Gitolite is an access control layer on top of git. Here are the features that most people see: Use a single unix user (\"real\" user) on the server. Provide access to many gitolite users: they are not \"real\" users, so they do not get shell access. Control access to many git repositories: read access controlled at the repo level, write access controlled at the branch/tag/file/directory level, including who can rewind, create, and delete branches/tags. Can be installed without root access, assuming git and perl are already installed. Authentication is most commonly done using sshd, but you can also use \"smart http\" mode if you prefer (this may require root access for the initial setup).","title":"what is gitolite?"},{"location":"overview.html#why-might-you-need-it","text":"","title":"why might you need it?"},{"location":"overview.html#access-control","text":"Git by itself does not do any access control -- it relies on the transport medium to do authentication (\"who are you?\"), and on OS file permissions to do authorisation (\"what are you allowed to do?\"). Git also comes with a program called \"git-shell\" which can act as a restricted login shell if you don't want users getting a proper shell. Using this and judicious use of Unix groups, you can allow some people read-only access while others get read-write access, etc. This is probably sufficient if your needs are simple and don't change too often. However, gitolite does this much better, and offers many more features.","title":"access control"},{"location":"overview.html#basic-use-case","text":"Gitolite is useful in any server that is going to host multiple git repositories, each with many developers, where \"anyone can do anything to any repo\" is not a good idea. Here're two examples to illustrate. This first example has 3 repos and 3 developers with different levels of access to each repo. It's a very simple, readable, syntax, and makes it easy to answer questions like \"what repos can bob push to\" (answer: only 'bar'). repo foo RW+ = alice RW = carol repo bar RW+ = bob R = alice repo baz RW+ = carol R = alice bob This second example allows different levels of access to different branches and tags for different developers: repo foo RW+ = alice RW master = bob RW+ dev/ = bob RW refs/heads/tags/v[0-9] = ashok","title":"basic use case"},{"location":"overview.html#other-features","text":"Gitolite has many more features, as you might guess from the amount of documentation (see links in the nav bar at the top). Here's a quick sample: Very powerful rule language (rules most often based on branch/tag name, or files/directories touched, but many other factors can be used, such as size of changed files, number of changed files, etc.). Convenience features for writing the rules (repo groups, user groups, get user group info from LDAP, include files, macros...) Highly customisable and scriptable, especially custom commands for users. Many built-in commands and options. Powerful and flexible mirroring system. Users can create their own repos and set access rights (if you allow them).","title":"other features"},{"location":"overview.html#alternatives-to-gitolite","text":"","title":"alternatives to gitolite"},{"location":"overview.html#unix-permissions-and-acls","text":"If you're a masochist, you could probably do example 1 with Unix permissions and facls. But you can't do example 2 -- git is not designed to allow that! Here are some other disadvantages of the Unix ACL method: Every user needs a userid and password on the server. Changing access rights involves complex usermod -G ... mumblings (I.e., the \"pain\" mentioned above is not a one-time pain!) Viewing the current set of permissions requires running multiple commands to list directories and their permissions/ownerships, users and their group memberships, and then correlating all these manually. Auditing historical permissions or permission changes is impossible.","title":"unix permissions and ACLs"},{"location":"overview.html#gerrit-code-review","text":"The best real alternative to gitolite is Gerrit Code Review. If code review is an essential part of your workflow, you should use Gerrit. Here're some high level differences between gitolite and Gerrit (as of about mid-2012 or so): Size : 3000+ lines of perl versus of 56,000+ lines of Java Architecture : Gitolite sits on top of \"standard\" git and openssh, which are assumed to already be installed. Gerrit includes its own git stack (jgit) and sshd (Apache Mina). In Java tradition, they all come bundled together. (Corollary: As far as I know jgit does not support the same hooks that 'man githooks' talks about). Gitolite uses a plain text config file; gerrit uses a database. User view : Gitolite is invisible to users except when access is denied. Gerrit is much more visible to devs because of its role in enforcing code review, approvals, and workflow. On a related note, gitolite does not do anything special with signed or annotated tags, nor does it check author/committer identity. However, it is trivial to add your own code to do either (or if someone contributes it, to just \"enable\" what ships with gitolite in a disabled state).","title":"Gerrit Code Review"},{"location":"overview.html#gitlab-gogs-gitblit-and-others","text":"There are several alternatives which offer a full web-based GUI, for administrators or users or both. They also offer a lot of enterprise features (for example LDAP integration), and social coding features (issue trackers, discussions, comments on code, pull requests, etc.) However, they are unlikely to be as customisable as gitolite is, if you care about that sort of thing.","title":"gitlab, gogs, gitblit, and others"},{"location":"overview.html#how-does-it-work","text":"At a very high level, gitolite relies on sshd (or httpd if you're using the smart http mode) to authenticate the user and supply the username. Based on this, and the command given, it decides whether to allow or deny the request. Consider a push command in ssh mode. Normally (i.e., without gitolite) this would invoke git-receive-pack on the server, and the flow would be somewhat like this (left side is client, right side is server): When you install gitolite and setup the user, gitolite sets up ssh to force the gitolite-shell command to run first, instead of the command requested: The gitolite-shell program uses the username supplied by ssh, and the repo name in the command, to decide if the user has write access to the repo or not. If he does have some write access, git-receive-pack is called, but that's not the end of the story. The branch/tag/file(s) he is pushing also need to be checked, and gitolite sets up the update hook on the repo to do that. A more detailed explanation, with figures, is here .","title":"how does it work?"},{"location":"overview.html#who-uses-it","text":"If you're using gitolite and find it very useful in some way, I would love to describe your use of it or add a link to your own description of it here. Of course, you can anonymise it as much as you need to. The Fedora Project controls access to over 10,000 package management repositories accessed by over 1,000 package maintainers using gitolite . This is probably the largest confirmed gitolite installation anywhere. The whole \"big-config\" option back in v2 (in v3 this is the default!) was initially done for them (their config file was so big that without the big-config changes gitolite would just run out of memory and die!). The KDE project uses gitolite (in combination with redmine for issue tracking and reviewboard for code review). Apart from the usual access control, the KDE folks are heavy users of the \"ad hoc repo creation\" features enabled by wildrepos and the accompanying commands. Several of the changes to the \"admin defined commands\" were also inspired by KDE's needs. See section 5 and section 6 of the above linked page for details. Prof. Hiren Patel of the University of Waterloo is responsible for the existence of the fairly popular \" wildrepos \" feature. The documentation was pretty much written with his use case in mind, but of course it turns out to be useful for a lot of people, as you can see from the previous para on KDE's use of gitolite. In fact, he surprised the heck out of me once by saying that if it hadn't been for this feature, he might not have used git itself -- which is a pretty serious compliment if you think about the magnitude of the git project and my little one-man show! He explains his use of it here . Gentoo Linux has just moved their git repositories from gitosis to gitolite. There are about 200 repositories, some of them are the so called overlays , official and unofficial/user overlays, plus several developer and project repositories, used by more than 1000 people. That number will be increased in the near future, as they are going to migrate some of their CVS/SVN repositories there, plus they are offering overlays hosting for users as well. kernel.org , the official distribution point for the Linux kernel, is the latest (as of 2011-10) high-visibility installation. According to this email to the lkml, kernel.org decided to use gitolite for access controlling their git repos. Their FAQ entry describes at a high level why they chose gitolite. This move also prompted the first ever security audit of gitolite by an outside party. Gitolite did great; see here for details. [NOTE: v3 has not had such an audit yet; if you did one, please let me know what you found. If you want to do one and need clarifications on anything or general background let me know]. In addition, kernel.org was responsible for a serious rethink of a few rough edges in gitolite, and smoothing them out was fun (the \"playing with gitolite\" stuff, making the test suite simpler, \"deny\" rules for the entire repo). The Mageia Project is using gitolite 3 to manage its git repositories and access control. The repositories are defined in yaml files. A tool called mgagit has been created and is repsonsible for the generation of the gitolite configuration from the yaml repos definitions, and the extraction of users' ssh keys from an ldap directory into the gitolite configuration. Gitolite and mgagit are installed using rpm packages and a puppet module . A general note: if you see the list of high-profile users above, you will see that gitolite benefits as much as they do; possibly more. Note: GIT is a trademark of Software Freedom Conservancy and my use of \"Gitolite\" is under license.","title":"who uses it?"},{"location":"package.html","text":"packaging gitolite \uf0c1 Gitolite has broad similarities to git in terms of packaging requirements. Git has 150 executables to marshal and put somewhere. Gitolite has the directories commands , lib , syntactic-sugar , triggers , and VREF . It doesn't matter what this directory is. As an example, Fedora keeps git's 150 executables in /usr/libexec/git-core, so /usr/libexec/gitolite may be a good choice; it's upto you. The rest of this section will assume you chose /usr/libexec/gitolite as the location, and that this location contains the 5 directories named above . Git has the GIT_EXEC_PATH env var to point to this directory. Gitolite has GL_BINDIR . However, in git, the \"make\" process embeds a suitable default into the binary, making the env var optional. With that said, here's one way to package gitolite: Put the executable gitolite somewhere in PATH. Put the executable gitolite-shell in /usr/libexec/gitolite (along with those 5 directories). Change the 2 assignments to $ENV{GL_BINDIR} , one in 'gitolite', one in 'gitolite-shell', to \"/usr/libexec/gitolite\" from $FindBin::RealBin . This is equivalent to \"make\" embedding the exec-path into the executable. OR Put both executables gitolite and gitolite-shell also into /usr/libexec/gitolite (i.e., as siblings to the 5 directories mentioned above). Then symlink /usr/libexec/gitolite/gitolite to some directory in the PATH. Do not copy it; it must be a symlink. Gitolite will find the exec-path by following the symlink. The Gitolite subdirectory in /usr/libexec/gitolite/lib can stay right there, OR , if your distro policies don't allow that, can be put in any directory in perl's @INC path (such as /usr/share/perl5/vendor_perl ). Finally, a file called /usr/libexec/gitolite/VERSION must contain a suitable version string.","title":"packaging gitolite"},{"location":"package.html#packaging-gitolite","text":"Gitolite has broad similarities to git in terms of packaging requirements. Git has 150 executables to marshal and put somewhere. Gitolite has the directories commands , lib , syntactic-sugar , triggers , and VREF . It doesn't matter what this directory is. As an example, Fedora keeps git's 150 executables in /usr/libexec/git-core, so /usr/libexec/gitolite may be a good choice; it's upto you. The rest of this section will assume you chose /usr/libexec/gitolite as the location, and that this location contains the 5 directories named above . Git has the GIT_EXEC_PATH env var to point to this directory. Gitolite has GL_BINDIR . However, in git, the \"make\" process embeds a suitable default into the binary, making the env var optional. With that said, here's one way to package gitolite: Put the executable gitolite somewhere in PATH. Put the executable gitolite-shell in /usr/libexec/gitolite (along with those 5 directories). Change the 2 assignments to $ENV{GL_BINDIR} , one in 'gitolite', one in 'gitolite-shell', to \"/usr/libexec/gitolite\" from $FindBin::RealBin . This is equivalent to \"make\" embedding the exec-path into the executable. OR Put both executables gitolite and gitolite-shell also into /usr/libexec/gitolite (i.e., as siblings to the 5 directories mentioned above). Then symlink /usr/libexec/gitolite/gitolite to some directory in the PATH. Do not copy it; it must be a symlink. Gitolite will find the exec-path by following the symlink. The Gitolite subdirectory in /usr/libexec/gitolite/lib can stay right there, OR , if your distro policies don't allow that, can be put in any directory in perl's @INC path (such as /usr/share/perl5/vendor_perl ). Finally, a file called /usr/libexec/gitolite/VERSION must contain a suitable version string.","title":"packaging gitolite"},{"location":"perf.html","text":"gitolite performance \uf0c1 TOP TIP: If you have more than 2000 or so repos, then you should be using v3.2 or later; there was a bit of code that went in there that makes a huge difference for really large sites. factors affecting gitolite performance \uf0c1 A lot of the following discussion involves understanding these factors: the number of lines in gitolite.conf (plus all its \"include\" files, if any). the number of normal repos in the conf. A normal repo is one that is directly named in a repo ... line. repo foo bar # ...rules... The rules for a normal repo is compiled into a file called gl-conf in the repo directory (i.e., one gl-conf file per normal repo). the number of group repos -- repos that are part of repo groups : @foss = git gitolite linux repo @foss # ...rules... The rules for group repos are compiled into a \"common\" compiled rules file which resides in ~/.gitolite/conf . the number of wild repos -- repos that match a wild repo pattern and were created by a user. repo dev/CREATOR/..* C = @team # ...rules... # actual repos created by users using git clone/push commands The compiled rules for wild repos also go into the \"common\" compiled rules file. However, these rules often consist of just \"role names\" , not actual user names. The user who owns the repo will map other users to various roles by running the perms command. This mapping is saved in a file called gl-perms in the repo directory. types of performance issues \uf0c1 Gitolite performance can be discussed in four different scenarios: normal git activity \uf0c1 A user accesses a git repo using git clone, fetch, push, etc. Gitolite is heavily optimised for the day to day \"developer\" activity by users. You should never have any issues with this, regardless of what mix of factors (affecting performance; see above) you have. admin push \uf0c1 An admin does a \"push\" to the \"gitolite-admin\" repo (or does the equivalent when administering gitolite directly on the server ). What happens then can be divided into two distinct parts. gitolite compile \uf0c1 The first part is gitolite compile . This is influenced by the conf file size as well as the number of normal repos. For each normal repo, gitolite has to write the gl-conf file in that repo's directory. That's a whole bunch of small-file writes. Over the past few weeks (as of Oct 2017), mainly driven by Fedora's mammoth 560,000+ line conf file containing 42,000 or so repos, there have been a couple of attempts to mitigate this. Extend the wild repos concept: See the templates document for details on this. The section that is directly relevant to the topic of performance is the one dealing with \"bypassing gitolite.conf for huge sites\", but really, you should read the whole document in order to understand what is happening there. Note Although the templates feature was inspired by performance issues, I now realise it's a much nicer way to organise repos and rules, and -- on my comparatively puny production setup -- I have reorganised all the rules to use templates instead. The result is much easier to maintain, because I can farm out the maintenance to folks who are less gitolite-savvy. See the \"advantages\" section in that page for more. Compile repo rules separately: A much less interesting, probably even somewhat kludgey, outcome of the Fedora exercise was the compile-1 command. It's in contrib because I do not encourage its use unless you really really ( really! ) need it. Instructions and caveats are in the source file itself. gitolite trigger POST_COMPILE \uf0c1 The second part runs all the POST_COMPILE triggers scripts. On a default installation, this includes maintaining ~/.ssh/authorised_keys , updating gitweb and daemon permissions, and updating \"config\" values. This is influenced by the total number of repos in the system (normal and other repos), and what options are enabled in your ~/.gitolite.rc file. Many of these these require scanning all the repositories and doing something to each of them (see \"scan ALL repos\" section later). For example, the trigger script that updates the \"projects.list\" file for gitweb needs to check every repo to see if the user gitweb is allowed R ead access to it. new wild repo \uf0c1 A user creates a brand new \"wild\" repo. If you use only the default set of options enabled in the rc file, this should be pretty fast, though some of the non-default options may still be slow. However, the commit that finally fixed this issue for the default options is pretty recent as of the time of writing. In tag terms, you should see it in 3.6.8. If you're really affected by this, bug me on the mailing list to make a release, and then bug your package maintainers :-) Or just upgrade from github! How can you tell which program is slowing you down? Look in the log file after a user runs a wild repo create -- any subtask of that 'create' that takes more than a second is a problem. Send details to the mailing list so we can discuss and fix whatever can be fixed. scan ALL repos \uf0c1 There are a few activities that scan all repos, looking for a given user's permission on each of them: a user runs the info command a user accesses gitweb on a site where repo specific authorisation is in place the POST_COMPILE triggers in an \"admin push\" are invoked (as briefly explained above). In general, this is the slowest part of gitolite. It's work load is influenced by two things: the number of normal repos, and the number of wild repos, because (as we saw up above) those are the two types of repos for which certain individual files in the repo directory need to be read. So, on a system with lots of of normal and/or wild repos, this operation needs to read lots of small files (one in each repo directory)... which takes time. And depends on how fast your disk is, too. The appendix has a solution for this, using a perl module called Memoize (comes standard with perl); check down there for details. appendix 1: using memoize \uf0c1 It seems that perl's Memoize module does a great job at helping with the \"scan ALL repos\" use case, at least after the first time a user accesses gitweb or runs the 'info' command. gitweb \uf0c1 To start with, here's tested code to add into gitweb.conf: # ---------------------------------------------------------------------- # caching section use Fcntl; use DB_File; use Memoize; # the actual file on disk my $dbf = \" $rc { GL_ADMIN_BASE } / $ENV { GL_USER } -canread.db \" ; # set up persistence tie ( %disk_cache , ' DB_File ' , $dbf , O_RDWR|O_CREAT, 0666 ) or die \" Tie ' $dbf ' failed: $! \" ; memoize ' can_read ' , SCALAR_CACHE => [ HASH => \\ %disk_cache ]; # ---------------------------------------------------------------------- You can add this at the end of the code linked from the repo specific authorisation section. The maintenance of these cache files is tricky. I suggest: delete all of them when a gitolite-admin push happens (easy enough to add a new POST_COMPILE trigger for it -- a simple 1-line shell script will do) run a cron job at midnight that also does the same thing create a gitolite command (maybe \"flush-canread-cache\"?) to allow a user to flush his/her own cache file. The basic code is pretty simple (you can embellish it with proper error messages etc., if you like): #!/bin/sh [ -n \" $GL_USER \" ] && rm -vf $GL_ADMIN_BASE / $GL_USER -canread.db The biggest complication is \"wild\" repos and users running the \"perms\" command. That gets a little messy (you'd have to add code to the perms command to delete just this repo, from all user's cache files!), so I suggest ignoring this. The worst that can happen is that, until the next morning (when your cron job fires) (a) he retains access to a repo that he has been removed from, and (b) he does not get access to a repo to which he has been just added. The first issue is unlikely to generate any complaints from the users, though you may have to run it by your security team (but remember these are user-assigned privileges, so just pretend the user did not get around to removing the permission till the next morning!) The second is easily solved by asking them to run that command we created. That's it. the info command \uf0c1 TODO: see if the info command can also benefit from something similar!","title":"performance"},{"location":"perf.html#gitolite-performance","text":"TOP TIP: If you have more than 2000 or so repos, then you should be using v3.2 or later; there was a bit of code that went in there that makes a huge difference for really large sites.","title":"gitolite performance"},{"location":"perf.html#factors-affecting-gitolite-performance","text":"A lot of the following discussion involves understanding these factors: the number of lines in gitolite.conf (plus all its \"include\" files, if any). the number of normal repos in the conf. A normal repo is one that is directly named in a repo ... line. repo foo bar # ...rules... The rules for a normal repo is compiled into a file called gl-conf in the repo directory (i.e., one gl-conf file per normal repo). the number of group repos -- repos that are part of repo groups : @foss = git gitolite linux repo @foss # ...rules... The rules for group repos are compiled into a \"common\" compiled rules file which resides in ~/.gitolite/conf . the number of wild repos -- repos that match a wild repo pattern and were created by a user. repo dev/CREATOR/..* C = @team # ...rules... # actual repos created by users using git clone/push commands The compiled rules for wild repos also go into the \"common\" compiled rules file. However, these rules often consist of just \"role names\" , not actual user names. The user who owns the repo will map other users to various roles by running the perms command. This mapping is saved in a file called gl-perms in the repo directory.","title":"factors affecting gitolite performance"},{"location":"perf.html#types-of-performance-issues","text":"Gitolite performance can be discussed in four different scenarios:","title":"types of performance issues"},{"location":"perf.html#normal-git-activity","text":"A user accesses a git repo using git clone, fetch, push, etc. Gitolite is heavily optimised for the day to day \"developer\" activity by users. You should never have any issues with this, regardless of what mix of factors (affecting performance; see above) you have.","title":"normal git activity"},{"location":"perf.html#admin-push","text":"An admin does a \"push\" to the \"gitolite-admin\" repo (or does the equivalent when administering gitolite directly on the server ). What happens then can be divided into two distinct parts.","title":"admin push"},{"location":"perf.html#gitolite-compile","text":"The first part is gitolite compile . This is influenced by the conf file size as well as the number of normal repos. For each normal repo, gitolite has to write the gl-conf file in that repo's directory. That's a whole bunch of small-file writes. Over the past few weeks (as of Oct 2017), mainly driven by Fedora's mammoth 560,000+ line conf file containing 42,000 or so repos, there have been a couple of attempts to mitigate this. Extend the wild repos concept: See the templates document for details on this. The section that is directly relevant to the topic of performance is the one dealing with \"bypassing gitolite.conf for huge sites\", but really, you should read the whole document in order to understand what is happening there. Note Although the templates feature was inspired by performance issues, I now realise it's a much nicer way to organise repos and rules, and -- on my comparatively puny production setup -- I have reorganised all the rules to use templates instead. The result is much easier to maintain, because I can farm out the maintenance to folks who are less gitolite-savvy. See the \"advantages\" section in that page for more. Compile repo rules separately: A much less interesting, probably even somewhat kludgey, outcome of the Fedora exercise was the compile-1 command. It's in contrib because I do not encourage its use unless you really really ( really! ) need it. Instructions and caveats are in the source file itself.","title":"gitolite compile"},{"location":"perf.html#gitolite-trigger-post_compile","text":"The second part runs all the POST_COMPILE triggers scripts. On a default installation, this includes maintaining ~/.ssh/authorised_keys , updating gitweb and daemon permissions, and updating \"config\" values. This is influenced by the total number of repos in the system (normal and other repos), and what options are enabled in your ~/.gitolite.rc file. Many of these these require scanning all the repositories and doing something to each of them (see \"scan ALL repos\" section later). For example, the trigger script that updates the \"projects.list\" file for gitweb needs to check every repo to see if the user gitweb is allowed R ead access to it.","title":"gitolite trigger POST_COMPILE"},{"location":"perf.html#new-wild-repo","text":"A user creates a brand new \"wild\" repo. If you use only the default set of options enabled in the rc file, this should be pretty fast, though some of the non-default options may still be slow. However, the commit that finally fixed this issue for the default options is pretty recent as of the time of writing. In tag terms, you should see it in 3.6.8. If you're really affected by this, bug me on the mailing list to make a release, and then bug your package maintainers :-) Or just upgrade from github! How can you tell which program is slowing you down? Look in the log file after a user runs a wild repo create -- any subtask of that 'create' that takes more than a second is a problem. Send details to the mailing list so we can discuss and fix whatever can be fixed.","title":"new wild repo"},{"location":"perf.html#scan-all-repos","text":"There are a few activities that scan all repos, looking for a given user's permission on each of them: a user runs the info command a user accesses gitweb on a site where repo specific authorisation is in place the POST_COMPILE triggers in an \"admin push\" are invoked (as briefly explained above). In general, this is the slowest part of gitolite. It's work load is influenced by two things: the number of normal repos, and the number of wild repos, because (as we saw up above) those are the two types of repos for which certain individual files in the repo directory need to be read. So, on a system with lots of of normal and/or wild repos, this operation needs to read lots of small files (one in each repo directory)... which takes time. And depends on how fast your disk is, too. The appendix has a solution for this, using a perl module called Memoize (comes standard with perl); check down there for details.","title":"scan ALL repos"},{"location":"perf.html#appendix-1-using-memoize","text":"It seems that perl's Memoize module does a great job at helping with the \"scan ALL repos\" use case, at least after the first time a user accesses gitweb or runs the 'info' command.","title":"appendix 1: using memoize"},{"location":"perf.html#gitweb","text":"To start with, here's tested code to add into gitweb.conf: # ---------------------------------------------------------------------- # caching section use Fcntl; use DB_File; use Memoize; # the actual file on disk my $dbf = \" $rc { GL_ADMIN_BASE } / $ENV { GL_USER } -canread.db \" ; # set up persistence tie ( %disk_cache , ' DB_File ' , $dbf , O_RDWR|O_CREAT, 0666 ) or die \" Tie ' $dbf ' failed: $! \" ; memoize ' can_read ' , SCALAR_CACHE => [ HASH => \\ %disk_cache ]; # ---------------------------------------------------------------------- You can add this at the end of the code linked from the repo specific authorisation section. The maintenance of these cache files is tricky. I suggest: delete all of them when a gitolite-admin push happens (easy enough to add a new POST_COMPILE trigger for it -- a simple 1-line shell script will do) run a cron job at midnight that also does the same thing create a gitolite command (maybe \"flush-canread-cache\"?) to allow a user to flush his/her own cache file. The basic code is pretty simple (you can embellish it with proper error messages etc., if you like): #!/bin/sh [ -n \" $GL_USER \" ] && rm -vf $GL_ADMIN_BASE / $GL_USER -canread.db The biggest complication is \"wild\" repos and users running the \"perms\" command. That gets a little messy (you'd have to add code to the perms command to delete just this repo, from all user's cache files!), so I suggest ignoring this. The worst that can happen is that, until the next morning (when your cron job fires) (a) he retains access to a repo that he has been removed from, and (b) he does not get access to a repo to which he has been just added. The first issue is unlikely to generate any complaints from the users, though you may have to run it by your security team (but remember these are user-assigned privileges, so just pretend the user did not get around to removing the permission till the next morning!) The second is easily solved by asking them to run that command we created. That's it.","title":"gitweb"},{"location":"perf.html#the-info-command","text":"TODO: see if the info command can also benefit from something similar!","title":"the info command"},{"location":"quick_install.html","text":"quick install and setup \uf0c1 If your Unix-fu and ssh-fu are good, this will work for you. Otherwise, please click the \"next\" button up there on the right for a more leisurely, detailed, drive through the install process. distro package install \uf0c1 Tip: look for packages called 'gitolite3' before you look for 'gitolite'. install from source \uf0c1 If you're comfortable with Unix and ssh, just copy your ssh public key from your workstation to the hosting user, then do something like this: su - git mkdir -p ~/bin git clone https://github.com/sitaramc/gitolite gitolite/install -ln ~/bin # please use absolute path here gitolite setup -pk yourname.pub Please be sure to read any messages produced by these steps, especially the last one, to make sure things went OK. Notes: If your hosting user is not 'git', substitute accordingly. Make sure ~/bin is in $PATH . If it is not, add something to your shell startup files to make it so. If some other writable directory is in the path, you can use that if you like. Substitute your name for \"yourname\" :-)","title":"(unix/ssh experts) quick install and setup"},{"location":"quick_install.html#quick-install-and-setup","text":"If your Unix-fu and ssh-fu are good, this will work for you. Otherwise, please click the \"next\" button up there on the right for a more leisurely, detailed, drive through the install process.","title":"quick install and setup"},{"location":"quick_install.html#distro-package-install","text":"Tip: look for packages called 'gitolite3' before you look for 'gitolite'.","title":"distro package install"},{"location":"quick_install.html#install-from-source","text":"If you're comfortable with Unix and ssh, just copy your ssh public key from your workstation to the hosting user, then do something like this: su - git mkdir -p ~/bin git clone https://github.com/sitaramc/gitolite gitolite/install -ln ~/bin # please use absolute path here gitolite setup -pk yourname.pub Please be sure to read any messages produced by these steps, especially the last one, to make sure things went OK. Notes: If your hosting user is not 'git', substitute accordingly. Make sure ~/bin is in $PATH . If it is not, add something to your shell startup files to make it so. If some other writable directory is in the path, you can use that if you like. Substitute your name for \"yourname\" :-)","title":"install from source"},{"location":"rc-33.html","text":"the v3.0 to v3.3 \"rc\" file ( $HOME/.gitolite.rc ) \uf0c1 NOTE 1 : if you're using v3.4 and above, see this . NOTE 2 : if you're migrating from v2, there are some settings that MUST be dealt with before running gitolite setup ; please read the migration page and linked pages, and especially the one on \"presetting the rc file\" The rc file for v3 is quite different from that of v2. As before, it is designed to be the only thing unique to your site for most setups. What is new is that it is easy to extend it when new needs come up, without having to touch core gitolite. The rc file is perl code, but you do NOT need to know perl to edit it. Just mind the commas, use single quotes unless you know what you're doing, and make sure the brackets and braces stay matched up! Please look at the ~/.gitolite.rc file that gets installed when you setup gitolite. As you can see there are 3 types of variables in it: simple variables (like UMASK ) lists (like POST_COMPILE , POST_CREATE ) hashes (like ROLES , COMMANDS ) While some of the variables are documented in this file, many of them are not. Their purposes are to be found in each of their individual documentation files around; start with \"non-core\" gitolite . If a setting is used by a command then running that command with '-h' may give you additional information. specific variables \uf0c1 $UMASK , octal, default 0077 The default UMASK that gitolite uses makes all the repos and their contents have rwx------ permissions. People who want to run gitweb realise that this will not do. The correct way to deal with this is to give this variable a value like 0027 (note the syntax: the leading 0 is required), and then make the user running the webserver (apache, www-data, whatever) a member of the 'git' group. If you've already installed gitolite then existing files will have to be fixed up manually (for a umask or 0027, that would be chmod -R g+rX ). This is because umask only affects permissions on newly created files, not existing ones. $GIT_CONFIG_KEYS , string, default empty This setting allows the repo admin to define acceptable gitconfig keys. Gitolite allows you to set git config values using the \"config\" keyword; see here for details and syntax. However, if you are in an installation where the repo admin does not (and should not) have shell access to the server, then allowing him to set arbitrary repo config options may be a security risk -- some config settings allow executing arbitrary commands! You have 3 choices. By default $GIT_CONFIG_KEYS is left empty, which completely disables this feature (meaning you cannot set git configs via the repo config). The second choice is to give it a space separated list of settings you consider safe. (These are actually treated as a set of regular expressions , and any one of them must match). For example: $GIT_CONFIG_KEYS = 'core\\.logAllRefUpdates core\\..*compression'; Each regex should match the whole key (in other words, there is an implicit ^ at the start of each regex, and a $ at the end). The third choice (which you may have guessed already if you're familiar with regular expressions) is to allow anything and everything: $GIT_CONFIG_KEYS = '.*'; ROLES , hash, default keys 'READERS' and 'WRITERS' This specifies the role names allowed to be used by users running the perms command. The wild repos doc has more info on roles. DEFAULT_ROLE_PERMS , string, default undef This sets default wildcard permissions for newly created wildcard repos. If set, this value will be used as the default role permissions for new wildcard repositories. The user can change this value with the perms command as desired after repository creation; it is only a default. Please be aware this is potentially a multi-line variable. In most setups, it will be left undefined. Some installations may benefit from setting it to READERS @all . If you want multiple roles to be assigned by default, here is how. Note double quotes this time, due to the embedded newline, which in turn require the '@' to be escaped: DEFAULT_ROLE_PERMS => \"READERS \\@all\\nWRITERS \\@senior_devs\", LOCAL_CODE , string This is described in more detail here . Please be aware this must be a FULL path , not a relative path.","title":"the 3.3 format rc file"},{"location":"rc-33.html#the-v30-to-v33-rc-file-homegitoliterc","text":"NOTE 1 : if you're using v3.4 and above, see this . NOTE 2 : if you're migrating from v2, there are some settings that MUST be dealt with before running gitolite setup ; please read the migration page and linked pages, and especially the one on \"presetting the rc file\" The rc file for v3 is quite different from that of v2. As before, it is designed to be the only thing unique to your site for most setups. What is new is that it is easy to extend it when new needs come up, without having to touch core gitolite. The rc file is perl code, but you do NOT need to know perl to edit it. Just mind the commas, use single quotes unless you know what you're doing, and make sure the brackets and braces stay matched up! Please look at the ~/.gitolite.rc file that gets installed when you setup gitolite. As you can see there are 3 types of variables in it: simple variables (like UMASK ) lists (like POST_COMPILE , POST_CREATE ) hashes (like ROLES , COMMANDS ) While some of the variables are documented in this file, many of them are not. Their purposes are to be found in each of their individual documentation files around; start with \"non-core\" gitolite . If a setting is used by a command then running that command with '-h' may give you additional information.","title":"the v3.0 to v3.3 \"rc\" file ($HOME/.gitolite.rc)"},{"location":"rc-33.html#specific-variables","text":"$UMASK , octal, default 0077 The default UMASK that gitolite uses makes all the repos and their contents have rwx------ permissions. People who want to run gitweb realise that this will not do. The correct way to deal with this is to give this variable a value like 0027 (note the syntax: the leading 0 is required), and then make the user running the webserver (apache, www-data, whatever) a member of the 'git' group. If you've already installed gitolite then existing files will have to be fixed up manually (for a umask or 0027, that would be chmod -R g+rX ). This is because umask only affects permissions on newly created files, not existing ones. $GIT_CONFIG_KEYS , string, default empty This setting allows the repo admin to define acceptable gitconfig keys. Gitolite allows you to set git config values using the \"config\" keyword; see here for details and syntax. However, if you are in an installation where the repo admin does not (and should not) have shell access to the server, then allowing him to set arbitrary repo config options may be a security risk -- some config settings allow executing arbitrary commands! You have 3 choices. By default $GIT_CONFIG_KEYS is left empty, which completely disables this feature (meaning you cannot set git configs via the repo config). The second choice is to give it a space separated list of settings you consider safe. (These are actually treated as a set of regular expressions , and any one of them must match). For example: $GIT_CONFIG_KEYS = 'core\\.logAllRefUpdates core\\..*compression'; Each regex should match the whole key (in other words, there is an implicit ^ at the start of each regex, and a $ at the end). The third choice (which you may have guessed already if you're familiar with regular expressions) is to allow anything and everything: $GIT_CONFIG_KEYS = '.*'; ROLES , hash, default keys 'READERS' and 'WRITERS' This specifies the role names allowed to be used by users running the perms command. The wild repos doc has more info on roles. DEFAULT_ROLE_PERMS , string, default undef This sets default wildcard permissions for newly created wildcard repos. If set, this value will be used as the default role permissions for new wildcard repositories. The user can change this value with the perms command as desired after repository creation; it is only a default. Please be aware this is potentially a multi-line variable. In most setups, it will be left undefined. Some installations may benefit from setting it to READERS @all . If you want multiple roles to be assigned by default, here is how. Note double quotes this time, due to the embedded newline, which in turn require the '@' to be escaped: DEFAULT_ROLE_PERMS => \"READERS \\@all\\nWRITERS \\@senior_devs\", LOCAL_CODE , string This is described in more detail here . Please be aware this must be a FULL path , not a relative path.","title":"specific variables"},{"location":"rc.html","text":"the \"rc\" file ( $HOME/.gitolite.rc ) \uf0c1 IMPORTANT : if you have a v3.0-v3.3 rc file it is documented here , and it will still work. Please see appendix A below for details. The rc file is designed to be the only thing unique to your site for most setups. The rc file is well commented. Please look at the ~/.gitolite.rc file that gets installed when you setup gitolite. You can always get a default copy for your current version by running gitolite print-default-rc . (Please see appendix A for upgrade instructions.) structure of the rc file \uf0c1 The rc file is perl code, but you do NOT need to know perl to edit it. Just mind the commas, use single quotes unless you know what you're doing, and make sure the brackets and braces stay matched up! As you can see there are 3 types of variables in it: A lot of simple variables (like UMASK , GIT_CONFIG_KEYS , etc.). A hash or two (like ROLES ). And one large list of features to be enabled ( ENABLE ). This page documents only some of them; for most of them it's best to look in the actual rc file or in each of their individual documentation files around; start with \"non-core\" gitolite . If a setting is used by a command then running that command with '-h' may give you additional information. specific variables \uf0c1 $UMASK , octal, default 0077 The default UMASK that gitolite uses gives rwx------ permissions to all the repos and their contents. People who want to run gitweb (or cgit, redmine, etc) realise that this will not do. The correct way to deal with this is to give this variable a value like 0027 (note the syntax: the leading 0 is required), and then make the user running the webserver (apache, www-data, whatever) a member of the 'git' group. If you've already installed gitolite then existing files will have to be fixed up manually (for a umask or 0027, that would be chmod -R g+rX ). This is because umask only affects permissions on newly created files, not existing ones. $GIT_CONFIG_KEYS , string, default empty See the security note at the end of this page for why we do this. This setting allows the repo admin to define acceptable gitconfig keys. Gitolite allows you to set git config values using the \"config\" keyword; see here for details and syntax. You have 3 choices. By default $GIT_CONFIG_KEYS is left empty, which completely disables this feature (meaning you cannot set git configs via the repo config). The second choice is to give it a space separated list of settings you consider safe. (These are actually treated as a set of regular expressions , and any one of them must match). For example: $GIT_CONFIG_KEYS = 'core\\.logAllRefUpdates core\\..*compression'; Each regex should match the whole key (in other words, there is an implicit ^ at the start of each regex, and a $ at the end). The third choice (which you may have guessed already if you're familiar with regular expressions) is to allow anything and everything: $GIT_CONFIG_KEYS = '.*'; ROLES , hash, default keys 'READERS' and 'WRITERS' This specifies the role names allowed to be used by users running the perms command. The wild repos doc has more info on roles. OWNER_ROLENAME , string, default undef (requires v3.5 or later) By default, permissions on a wild repo can only be set by the creator of the repo (using the perms command). But some sites want to allow other people to do this as well. To enable this behaviour, the server admin must first set this variable to some string, say 'OWNERS'. (He must also add 'OWNERS' to the ROLES hash described in the previous bullet). The creator of the repo can then add other users to the OWNERS role using the perms command. The perms command, the new \"owns\" command, and possibly other commands in future, will then give these users the same privileges that they give to the creator of the repo. (Also see the full documentation on roles ). LOCAL_CODE , string This is described in more detail here . Please be aware this must be a FULL path , not a relative path. security note: gitolite admin and shell access \uf0c1 People sometimes ask why this file is also not revision controlled. Here's why. Gitolite maintains a clear distinction between people who can push to the gitolite-admin repo, and people who can get a shell or run arbitrary commands on the server. This may not matter to many (small) sites, but in large installations, the former is often a much larger set of people that you really don't want to give shell access to. Therefore, gitolite tries very hard to make sure that people in the first set are not allowed to do anything that gets them into the second set. If you must revision control it, you can. Just add it to your admin repo, push the change, then replace ~/.gitolite.rc with a symlink to ~/.gitolite/.gitolite.rc . appendix A: upgrading the rc file \uf0c1 First, note that upgrading the rc file is always optional . However, it may help if you want to use any of the new features available in later gitolite releases, in the sense that the lines you need to add may already be present (commented out) in the rc file, so you just need to uncomment them instead of typing them in yourself. If you have a v3.0-v3.3 rc file it is documented here , and it will still work. In fact internally the v3.4 rc file data gets converted to the v3.3 format. There's a simple program to help you upgrade a v3.3 (or prior) rc file (in v3.6.1+ , see contrib/utils/rc-format-v3.4), but it has probably not seen too much testing; please tread carefully and report any problems you find. Upgrading from any v3.4+ rc file to any later gitolite is fairly easy, though still manual. One useful aid is that, as of v3.6.4, you can run gitolite query-rc -d to dump the entire rc structure to STDOUT. This only requires that gitolite be v3.6.4+; your rc file can still be the old one. You can use this to confirm you did not miss something during the manual rc upgrade. dump the current rc by running gitolite query-rc -d > old.dump (assuming you upgraded to v3.6.4 or higher) save your old rc file: mv ~/.gitolite.rc ~/old.gitolite.rc get a \"default\" rc for your current gitolite by running gitolite print-default-rc > ~/.gitolite.rc use your favourite diff-ing editor on the old and the new files and figure out what to carry over from the old rc file to the new one. vimdiff ~/old.gitolite.rc ~/.gitolite.rc # or maybe kdiff3 or whatever This is the tricky part of course! Watch out for configs that got moved around, or in some cases removed completely, not just new config items. dump the new rc by running gitolite query-rc -d > new.dump compare the 2 rc dumps to make sure you've got everything covered. appendix B: making a trigger run after the built-in ones \uf0c1 For most purposes, the section on adding your own scripts to a trigger works fine. But triggers added that way, run before the built-in triggers, which you can also confirm by running gitolite query-rc -d and looking for your trigger in the output. If you need your trigger to run after the built-in ones, it is possible, it's a wee bit more work. Let's say you have a post-compile script called \"my-custom-config\", and you want it to run after the shipped post-compile scripts. Here's what you do: add something like 'my-cust' (could be anything you like, as long as it matches the next step) to the ENABLE list in the rc file. Dont forget the trailing comma if it's not the last element (and in perl you can add a trailing comma even if it is the last element) after the ENABLE list, but still within the RC hash, add this: NON_CORE => \" my-cust POST_COMPILE post-compile/my-custom-config \", The words in caps are fixed. The others you know, and as you can see the \"my-cust\" here matches the \"my-cust\" in the ENABLE list. After you do this, you can test whether it worked or not: gitolite query-rc POST_COMPILE and it should show you what it thinks are the items in that list, in the order it has them.","title":"the \"rc\" file"},{"location":"rc.html#the-rc-file-homegitoliterc","text":"IMPORTANT : if you have a v3.0-v3.3 rc file it is documented here , and it will still work. Please see appendix A below for details. The rc file is designed to be the only thing unique to your site for most setups. The rc file is well commented. Please look at the ~/.gitolite.rc file that gets installed when you setup gitolite. You can always get a default copy for your current version by running gitolite print-default-rc . (Please see appendix A for upgrade instructions.)","title":"the \"rc\" file ($HOME/.gitolite.rc)"},{"location":"rc.html#structure-of-the-rc-file","text":"The rc file is perl code, but you do NOT need to know perl to edit it. Just mind the commas, use single quotes unless you know what you're doing, and make sure the brackets and braces stay matched up! As you can see there are 3 types of variables in it: A lot of simple variables (like UMASK , GIT_CONFIG_KEYS , etc.). A hash or two (like ROLES ). And one large list of features to be enabled ( ENABLE ). This page documents only some of them; for most of them it's best to look in the actual rc file or in each of their individual documentation files around; start with \"non-core\" gitolite . If a setting is used by a command then running that command with '-h' may give you additional information.","title":"structure of the rc file"},{"location":"rc.html#specific-variables","text":"$UMASK , octal, default 0077 The default UMASK that gitolite uses gives rwx------ permissions to all the repos and their contents. People who want to run gitweb (or cgit, redmine, etc) realise that this will not do. The correct way to deal with this is to give this variable a value like 0027 (note the syntax: the leading 0 is required), and then make the user running the webserver (apache, www-data, whatever) a member of the 'git' group. If you've already installed gitolite then existing files will have to be fixed up manually (for a umask or 0027, that would be chmod -R g+rX ). This is because umask only affects permissions on newly created files, not existing ones. $GIT_CONFIG_KEYS , string, default empty See the security note at the end of this page for why we do this. This setting allows the repo admin to define acceptable gitconfig keys. Gitolite allows you to set git config values using the \"config\" keyword; see here for details and syntax. You have 3 choices. By default $GIT_CONFIG_KEYS is left empty, which completely disables this feature (meaning you cannot set git configs via the repo config). The second choice is to give it a space separated list of settings you consider safe. (These are actually treated as a set of regular expressions , and any one of them must match). For example: $GIT_CONFIG_KEYS = 'core\\.logAllRefUpdates core\\..*compression'; Each regex should match the whole key (in other words, there is an implicit ^ at the start of each regex, and a $ at the end). The third choice (which you may have guessed already if you're familiar with regular expressions) is to allow anything and everything: $GIT_CONFIG_KEYS = '.*'; ROLES , hash, default keys 'READERS' and 'WRITERS' This specifies the role names allowed to be used by users running the perms command. The wild repos doc has more info on roles. OWNER_ROLENAME , string, default undef (requires v3.5 or later) By default, permissions on a wild repo can only be set by the creator of the repo (using the perms command). But some sites want to allow other people to do this as well. To enable this behaviour, the server admin must first set this variable to some string, say 'OWNERS'. (He must also add 'OWNERS' to the ROLES hash described in the previous bullet). The creator of the repo can then add other users to the OWNERS role using the perms command. The perms command, the new \"owns\" command, and possibly other commands in future, will then give these users the same privileges that they give to the creator of the repo. (Also see the full documentation on roles ). LOCAL_CODE , string This is described in more detail here . Please be aware this must be a FULL path , not a relative path.","title":"specific variables"},{"location":"rc.html#security-note-gitolite-admin-and-shell-access","text":"People sometimes ask why this file is also not revision controlled. Here's why. Gitolite maintains a clear distinction between people who can push to the gitolite-admin repo, and people who can get a shell or run arbitrary commands on the server. This may not matter to many (small) sites, but in large installations, the former is often a much larger set of people that you really don't want to give shell access to. Therefore, gitolite tries very hard to make sure that people in the first set are not allowed to do anything that gets them into the second set. If you must revision control it, you can. Just add it to your admin repo, push the change, then replace ~/.gitolite.rc with a symlink to ~/.gitolite/.gitolite.rc .","title":"security note: gitolite admin and shell access"},{"location":"rc.html#appendix-a-upgrading-the-rc-file","text":"First, note that upgrading the rc file is always optional . However, it may help if you want to use any of the new features available in later gitolite releases, in the sense that the lines you need to add may already be present (commented out) in the rc file, so you just need to uncomment them instead of typing them in yourself. If you have a v3.0-v3.3 rc file it is documented here , and it will still work. In fact internally the v3.4 rc file data gets converted to the v3.3 format. There's a simple program to help you upgrade a v3.3 (or prior) rc file (in v3.6.1+ , see contrib/utils/rc-format-v3.4), but it has probably not seen too much testing; please tread carefully and report any problems you find. Upgrading from any v3.4+ rc file to any later gitolite is fairly easy, though still manual. One useful aid is that, as of v3.6.4, you can run gitolite query-rc -d to dump the entire rc structure to STDOUT. This only requires that gitolite be v3.6.4+; your rc file can still be the old one. You can use this to confirm you did not miss something during the manual rc upgrade. dump the current rc by running gitolite query-rc -d > old.dump (assuming you upgraded to v3.6.4 or higher) save your old rc file: mv ~/.gitolite.rc ~/old.gitolite.rc get a \"default\" rc for your current gitolite by running gitolite print-default-rc > ~/.gitolite.rc use your favourite diff-ing editor on the old and the new files and figure out what to carry over from the old rc file to the new one. vimdiff ~/old.gitolite.rc ~/.gitolite.rc # or maybe kdiff3 or whatever This is the tricky part of course! Watch out for configs that got moved around, or in some cases removed completely, not just new config items. dump the new rc by running gitolite query-rc -d > new.dump compare the 2 rc dumps to make sure you've got everything covered.","title":"appendix A: upgrading the rc file"},{"location":"rc.html#appendix-b-making-a-trigger-run-after-the-built-in-ones","text":"For most purposes, the section on adding your own scripts to a trigger works fine. But triggers added that way, run before the built-in triggers, which you can also confirm by running gitolite query-rc -d and looking for your trigger in the output. If you need your trigger to run after the built-in ones, it is possible, it's a wee bit more work. Let's say you have a post-compile script called \"my-custom-config\", and you want it to run after the shipped post-compile scripts. Here's what you do: add something like 'my-cust' (could be anything you like, as long as it matches the next step) to the ENABLE list in the rc file. Dont forget the trailing comma if it's not the last element (and in perl you can add a trailing comma even if it is the last element) after the ENABLE list, but still within the RC hash, add this: NON_CORE => \" my-cust POST_COMPILE post-compile/my-custom-config \", The words in caps are fixed. The others you know, and as you can see the \"my-cust\" here matches the \"my-cust\" in the ENABLE list. After you do this, you can test whether it worked or not: gitolite query-rc POST_COMPILE and it should show you what it thinks are the items in that list, in the order it has them.","title":"appendix B: making a trigger run after the built-in ones"},{"location":"regex.html","text":"extremely brief regex overview \uf0c1 Regexes are powerful. Gitolite uses that power as much as it can. If you can't handle that power, hire someone who can and become a manager ;-) That said, here's a very quick overview of the highlights. ^ and $ are called \"anchors\". They anchor the match to the beginning and end of the string respectively. ^foo matches any string starting with 'foo' foo$ matches any string ending with 'foo' ^foo$ matches exact string 'foo'. To be precise, the last one is \"any string starting and ending with the same 'foo'\"; \"foofoo\" does not match. [0-9] is an example of a character class; it matches any single digit. [a-z] matches any lower case alpha, and [0-9a-f] is the range of hex characters. You should now guess what [a-zA-Z0-9_] does. . (the period) is special -- it matches any character. If you want to match an actual period, you need to say \\. . * , ? , and + are quantifiers. They apply to the previous token. a* means \"zero or more 'a' characters\". Similarly a+ means \"one or more\", and a? means \"zero or one\". As a result, .* means \"any number (including zero) of any character\". The previous token need not be a single character; you can use parens to make it longer. (foo)+ matches one or more \"foo\", (like \"foo\", \"foofoo\", \"foofoofoo\", etc.)","title":"regular expressions"},{"location":"regex.html#extremely-brief-regex-overview","text":"Regexes are powerful. Gitolite uses that power as much as it can. If you can't handle that power, hire someone who can and become a manager ;-) That said, here's a very quick overview of the highlights. ^ and $ are called \"anchors\". They anchor the match to the beginning and end of the string respectively. ^foo matches any string starting with 'foo' foo$ matches any string ending with 'foo' ^foo$ matches exact string 'foo'. To be precise, the last one is \"any string starting and ending with the same 'foo'\"; \"foofoo\" does not match. [0-9] is an example of a character class; it matches any single digit. [a-z] matches any lower case alpha, and [0-9a-f] is the range of hex characters. You should now guess what [a-zA-Z0-9_] does. . (the period) is special -- it matches any character. If you want to match an actual period, you need to say \\. . * , ? , and + are quantifiers. They apply to the previous token. a* means \"zero or more 'a' characters\". Similarly a+ means \"one or more\", and a? means \"zero or one\". As a result, .* means \"any number (including zero) of any character\". The previous token need not be a single character; you can use parens to make it longer. (foo)+ matches one or more \"foo\", (like \"foo\", \"foofoo\", \"foofoofoo\", etc.)","title":"extremely brief regex overview"},{"location":"ssh.html","text":"ssh \uf0c1 If you're installing gitolite, you're a \"system admin\", like it or not. If you're using the default ssh mode (i.e., not http mode), ssh is a necessary skill. Please take the time to learn at least enough to get passwordless access working. You must read both these pages before asking for help: Gitolite and ssh explains how gitolite uses openssh features to create any number of virtual users over just one actual (unix) user, and distinguish between them by their public keys. Ssh troubleshooting is a rather long page that, as far as I know, covers almost every known ssh related issue. If you find something missing, send me an email with details so I can update it. ssh related features \uf0c1 This section will explain why an \"ssh issue\" is almost never a \"gitolite issue\", and, indirectly, why I dont get too excited about the former. To start with, as this section of the concepts page explained, Gitolite does not do authentication. It only does authorisation . Let's recap the definition of those words: Authentication is the process of verifying that you are who you claim to be. An authentication system will establish that I am the user \"sitaram\" on my work system. The one behind gmail will similarly establish that I am \"sitaramc\". And so on... Authorisation is the process of asking what you want to do and deciding if you're allowed to do it or not. Now, if you managed to read the gitolite and ssh link above, you know that gitolite is meant to be invoked as: /full/path/to/gitolite-shell some-authenticated-gitolite-username (where the \"gitolite username\" is a \"virtual\" username; it does not have to be, and usually isn't , an actual unix username). As you can see, authentication happens before gitolite is called. but... but... you have all that ssh stuff in gitolite! \uf0c1 No I don't. Not in \"core\" gitolite from v3 onwards :-) The default setup does use ssh keys, but it's only helping you setup ssh-based authentication as a convenience to you . But in fact it is a completely separate program that you can disable (in the rc file) or replace with something else of your choice. For example, in both smart http and ldap-backed sshd, gitolite has no role to play in creating users, setting up their passwords/keys, etc. so you're basically saying you won't support \"X\" \uf0c1 (where \"X\" is some ssh related behaviour change or feature) Well, if it's not a security issue I won't. But since it's no longer part of \"core\" gitolite, I can be much more relaxed about taking patches, or even alternative implementations. While we're on the subject, locking someone out is not a security issue. Even if you lost the admin key , the docs tell you how to recover from such errors. You do need some password based method to get a shell command line on the server, of course. using other authentication systems with gitolite \uf0c1 The bottom line in terms of how to invoke gitolite has been described above, and as long as you manage to do that gitolite won't even know how the authentication was done. Which in turn means you can use whatever authentication scheme you want. It also expects the SSH_ORIGINAL_COMMAND environment variable to contain the full command (typically starting with git-receive-pack or git-upload-pack) that the client sent. Also, when using smart http , things are somewhat different: gitolite uses certain environment variables that it expects httpd to have set up. Even the user name comes from the REMOTE_USER environment variable instead of as a command line argument in this case. However, it has to be an authentication system that is compatible with sshd or httpd in some form. Why? Because the git client accessing the server only knows those 2 protocols to \"speak git\". (Well, the git:// protocol is unauthenticated, and file:// doesn't really apply to this discussion, so we're ignoring those). For example, let's say you have an LDAP-based authentication system somewhere. It is possible to make apache use that to authenticate users, so when a user accesses a git url using https://sitaram:password@git.example.com/repo , it is LDAP that does the actual authentication. [I wouldn't know how to do it but I know it is possible. Patches to this doc explaining how are welcome!] There are also ssh daemons that use LDAP to store the authorised keys (instead of putting them all in ~/.ssh/authorized_keys ). The clients will still need to generate keypairs and send them to the admin, but they can be more centrally stored and perhaps used by other programs or tools simultaneously, which can be useful.","title":"ssh"},{"location":"ssh.html#ssh","text":"If you're installing gitolite, you're a \"system admin\", like it or not. If you're using the default ssh mode (i.e., not http mode), ssh is a necessary skill. Please take the time to learn at least enough to get passwordless access working. You must read both these pages before asking for help: Gitolite and ssh explains how gitolite uses openssh features to create any number of virtual users over just one actual (unix) user, and distinguish between them by their public keys. Ssh troubleshooting is a rather long page that, as far as I know, covers almost every known ssh related issue. If you find something missing, send me an email with details so I can update it.","title":"ssh"},{"location":"ssh.html#ssh-related-features","text":"This section will explain why an \"ssh issue\" is almost never a \"gitolite issue\", and, indirectly, why I dont get too excited about the former. To start with, as this section of the concepts page explained, Gitolite does not do authentication. It only does authorisation . Let's recap the definition of those words: Authentication is the process of verifying that you are who you claim to be. An authentication system will establish that I am the user \"sitaram\" on my work system. The one behind gmail will similarly establish that I am \"sitaramc\". And so on... Authorisation is the process of asking what you want to do and deciding if you're allowed to do it or not. Now, if you managed to read the gitolite and ssh link above, you know that gitolite is meant to be invoked as: /full/path/to/gitolite-shell some-authenticated-gitolite-username (where the \"gitolite username\" is a \"virtual\" username; it does not have to be, and usually isn't , an actual unix username). As you can see, authentication happens before gitolite is called.","title":"ssh related features"},{"location":"ssh.html#but-but-you-have-all-that-ssh-stuff-in-gitolite","text":"No I don't. Not in \"core\" gitolite from v3 onwards :-) The default setup does use ssh keys, but it's only helping you setup ssh-based authentication as a convenience to you . But in fact it is a completely separate program that you can disable (in the rc file) or replace with something else of your choice. For example, in both smart http and ldap-backed sshd, gitolite has no role to play in creating users, setting up their passwords/keys, etc.","title":"but... but... you have all that ssh stuff in gitolite!"},{"location":"ssh.html#so-youre-basically-saying-you-wont-support-x","text":"(where \"X\" is some ssh related behaviour change or feature) Well, if it's not a security issue I won't. But since it's no longer part of \"core\" gitolite, I can be much more relaxed about taking patches, or even alternative implementations. While we're on the subject, locking someone out is not a security issue. Even if you lost the admin key , the docs tell you how to recover from such errors. You do need some password based method to get a shell command line on the server, of course.","title":"so you're basically saying you won't support \"X\""},{"location":"ssh.html#using-other-authentication-systems-with-gitolite","text":"The bottom line in terms of how to invoke gitolite has been described above, and as long as you manage to do that gitolite won't even know how the authentication was done. Which in turn means you can use whatever authentication scheme you want. It also expects the SSH_ORIGINAL_COMMAND environment variable to contain the full command (typically starting with git-receive-pack or git-upload-pack) that the client sent. Also, when using smart http , things are somewhat different: gitolite uses certain environment variables that it expects httpd to have set up. Even the user name comes from the REMOTE_USER environment variable instead of as a command line argument in this case. However, it has to be an authentication system that is compatible with sshd or httpd in some form. Why? Because the git client accessing the server only knows those 2 protocols to \"speak git\". (Well, the git:// protocol is unauthenticated, and file:// doesn't really apply to this discussion, so we're ignoring those). For example, let's say you have an LDAP-based authentication system somewhere. It is possible to make apache use that to authenticate users, so when a user accesses a git url using https://sitaram:password@git.example.com/repo , it is LDAP that does the actual authentication. [I wouldn't know how to do it but I know it is possible. Patches to this doc explaining how are welcome!] There are also ssh daemons that use LDAP to store the authorised keys (instead of putting them all in ~/.ssh/authorized_keys ). The clients will still need to generate keypairs and send them to the admin, but they can be more centrally stored and perhaps used by other programs or tools simultaneously, which can be useful.","title":"using other authentication systems with gitolite"},{"location":"sts.html","text":"ssh troubleshooting and tips \uf0c1 This page must be read in full the first time. If you start from some nice looking section in the middle it may not help you unless you're already an expert at ssh . This page should help you troubleshoot ssh-related problems in installing and accessing gitolite. It also has a section of random ssh-related tips and tricks that gitolite can do. IMPORTANT -- READ THIS FIRST \uf0c1 caveats \uf0c1 Before reading this page, it is mandatory to read and completely understand this , which is a very detailed look at how gitolite uses ssh's features on the server side. Don't assume you know all that; if you did, you wouldn't be needing this page either! This page, and others linked from this, together comprise all the help I can give you in terms of the ssh aspect of using gitolite. If you're installing gitolite, you're a \"system admin\", like it or not. Ssh is therefore a necessary skill. Please take the time to learn at least enough to get passwordless access working. Please note that authentication is not really gitolite's job at all. I'd rather spend time on actual gitolite features, code, and documentation than authentication (i.e., ssh, in the common case). Surprised? This might help explain better. naming conventions used \uf0c1 Your workstation is the client . Your userid on the client does not matter, and it has no relation to your gitolite username. The server is called server and the \"hosting user\" is git . If this is an RPM/DEB install, the hosting user is probably called \"gitolite\", however we will use \"git\" in this page. taking stock -- relevant files and directories \uf0c1 The client has a ~/.ssh containing a few keypairs. It may also have a config file. The client also has a clone of the \"gitolite-admin\" repo, which contains a bunch of *.pub files in keydir . We assume this clone is in $HOME ; if it is not, adjust instructions accordingly when needed. The git user on the server has a ~/.ssh/authorized_keys file that the ssh daemon uses to authenticate incoming users. We often call this file authkeys to save typing, and it always means the one on the server (we're not interested in this file on the client side). The server also has a ~/.gitolite/keydir which contains a bunch of *.pub files. normal gitolite key handling \uf0c1 Here's how normal gitolite key handling works: (On client) pub key changes like adding new ones, deleting old ones, etc., are done in the keydir directory in the gitolite-admin repo clone. Then the admin git add s and git commit s those changes, then git push es them to the server. (On server) a successful push from the client makes git invoke the post-update hook in the gitolite-admin repo. This hook is installed by gitolite, and it does a bunch of things which are quite transparent to the admin, but we'll describe briefly here: The pubkey files from this push are checked-out into ~/.gitolite/keydir (and similarly the config files into ~/.gitolite/conf ). The \"compile\" script then runs, which uses these files to populate ~/.ssh/authorized_keys on the server. The authkeys file may have other, (non-gitolite) keys also. Those lines are preserved. Gitolite only touches lines that are found between gitolite's \"marker\" lines ( # gitolite start and # gitolite end ). common ssh problems \uf0c1 Since I'm pretty sure at least some of you didn't bother to read the \"IMPORTANT: PLEASE READ FIRST\" section above, let me take a minute to point you there again. Especially the first bullet. Done? OK, read on... The following problem(s) indicate that pubkey access is not working at all, so you should start with appendix 1 . If that doesn't fix the problem, continue with the other appendices in sequence. Running any git clone/fetch/ls-remote or just ssh git@server info asks you for a password. (Or, if your sshd is set to use keys only, it just disconnects without doing anything). The following problem(s) indicate that your pubkey is bypassing gitolite and going straight to a shell. You should start with appendix 2 and continue with the rest in sequence. Appendix 5 has some background info. Running ssh git@server info gets you the output of the GNU 'info' command instead of gitolite's version and access info. Running git clone git@server:repositories/reponame (note presence of repositories/ in URL) works. [A proper gitolite key will only let you git clone git@server:reponame (note absence of repositories/ )] You are able to clone repositories but are unable to push changes back (the error complains about the GL_BINDIR environment variable not being set or about not being able to locate Gitolite/Hooks/Update.pm , and the hooks/update failing in some way). [If you run git remote -v you will find that your clone URL included the repositories/ described above!] Conversely, using the correct syntax, git clone git@server:reponame (note absence of repositories/ in the URL), gets you fatal: 'reponame' does not appear to be a git repository , and yet you are sure 'reponame' exists, you haven't mis-spelled it, etc. step by step \uf0c1 Since I'm pretty sure at least some of you didn't bother to read the \"IMPORTANT: PLEASE READ FIRST\" section above, let me take a minute to point you there again. Especially the first bullet. Done? OK, now the general outline for ssh troubleshooting is this: Make sure the server's overall setup even allows pubkey based login. I.e., check that git fetch/clone/ls-remote commands or a plain ssh git@server info do NOT ask for a password. If you do get asked for a password, see appendix 1 . Match client-side pubkeys ( ~/.ssh/*.pub ) with the server's authkeys file. To do this, run sshkeys-lint , which tells you in detail what key has what access. See appendix 2 . At this point, we know that we have the right key, and that if sshd receives that key, things will work. But we're not done yet. We still need to make sure that this specific key is being offered/sent by the client, instead of the default key. See appendix 3 and appendix 4 . random tips, tricks, and notes \uf0c1 giving shell access to gitolite users \uf0c1 Thanks to an idea from Jesse Keating, a single key can allow both gitolite access and shell access. (v3.6.1+) There are two ways to do this, both require uncommenting and editing the 'Shell' line in the ENABLE list in the rc file. If you have only a few users who need to get shell access, edit the line to look like this (note the trailing comma!): 'Shell alice bob', If you have lots of users, add them to some file accessible to gitolite, (one per line, no extra whitespace), then specify the full path of the file. For example: \"Shell $ENV{HOME}/.gitolite.shell-users\", (Note in this case we have to use double quotes since we are using a variable that needs to be interpolated into the value). Then run gitolite compile; gitolite trigger POST_COMPILE or push a dummy change to the admin repo. the SHELL_USERS_LIST \uf0c1 If you're using gitolite v3.6 or below, it's slightly different. You have to enable the trigger by uncommenting the 'Shell' line in the ENABLE list, but you cannot list the users directly on the 'Shell' line in the rc file, nor can you put the file name on that line. Instead, you have to go to the variables section in the rc file and set the SHELL_USERS_LIST variable to the filename. For example: SHELL_USERS_LIST => \"$ENV{HOME}/.gitolite.shell-users\", Then run gitolite compile; gitolite trigger POST_COMPILE or push a dummy change to the admin repo. NOTE : to maintain backward compatibility, this method will continue to work in 3.6.*, but when 3.7 is released (whenever that may be), it will not work, and you will have to use the new syntax described above. distinguishing one key from another \uf0c1 Since a user can have more than one key , it is sometimes useful to distinguish one key from another. Sshd does not tell you even the fingerprint of the key that finally matched, so normally all you have is the GL_USER env var. However, if you replace 'ssh-authkeys', in the ENABLE list with 'ssh-authkeys --key-file-name', then an extra argument is added after the username in the \"command\" variable of the authkeys file. That is, instead of this: command=\"/home/g3/gitolite/src/gitolite-shell u3\",no-port-forwarding,... you get this: command=\"/home/g3/gitolite/src/gitolite-shell u3 keydir/u3.pub\",no-port-forwarding,... You can then write an INPUT trigger to do whatever you need with the file name, which is in $ARGV[1] (the second argument). The actual file is available at $ENV{GL_ADMIN_BASE}/$ARGV[1] if you need its contents. simulating ssh-copy-id \uf0c1 don't have ssh-copy-id ? This is broadly what that command does, if you want to replicate it manually. The input is your pubkey, typically ~/.ssh/id_rsa.pub from your client/workstation. It copies it to the server as some file. It appends that file to ~/.ssh/authorized_keys on the server (creating it if it doesn't already exist). It then makes sure that all these files/directories have go-w perms set (assuming user is \"git\"): /home/git/.ssh/authorized_keys /home/git/.ssh /home/git [Actually, sshd requires that even directories above ~ ( / , /home , typically) also must be go-w , but that needs root. And typically they're already set that way anyway. (Or if they're not, you've got bigger problems than gitolite install not working!)] problems with using non-openssh public keys \uf0c1 Gitolite accepts public keys only in openssh format. Trying to use an \"ssh2\" key (used by proprietary SSH software) will not be a happy experience. src/triggers/post-compile/ssh-authkeys can be made to detect non-openssh formats and automatically convert them; patches welcome! The actual conversion command, if you want to just do it manually for now and be done with it, is: ssh-keygen -i -f /tmp/ssh2/YourName.pub > /tmp/openssh/YourName.pub then use the resulting pubkey as you normally would in gitolite. windows issues \uf0c1 On windows, I have only used msysgit, and the openssh that comes with it. Over time, I have grown to distrust putty/plink due to the number of people who seem to have trouble when those beasts are involved (I myself have never used them for any kind of git access). If you have unusual ssh problems that just don't seem to have any explanation, try removing all traces of putty/plink, including environment variables, etc., and then try again. Thankfully, someone contributed this . appendix 1: ssh daemon asks for a password \uf0c1 NOTE : This section should be useful to anyone trying to get password-less access working. It is not necessarily specific to gitolite, so keep that in mind if the wording feels a little more general than you were expecting. You have generated a keypair on your workstation ( ssh-keygen ) and copied the public part of it ( ~/.ssh/id_rsa.pub , by default) to the server. On the server you have appended this file to ~/.ssh/authorized_keys . Or you ran something, like the gitolite setup step during a gitolite install, which should have done that for you. You now expect to log in without having to type in a password, but when you try, you are being asked for a password. This is a quick checklist: Make sure you're being asked for a password and not a pass phrase . Do not confuse or mistake a prompt saying Enter passphrase for key '/home/sitaram/.ssh/id_rsa': for a password prompt from the remote server! When you create an ssh keypair using ssh-keygen , you have the option of protecting it with a passphrase. When you subsequently use that keypair to access a remote host, your local ssh client needs to unlock the corresponding private key, and ssh will probably ask for the passphrase you set when you created the keypair. You have two choices to avoid this prompt every time you try to use the private key. The first is to create keypairs without a passphrase (just hit enter when prompted for one). Be sure to add a passphrase later, once everything is working, using ssh-keygen -p . The second is to use ssh-agent (or keychain , which in turn uses ssh-agent ) or something like that to manage your keys. Other than discussing one more potential trouble-spot with ssh-agent (see below), further discussion of ssh-agent/keychain is out of scope of this page. Ssh is very sensitive to permissions. An extremely conservative setup is given below, but be sure to do this on both the client and the server : cd $HOME chmod go-rwx . chmod -R go-rwx .ssh Actually, every component of the path to ~/.ssh/authorized_keys all the way upto the root directory must be at least chmod go-w . So be sure to check / and /home also. While you're doing this, make sure the owner and group info for each of these components are correct. ls -ald ~ ~/.ssh ~/.ssh/authorized_keys will tell you what they are. You may also want to check /etc/ssh/sshd_config to see if the \"git\" user is allowed to login at all. For example, if that file contains an AllowUsers config entry, then only users mentioned in that line are allowed to log in! While you're in there, check that file does NOT have a setting for AuthorizedKeysFile . See man sshd_config for details. This setting is a show stopper for gitolite to use ssh. Some OSs/distributions require that the \"git\" user should have a password and/or not be a locked account. You may want to check that as well. If your server is running SELinux, and you install gitolite to /var/gitolite or another location unsupported by default SELinux policies, then SELinux will prevent sshd from reading .ssh/authorized_keys . Consider installing gitolite to /var/lib/gitolite , which is a supported location by default SELinux policies. If all that fails, log onto the server as root, cd /var/log , and look for a file called auth.log or secure or some such name. Look inside this file for messages matching the approximate time of your last attempt to login, to see if they tell you what is the problem. appendix 2: which key is which -- running sshkeys-lint \uf0c1 The sshkeys-lint program can be run on the server or the client. Run it with '-h' to get a help message. On the server you can run gitolite sshkeys-lint and it will tell you, for each key in the admin directory's keydir, what access is available. This is especially good at finding duplicate keys and such. To run it on the client you have to copy the file src/commands/sshkeys-lint from some gitolite clone, then follow these steps: Get a copy of ~/.ssh/authorized_keys from the server and put it in /tmp/foo or something. cd to ~/.ssh . Run /path/to/sshkeys-lint *.pub < /tmp/foo . Note that it is not trying to log in or anything -- it's just comparing fingerprints as computed by ssh-keygen -l . If the pubkey file you're interested in appears to have the correct access to the server, you're done with this step. Otherwise you have to rename some keypairs and try again to get the effect you need. Be careful: Do not just rename the \".pub\" file; you will have to rename the corresponding private key also (the one with the same basename but without an extension). If you're running ssh-agent, you may have to delete (using ssh-add -D ) and re-add identities for it to pick up the renamed ones correctly. typical cause(s) \uf0c1 The admin often has passwordless shell access to git@server already, and then used that same key to get access to gitolite (i.e., copied that same pubkey as YourName.pub and ran gitolite setup on it). As a result, the same key appears twice in the authkeys file now, and since the ssh server will always use the first match, the second occurrence (which invokes gitolite) is ignored. To fix this, you have to use a different keypair for gitolite access. The best way to do this is to create a new keypair, copy the pubkey to the server as YourName.pub, then run gitolite setup -pk YourName.pub on the server. Remember to adjust your agent identities using ssh-add -D and ssh-add if you're using ssh-agent, otherwise these new keys may not work. appendix 3: ssh client may not be offering the right key \uf0c1 Make sure the right private key is being offered. Run ssh in very verbose mode and look for the word \"Offering\", like so: ssh -vvv user@host pwd 2> >(grep -i offer) If some keys are being offered, but not the key that was supposed to be used, you may be using ssh-agent (next bullet). You may also need to create some host aliases in ~/.ssh/config ( appendix 4 ). (ssh-agent issues) If ssh-add -l responds with either \"The agent has no identities.\" or \"Could not open a connection to your authentication agent.\", then you can skip this bullet. However, if ssh-add -l lists any keys at all, then something weird happens. Due to a quirk in ssh-agent, ssh will now only use one of those keys, even if you explicitly ask for some other key to be used. In that case, add the key you want using ssh-add ~/.ssh/YourName and try the access again. appendix 4: ssh host aliases \uf0c1 (or \"making git use the right options for ssh\") The ssh command has several options for non-default items to be specified. Two common examples are -p for the port number if it is not 22, and -i for the public key file if you do not want to use just ~/.ssh/id_rsa or such. Git has two ssh-based URL syntaxes, but neither allows specifying a non-default public key file. And a port number is only allowed in one of them. (See man git-clone for details). Finally, hosts often have to be referred with IP addresses (such is life), or the name is very long, or hard to remember. Using a \"host\" para in ~/.ssh/config lets you nicely encapsulate all this within ssh and give it a short, easy-to-remember, name. Example: host gitolite user git hostname a.long.server.name.or.annoying.IP.address port 22 identityfile ~/.ssh/id_rsa Now you can simply use the one word gitolite (which is the host alias we defined here) and ssh will infer all those details defined under it -- just say ssh gitolite and git clone gitolite:reponame and things will work. (By the way, the 'port' and 'identityfile' lines are needed only if you have non-default values, although I put them in anyway just to be complete). more than one keypair \uf0c1 If you have more than one pubkey with access to the same server, you must use this method to make git pick up the right key. There is no other way to do this, as far as I know. A typical example would be if you wanted shell access to the gitolite server using one keypair, and gitolite-mediated access using another. Here's how I do that, where my \"id_rsa\" keypair has shell access, and my \"sitaram\" keypair has gitolite access: host gitolite user git hostname gitolite.mydomain.com port 22 identityfile ~/.ssh/sitaram host gitolite-sh user git hostname gitolite.mydomain.com port 22 identityfile ~/.ssh/id_rsa Then I would use \"ssh gitolite-sh\" to get a command line, and use the host alias \"gitolite\" in git clone and other commands, as well as for gitolite commands (like \"ssh gitolite info\"). Just to be clear, please note that this assumes the authorized keys file on the gitolite hosting user has my \"id_rsa.pub\" line, without the gitolite related forced command and options. appendix 5: why bypassing gitolite causes a problem \uf0c1 When you bypass gitolite, you end up running your normal shell instead of the special gitolite entry point script gitolite-shell . This means commands (like 'info') are interpreted by the shell instead of gitolite. It also means git operations look for repos in $HOME . However, gitolite places all your repos in ~/repositories , and internally prefixes this before calling the actual git command you invoked. Thus, the pathname of the repo that you use on the client is almost never the correct pathname on the server. (This is by design. Don't argue...) This means that, you get 2 kinds of errors if you bypass gitolite When you use git@server:reponame with a key that bypasses gitolite (i.e., gets you a shell), this prefixing does not happen, and so the repo is not found. Neither a clone/fetch nor a push will work. Conversely, consider git@server:repositories/reponame.git . The clone operation will work -- you're using the full Unix path, and so the shell finds the repo where you said it would be. However, when you push, gitolite's update hook kicks in, and fails to run because some of the environment variables it is expecting are not present.","title":"ssh troubleshooting"},{"location":"sts.html#ssh-troubleshooting-and-tips","text":"This page must be read in full the first time. If you start from some nice looking section in the middle it may not help you unless you're already an expert at ssh . This page should help you troubleshoot ssh-related problems in installing and accessing gitolite. It also has a section of random ssh-related tips and tricks that gitolite can do.","title":"ssh troubleshooting and tips"},{"location":"sts.html#important-read-this-first","text":"","title":"IMPORTANT -- READ THIS FIRST"},{"location":"sts.html#caveats","text":"Before reading this page, it is mandatory to read and completely understand this , which is a very detailed look at how gitolite uses ssh's features on the server side. Don't assume you know all that; if you did, you wouldn't be needing this page either! This page, and others linked from this, together comprise all the help I can give you in terms of the ssh aspect of using gitolite. If you're installing gitolite, you're a \"system admin\", like it or not. Ssh is therefore a necessary skill. Please take the time to learn at least enough to get passwordless access working. Please note that authentication is not really gitolite's job at all. I'd rather spend time on actual gitolite features, code, and documentation than authentication (i.e., ssh, in the common case). Surprised? This might help explain better.","title":"caveats"},{"location":"sts.html#naming-conventions-used","text":"Your workstation is the client . Your userid on the client does not matter, and it has no relation to your gitolite username. The server is called server and the \"hosting user\" is git . If this is an RPM/DEB install, the hosting user is probably called \"gitolite\", however we will use \"git\" in this page.","title":"naming conventions used"},{"location":"sts.html#taking-stock-relevant-files-and-directories","text":"The client has a ~/.ssh containing a few keypairs. It may also have a config file. The client also has a clone of the \"gitolite-admin\" repo, which contains a bunch of *.pub files in keydir . We assume this clone is in $HOME ; if it is not, adjust instructions accordingly when needed. The git user on the server has a ~/.ssh/authorized_keys file that the ssh daemon uses to authenticate incoming users. We often call this file authkeys to save typing, and it always means the one on the server (we're not interested in this file on the client side). The server also has a ~/.gitolite/keydir which contains a bunch of *.pub files.","title":"taking stock -- relevant files and directories"},{"location":"sts.html#normal-gitolite-key-handling","text":"Here's how normal gitolite key handling works: (On client) pub key changes like adding new ones, deleting old ones, etc., are done in the keydir directory in the gitolite-admin repo clone. Then the admin git add s and git commit s those changes, then git push es them to the server. (On server) a successful push from the client makes git invoke the post-update hook in the gitolite-admin repo. This hook is installed by gitolite, and it does a bunch of things which are quite transparent to the admin, but we'll describe briefly here: The pubkey files from this push are checked-out into ~/.gitolite/keydir (and similarly the config files into ~/.gitolite/conf ). The \"compile\" script then runs, which uses these files to populate ~/.ssh/authorized_keys on the server. The authkeys file may have other, (non-gitolite) keys also. Those lines are preserved. Gitolite only touches lines that are found between gitolite's \"marker\" lines ( # gitolite start and # gitolite end ).","title":"normal gitolite key handling"},{"location":"sts.html#common-ssh-problems","text":"Since I'm pretty sure at least some of you didn't bother to read the \"IMPORTANT: PLEASE READ FIRST\" section above, let me take a minute to point you there again. Especially the first bullet. Done? OK, read on... The following problem(s) indicate that pubkey access is not working at all, so you should start with appendix 1 . If that doesn't fix the problem, continue with the other appendices in sequence. Running any git clone/fetch/ls-remote or just ssh git@server info asks you for a password. (Or, if your sshd is set to use keys only, it just disconnects without doing anything). The following problem(s) indicate that your pubkey is bypassing gitolite and going straight to a shell. You should start with appendix 2 and continue with the rest in sequence. Appendix 5 has some background info. Running ssh git@server info gets you the output of the GNU 'info' command instead of gitolite's version and access info. Running git clone git@server:repositories/reponame (note presence of repositories/ in URL) works. [A proper gitolite key will only let you git clone git@server:reponame (note absence of repositories/ )] You are able to clone repositories but are unable to push changes back (the error complains about the GL_BINDIR environment variable not being set or about not being able to locate Gitolite/Hooks/Update.pm , and the hooks/update failing in some way). [If you run git remote -v you will find that your clone URL included the repositories/ described above!] Conversely, using the correct syntax, git clone git@server:reponame (note absence of repositories/ in the URL), gets you fatal: 'reponame' does not appear to be a git repository , and yet you are sure 'reponame' exists, you haven't mis-spelled it, etc.","title":"common ssh problems"},{"location":"sts.html#step-by-step","text":"Since I'm pretty sure at least some of you didn't bother to read the \"IMPORTANT: PLEASE READ FIRST\" section above, let me take a minute to point you there again. Especially the first bullet. Done? OK, now the general outline for ssh troubleshooting is this: Make sure the server's overall setup even allows pubkey based login. I.e., check that git fetch/clone/ls-remote commands or a plain ssh git@server info do NOT ask for a password. If you do get asked for a password, see appendix 1 . Match client-side pubkeys ( ~/.ssh/*.pub ) with the server's authkeys file. To do this, run sshkeys-lint , which tells you in detail what key has what access. See appendix 2 . At this point, we know that we have the right key, and that if sshd receives that key, things will work. But we're not done yet. We still need to make sure that this specific key is being offered/sent by the client, instead of the default key. See appendix 3 and appendix 4 .","title":"step by step"},{"location":"sts.html#random-tips-tricks-and-notes","text":"","title":"random tips, tricks, and notes"},{"location":"sts.html#giving-shell-access-to-gitolite-users","text":"Thanks to an idea from Jesse Keating, a single key can allow both gitolite access and shell access. (v3.6.1+) There are two ways to do this, both require uncommenting and editing the 'Shell' line in the ENABLE list in the rc file. If you have only a few users who need to get shell access, edit the line to look like this (note the trailing comma!): 'Shell alice bob', If you have lots of users, add them to some file accessible to gitolite, (one per line, no extra whitespace), then specify the full path of the file. For example: \"Shell $ENV{HOME}/.gitolite.shell-users\", (Note in this case we have to use double quotes since we are using a variable that needs to be interpolated into the value). Then run gitolite compile; gitolite trigger POST_COMPILE or push a dummy change to the admin repo.","title":"giving shell access to gitolite users"},{"location":"sts.html#the-shell_users_list","text":"If you're using gitolite v3.6 or below, it's slightly different. You have to enable the trigger by uncommenting the 'Shell' line in the ENABLE list, but you cannot list the users directly on the 'Shell' line in the rc file, nor can you put the file name on that line. Instead, you have to go to the variables section in the rc file and set the SHELL_USERS_LIST variable to the filename. For example: SHELL_USERS_LIST => \"$ENV{HOME}/.gitolite.shell-users\", Then run gitolite compile; gitolite trigger POST_COMPILE or push a dummy change to the admin repo. NOTE : to maintain backward compatibility, this method will continue to work in 3.6.*, but when 3.7 is released (whenever that may be), it will not work, and you will have to use the new syntax described above.","title":"the SHELL_USERS_LIST"},{"location":"sts.html#distinguishing-one-key-from-another","text":"Since a user can have more than one key , it is sometimes useful to distinguish one key from another. Sshd does not tell you even the fingerprint of the key that finally matched, so normally all you have is the GL_USER env var. However, if you replace 'ssh-authkeys', in the ENABLE list with 'ssh-authkeys --key-file-name', then an extra argument is added after the username in the \"command\" variable of the authkeys file. That is, instead of this: command=\"/home/g3/gitolite/src/gitolite-shell u3\",no-port-forwarding,... you get this: command=\"/home/g3/gitolite/src/gitolite-shell u3 keydir/u3.pub\",no-port-forwarding,... You can then write an INPUT trigger to do whatever you need with the file name, which is in $ARGV[1] (the second argument). The actual file is available at $ENV{GL_ADMIN_BASE}/$ARGV[1] if you need its contents.","title":"distinguishing one key from another"},{"location":"sts.html#simulating-ssh-copy-id","text":"don't have ssh-copy-id ? This is broadly what that command does, if you want to replicate it manually. The input is your pubkey, typically ~/.ssh/id_rsa.pub from your client/workstation. It copies it to the server as some file. It appends that file to ~/.ssh/authorized_keys on the server (creating it if it doesn't already exist). It then makes sure that all these files/directories have go-w perms set (assuming user is \"git\"): /home/git/.ssh/authorized_keys /home/git/.ssh /home/git [Actually, sshd requires that even directories above ~ ( / , /home , typically) also must be go-w , but that needs root. And typically they're already set that way anyway. (Or if they're not, you've got bigger problems than gitolite install not working!)]","title":"simulating ssh-copy-id"},{"location":"sts.html#problems-with-using-non-openssh-public-keys","text":"Gitolite accepts public keys only in openssh format. Trying to use an \"ssh2\" key (used by proprietary SSH software) will not be a happy experience. src/triggers/post-compile/ssh-authkeys can be made to detect non-openssh formats and automatically convert them; patches welcome! The actual conversion command, if you want to just do it manually for now and be done with it, is: ssh-keygen -i -f /tmp/ssh2/YourName.pub > /tmp/openssh/YourName.pub then use the resulting pubkey as you normally would in gitolite.","title":"problems with using non-openssh public keys"},{"location":"sts.html#windows-issues","text":"On windows, I have only used msysgit, and the openssh that comes with it. Over time, I have grown to distrust putty/plink due to the number of people who seem to have trouble when those beasts are involved (I myself have never used them for any kind of git access). If you have unusual ssh problems that just don't seem to have any explanation, try removing all traces of putty/plink, including environment variables, etc., and then try again. Thankfully, someone contributed this .","title":"windows issues"},{"location":"sts.html#appendix-1-ssh-daemon-asks-for-a-password","text":"NOTE : This section should be useful to anyone trying to get password-less access working. It is not necessarily specific to gitolite, so keep that in mind if the wording feels a little more general than you were expecting. You have generated a keypair on your workstation ( ssh-keygen ) and copied the public part of it ( ~/.ssh/id_rsa.pub , by default) to the server. On the server you have appended this file to ~/.ssh/authorized_keys . Or you ran something, like the gitolite setup step during a gitolite install, which should have done that for you. You now expect to log in without having to type in a password, but when you try, you are being asked for a password. This is a quick checklist: Make sure you're being asked for a password and not a pass phrase . Do not confuse or mistake a prompt saying Enter passphrase for key '/home/sitaram/.ssh/id_rsa': for a password prompt from the remote server! When you create an ssh keypair using ssh-keygen , you have the option of protecting it with a passphrase. When you subsequently use that keypair to access a remote host, your local ssh client needs to unlock the corresponding private key, and ssh will probably ask for the passphrase you set when you created the keypair. You have two choices to avoid this prompt every time you try to use the private key. The first is to create keypairs without a passphrase (just hit enter when prompted for one). Be sure to add a passphrase later, once everything is working, using ssh-keygen -p . The second is to use ssh-agent (or keychain , which in turn uses ssh-agent ) or something like that to manage your keys. Other than discussing one more potential trouble-spot with ssh-agent (see below), further discussion of ssh-agent/keychain is out of scope of this page. Ssh is very sensitive to permissions. An extremely conservative setup is given below, but be sure to do this on both the client and the server : cd $HOME chmod go-rwx . chmod -R go-rwx .ssh Actually, every component of the path to ~/.ssh/authorized_keys all the way upto the root directory must be at least chmod go-w . So be sure to check / and /home also. While you're doing this, make sure the owner and group info for each of these components are correct. ls -ald ~ ~/.ssh ~/.ssh/authorized_keys will tell you what they are. You may also want to check /etc/ssh/sshd_config to see if the \"git\" user is allowed to login at all. For example, if that file contains an AllowUsers config entry, then only users mentioned in that line are allowed to log in! While you're in there, check that file does NOT have a setting for AuthorizedKeysFile . See man sshd_config for details. This setting is a show stopper for gitolite to use ssh. Some OSs/distributions require that the \"git\" user should have a password and/or not be a locked account. You may want to check that as well. If your server is running SELinux, and you install gitolite to /var/gitolite or another location unsupported by default SELinux policies, then SELinux will prevent sshd from reading .ssh/authorized_keys . Consider installing gitolite to /var/lib/gitolite , which is a supported location by default SELinux policies. If all that fails, log onto the server as root, cd /var/log , and look for a file called auth.log or secure or some such name. Look inside this file for messages matching the approximate time of your last attempt to login, to see if they tell you what is the problem.","title":"appendix 1: ssh daemon asks for a password"},{"location":"sts.html#appendix-2-which-key-is-which-running-sshkeys-lint","text":"The sshkeys-lint program can be run on the server or the client. Run it with '-h' to get a help message. On the server you can run gitolite sshkeys-lint and it will tell you, for each key in the admin directory's keydir, what access is available. This is especially good at finding duplicate keys and such. To run it on the client you have to copy the file src/commands/sshkeys-lint from some gitolite clone, then follow these steps: Get a copy of ~/.ssh/authorized_keys from the server and put it in /tmp/foo or something. cd to ~/.ssh . Run /path/to/sshkeys-lint *.pub < /tmp/foo . Note that it is not trying to log in or anything -- it's just comparing fingerprints as computed by ssh-keygen -l . If the pubkey file you're interested in appears to have the correct access to the server, you're done with this step. Otherwise you have to rename some keypairs and try again to get the effect you need. Be careful: Do not just rename the \".pub\" file; you will have to rename the corresponding private key also (the one with the same basename but without an extension). If you're running ssh-agent, you may have to delete (using ssh-add -D ) and re-add identities for it to pick up the renamed ones correctly.","title":"appendix 2: which key is which -- running sshkeys-lint"},{"location":"sts.html#typical-causes","text":"The admin often has passwordless shell access to git@server already, and then used that same key to get access to gitolite (i.e., copied that same pubkey as YourName.pub and ran gitolite setup on it). As a result, the same key appears twice in the authkeys file now, and since the ssh server will always use the first match, the second occurrence (which invokes gitolite) is ignored. To fix this, you have to use a different keypair for gitolite access. The best way to do this is to create a new keypair, copy the pubkey to the server as YourName.pub, then run gitolite setup -pk YourName.pub on the server. Remember to adjust your agent identities using ssh-add -D and ssh-add if you're using ssh-agent, otherwise these new keys may not work.","title":"typical cause(s)"},{"location":"sts.html#appendix-3-ssh-client-may-not-be-offering-the-right-key","text":"Make sure the right private key is being offered. Run ssh in very verbose mode and look for the word \"Offering\", like so: ssh -vvv user@host pwd 2> >(grep -i offer) If some keys are being offered, but not the key that was supposed to be used, you may be using ssh-agent (next bullet). You may also need to create some host aliases in ~/.ssh/config ( appendix 4 ). (ssh-agent issues) If ssh-add -l responds with either \"The agent has no identities.\" or \"Could not open a connection to your authentication agent.\", then you can skip this bullet. However, if ssh-add -l lists any keys at all, then something weird happens. Due to a quirk in ssh-agent, ssh will now only use one of those keys, even if you explicitly ask for some other key to be used. In that case, add the key you want using ssh-add ~/.ssh/YourName and try the access again.","title":"appendix 3: ssh client may not be offering the right key"},{"location":"sts.html#appendix-4-ssh-host-aliases","text":"(or \"making git use the right options for ssh\") The ssh command has several options for non-default items to be specified. Two common examples are -p for the port number if it is not 22, and -i for the public key file if you do not want to use just ~/.ssh/id_rsa or such. Git has two ssh-based URL syntaxes, but neither allows specifying a non-default public key file. And a port number is only allowed in one of them. (See man git-clone for details). Finally, hosts often have to be referred with IP addresses (such is life), or the name is very long, or hard to remember. Using a \"host\" para in ~/.ssh/config lets you nicely encapsulate all this within ssh and give it a short, easy-to-remember, name. Example: host gitolite user git hostname a.long.server.name.or.annoying.IP.address port 22 identityfile ~/.ssh/id_rsa Now you can simply use the one word gitolite (which is the host alias we defined here) and ssh will infer all those details defined under it -- just say ssh gitolite and git clone gitolite:reponame and things will work. (By the way, the 'port' and 'identityfile' lines are needed only if you have non-default values, although I put them in anyway just to be complete).","title":"appendix 4: ssh host aliases"},{"location":"sts.html#more-than-one-keypair","text":"If you have more than one pubkey with access to the same server, you must use this method to make git pick up the right key. There is no other way to do this, as far as I know. A typical example would be if you wanted shell access to the gitolite server using one keypair, and gitolite-mediated access using another. Here's how I do that, where my \"id_rsa\" keypair has shell access, and my \"sitaram\" keypair has gitolite access: host gitolite user git hostname gitolite.mydomain.com port 22 identityfile ~/.ssh/sitaram host gitolite-sh user git hostname gitolite.mydomain.com port 22 identityfile ~/.ssh/id_rsa Then I would use \"ssh gitolite-sh\" to get a command line, and use the host alias \"gitolite\" in git clone and other commands, as well as for gitolite commands (like \"ssh gitolite info\"). Just to be clear, please note that this assumes the authorized keys file on the gitolite hosting user has my \"id_rsa.pub\" line, without the gitolite related forced command and options.","title":"more than one keypair"},{"location":"sts.html#appendix-5-why-bypassing-gitolite-causes-a-problem","text":"When you bypass gitolite, you end up running your normal shell instead of the special gitolite entry point script gitolite-shell . This means commands (like 'info') are interpreted by the shell instead of gitolite. It also means git operations look for repos in $HOME . However, gitolite places all your repos in ~/repositories , and internally prefixes this before calling the actual git command you invoked. Thus, the pathname of the repo that you use on the client is almost never the correct pathname on the server. (This is by design. Don't argue...) This means that, you get 2 kinds of errors if you bypass gitolite When you use git@server:reponame with a key that bypasses gitolite (i.e., gets you a shell), this prefixing does not happen, and so the repo is not found. Neither a clone/fetch nor a push will work. Conversely, consider git@server:repositories/reponame.git . The clone operation will work -- you're using the full Unix path, and so the shell finds the repo where you said it would be. However, when you push, gitolite's update hook kicks in, and fails to run because some of the environment variables it is expecting are not present.","title":"appendix 5: why bypassing gitolite causes a problem"},{"location":"templates.html","text":"setting up and using templates \uf0c1 This feature was added late September 2017, after 3.6.7. In terms of versioning, it will be part of 3.6.8, or you could just grab the latest from github. overview \uf0c1 This feature describes a new method of specifying gitolite rules. A \"template\" is a set of gitolite access rules with a name. A gitolite \"expert\" can setup a suitable set of templates, and then actual repos can use one or more of these templates, according to their need. A simple example will illustrate. It's split into two parts. First, the template definitions , where the rules comprising each template are defined: # (obligatory warning: the order of the following lines matters!) repo @is_public R = @all repo @is_suspended - = @all repo @has_personal_refs RW+ dev /USER/ = teamleads team - dev/ = @all RW+ refs/tags/dev /USER/ = teamleads team - refs/tags/dev/ = @all repo @has_releases RW refs/tags/v[0-9] = release_managers - refs/tags/v[0-9] = @all repo @base RW+ = teamleads RW = team R = READERS Next, you have the template data section (i.e., the lines between the begin and end lines you see in the example below). This is where you declare actual repos ( foo and bar below), giving each a set of one or more templates it will use , and map users to any roles that the template may require. =begin template-data repo foo = base is_public has_releases teamleads = sitaram team = dilbert wally READERS = ashok release_managers = alice repo bar = base has_personal_refs teamleads = han team = luke chewie =end Notice that foo and bar use different sets of templates: foo is a public-readable repo that controls who can push versioned tags (releases), while bar is a basic repo which supports personal branches . advantages \uf0c1 There are a few advantages with this approach: Maintaining access rules is much simpler. Just choose an appropriate set of \"template names\", assign people to roles, and you're done. There's no need to understand the intricacies of gitolite's ruleset. (The person who wrote the templates needs to, but not the person who is maintaining dozens of repos by merely using those templates). Heck you can probably roll a nice GUI around this. Finally! Reduces boilerplate. A good example is the \"personal branches\" one above -- why have each of those 4 lines in every repo if you can instead refer to the feature by name somehow A conf using this is often smaller, and definitely cleaner. Reduces possible errors. This should follow from the previous point. It is easy to make mistakes when changing something due to some new requirement. Did you remember to put in the two \"deny\" rules in the personal branches example above? What if management decides to suspend pushes to one particular repo, and you best choice was to add a catch-all \"deny everyone\" rule. Did you remember to put it at the top? (If the templates are written as above (including the order in which you see them ), all you have to do is add the word is_suspended somewhere in the list of templates that apply to repo bar .) Makes gitolite compile much faster, especially if you have thousands (or tens of thousands) of repos. how does it work? \uf0c1 a repo and its users \uf0c1 The wildcard repos feature already has a way to dissociate the actual user names from the rule set in gitolite.conf. For example, you can say repo foo/..* C = @managers RW+ = WRITERS R = READERS ...(etc.)... This lets any \"manager\" create a repo whose name matches the pattern, then assign arbitrary users to WRITERS and other roles using the perms command . These role assignments are stored in a simple text file within the repository's bare directory (i.e., ~/repositories/$REPO.git ), so they are specific to that repo, not common to all the repos matching that pattern (as they would be if you listed the users in gitolite.conf directly). In other words, we've taken the actual users (say alice, bob, etc) out of the gitolite.conf file, and thus any changes to the users/roles no longer need to involve gitolite.conf. a repo and its rules \uf0c1 In a \"duh! Why didn't I think of this till now\" moment, I realised I can do the same for the rules that apply to a repo -- take that association out of gitolite.conf. That is what the repo foo = [...list of templates...] lines are doing. This list of templates is also stored in a plain text file just like the one that contains the user/role mappings, and in the same directory. usage and syntax \uf0c1 First, you have to add all the new \"roles\" to the ROLES hash in ~/.gitolite.rc . If you edit that file, you'll see two pre-created roles READERS and WRITERS . Using the same syntax (including the trailing comma), add any other roles you would like to use. In our example up at the top, the role names are team , teamleads , and release_managers . Rolenames must start with a letter, and be made up of only alphanumeric characters and the underscore -- basically the same rules as a shell variable. Next, you define the templates, in the right order. This is the only order that matters (not the order in which the templates are used in any particular repo in the template-data section). Thus, this is also the part that requires gitolite rules expertise, but it's hopefully a one-time or once-in-a-while thing. (Or you can ask on the mailing list!) Finally, you define actual repos in gitolite.conf as shown in the example above (including the =begin template-data and =end lines). For each repo, you specify what templates it will use, and then you map actual users to the role names from those templates. A few additional points: Not all role names need to be mapped to users (for example, we did not assign any READERS to repo bar , even though the base template specifies that role). Within the gitolite.conf file, the placement of the template-data section does not matter. (It's not even parsed by the conf compiler, which completely skips it. It's processed by a new program that is run internally, and directly manipulates the gl-repo-groups and gl-perms files). You can even have multiple template-data sections, with normal gitolite.conf rules, group definitions, config and option lines, etc., in between. (That's why there's a begin and an end!) If you use include files, I strongly suggest -- in the interest of sanity -- that you do not let a template-data section cross over a file boundary (i.e., define the begin in one file, and the end in another). It will work, if you understand what order the files are picked up, but I'd still avoid such tricks if I were you! If you want to insert some rules for a repo that is defined in a template-data section, you need to be careful where you place it. Rules defined by templates are deemed to occur exactly where the template definition is. So, speaking of repo foo, pretend that the line repo @is_public was replaced by repo foo , and similarly for repo @has_releases and repo @base . While we're on the subject, you can also pretend the role names on the right hand side of the rules are replaced by the actual user names you supplied in the template-data section. In the example above, say you wanted to insert a new rule for repo foo, which says that no one can rewind master , not even teamleads . Clearly, the rules you need are: repo foo RW master = sitaram # notice we had to expand 'teamleads' from foo's definition in the # template-data section - master = @all But where do you place them? The answer is, at least before the base template is defined . Otherwise, the RW+ in the base template will kick in, and this restriction will fail to take effect. Having said that, I would rather add a new template to deal with this, placing it just before repo @base ): repo @limits_master RW master = teamleads - master = @all and then add limits_master to the list of templates that foo uses. This has the advantages of being able to reuse that logic for other repos, but even more important, you're avoiding repeating the actual teamleads name(s) in more than one place! (Potentially a huge future inconsistency if someone forgot to update both places when the teamleads change!) You can also do multiple repos in one shot, as well as repo groups: # before the '=begin' line @repogroup1 = r1 r2 r3 ... ... ... =begin template-data repo foo bar @repogroup1 = base is_public has_releases ... ... ... =end bypassing gitolite.conf for huge sites \uf0c1 Some sites have all their access control information in a web-based system, and generate gitolite.conf as needed. If they have tens of thousands of repos, this \"generated\" gitolite.conf becomes humongous, and slows down compiles. Worse, the more repos you have, the more churn you have in terms of changes to users accesses, so you do more compiles per hour than a smaller site, which only makes things worse! With this feature, you can bypass gitolite.conf and directly create/update those text files to change the users and rule-sets for a given repo. It doesn't even have to touch gitolite or gitolite.conf (assuming the templates and roles are already defined in gitolite.conf and ~/.gitolite.rc of course!) generating the text files externally \uf0c1 The actual text files involved are very simple. Remember these files go into ~/repositories/$REPO.git (or more accurately, $(gitolite query-rc GL_REPO_BASE)/$REPO.git ). For the example above, here's the file gl-repo-groups in repo foo: $ cat ~/repositories/foo.git/gl-repo-groups base is_public has_releases As you can see, this text is just what is after the = sign in the repo line in the template data section of gitolite.conf. and the file gl-perms is: $ cat ~/repositories/foo.git/gl-perms teamleads = sitaram team = dilbert wally READERS = ashok release_managers = alice Again, this text is exactly the same as in the gitolite.conf! creating new repos \uf0c1 Gitolite has no mechanism to create repos out of thin air, so if you don't want to go via gitolite.conf, one way to do this is to add the following lines to the conf file (one-time): repo [a-zA-Z0-9].* C = gitolite-admin and then, at the server, run this: GL_USER=gitolite-admin gitolite create foo/bar That creates the repo, and you can now populate its gl-perms and gl-repo-groups files. thanks to... \uf0c1 ...pingou on irc, and the Fedora project, for having 42,000 repos in a conf file over 560,000 lines long. Which made me think about this real hard for days, including two false starts (one of which I published and have just now reverted, and one which was so kludgey I refuse to acknowledge it exists -- thank God I did not publish that!) miscellanea \uf0c1 This feature is not the same as wild repos; repos here are created by the gitolite admin or a server-side backend, not by a gitolite user. (However, this feature piggy-backs on a lot of the code for wild repos, adding just a wee bit -- the \"duh\" comment earlier in this document -- to complete it).","title":"using templates"},{"location":"templates.html#setting-up-and-using-templates","text":"This feature was added late September 2017, after 3.6.7. In terms of versioning, it will be part of 3.6.8, or you could just grab the latest from github.","title":"setting up and using templates"},{"location":"templates.html#overview","text":"This feature describes a new method of specifying gitolite rules. A \"template\" is a set of gitolite access rules with a name. A gitolite \"expert\" can setup a suitable set of templates, and then actual repos can use one or more of these templates, according to their need. A simple example will illustrate. It's split into two parts. First, the template definitions , where the rules comprising each template are defined: # (obligatory warning: the order of the following lines matters!) repo @is_public R = @all repo @is_suspended - = @all repo @has_personal_refs RW+ dev /USER/ = teamleads team - dev/ = @all RW+ refs/tags/dev /USER/ = teamleads team - refs/tags/dev/ = @all repo @has_releases RW refs/tags/v[0-9] = release_managers - refs/tags/v[0-9] = @all repo @base RW+ = teamleads RW = team R = READERS Next, you have the template data section (i.e., the lines between the begin and end lines you see in the example below). This is where you declare actual repos ( foo and bar below), giving each a set of one or more templates it will use , and map users to any roles that the template may require. =begin template-data repo foo = base is_public has_releases teamleads = sitaram team = dilbert wally READERS = ashok release_managers = alice repo bar = base has_personal_refs teamleads = han team = luke chewie =end Notice that foo and bar use different sets of templates: foo is a public-readable repo that controls who can push versioned tags (releases), while bar is a basic repo which supports personal branches .","title":"overview"},{"location":"templates.html#advantages","text":"There are a few advantages with this approach: Maintaining access rules is much simpler. Just choose an appropriate set of \"template names\", assign people to roles, and you're done. There's no need to understand the intricacies of gitolite's ruleset. (The person who wrote the templates needs to, but not the person who is maintaining dozens of repos by merely using those templates). Heck you can probably roll a nice GUI around this. Finally! Reduces boilerplate. A good example is the \"personal branches\" one above -- why have each of those 4 lines in every repo if you can instead refer to the feature by name somehow A conf using this is often smaller, and definitely cleaner. Reduces possible errors. This should follow from the previous point. It is easy to make mistakes when changing something due to some new requirement. Did you remember to put in the two \"deny\" rules in the personal branches example above? What if management decides to suspend pushes to one particular repo, and you best choice was to add a catch-all \"deny everyone\" rule. Did you remember to put it at the top? (If the templates are written as above (including the order in which you see them ), all you have to do is add the word is_suspended somewhere in the list of templates that apply to repo bar .) Makes gitolite compile much faster, especially if you have thousands (or tens of thousands) of repos.","title":"advantages"},{"location":"templates.html#how-does-it-work","text":"","title":"how does it work?"},{"location":"templates.html#a-repo-and-its-users","text":"The wildcard repos feature already has a way to dissociate the actual user names from the rule set in gitolite.conf. For example, you can say repo foo/..* C = @managers RW+ = WRITERS R = READERS ...(etc.)... This lets any \"manager\" create a repo whose name matches the pattern, then assign arbitrary users to WRITERS and other roles using the perms command . These role assignments are stored in a simple text file within the repository's bare directory (i.e., ~/repositories/$REPO.git ), so they are specific to that repo, not common to all the repos matching that pattern (as they would be if you listed the users in gitolite.conf directly). In other words, we've taken the actual users (say alice, bob, etc) out of the gitolite.conf file, and thus any changes to the users/roles no longer need to involve gitolite.conf.","title":"a repo and its users"},{"location":"templates.html#a-repo-and-its-rules","text":"In a \"duh! Why didn't I think of this till now\" moment, I realised I can do the same for the rules that apply to a repo -- take that association out of gitolite.conf. That is what the repo foo = [...list of templates...] lines are doing. This list of templates is also stored in a plain text file just like the one that contains the user/role mappings, and in the same directory.","title":"a repo and its rules"},{"location":"templates.html#usage-and-syntax","text":"First, you have to add all the new \"roles\" to the ROLES hash in ~/.gitolite.rc . If you edit that file, you'll see two pre-created roles READERS and WRITERS . Using the same syntax (including the trailing comma), add any other roles you would like to use. In our example up at the top, the role names are team , teamleads , and release_managers . Rolenames must start with a letter, and be made up of only alphanumeric characters and the underscore -- basically the same rules as a shell variable. Next, you define the templates, in the right order. This is the only order that matters (not the order in which the templates are used in any particular repo in the template-data section). Thus, this is also the part that requires gitolite rules expertise, but it's hopefully a one-time or once-in-a-while thing. (Or you can ask on the mailing list!) Finally, you define actual repos in gitolite.conf as shown in the example above (including the =begin template-data and =end lines). For each repo, you specify what templates it will use, and then you map actual users to the role names from those templates. A few additional points: Not all role names need to be mapped to users (for example, we did not assign any READERS to repo bar , even though the base template specifies that role). Within the gitolite.conf file, the placement of the template-data section does not matter. (It's not even parsed by the conf compiler, which completely skips it. It's processed by a new program that is run internally, and directly manipulates the gl-repo-groups and gl-perms files). You can even have multiple template-data sections, with normal gitolite.conf rules, group definitions, config and option lines, etc., in between. (That's why there's a begin and an end!) If you use include files, I strongly suggest -- in the interest of sanity -- that you do not let a template-data section cross over a file boundary (i.e., define the begin in one file, and the end in another). It will work, if you understand what order the files are picked up, but I'd still avoid such tricks if I were you! If you want to insert some rules for a repo that is defined in a template-data section, you need to be careful where you place it. Rules defined by templates are deemed to occur exactly where the template definition is. So, speaking of repo foo, pretend that the line repo @is_public was replaced by repo foo , and similarly for repo @has_releases and repo @base . While we're on the subject, you can also pretend the role names on the right hand side of the rules are replaced by the actual user names you supplied in the template-data section. In the example above, say you wanted to insert a new rule for repo foo, which says that no one can rewind master , not even teamleads . Clearly, the rules you need are: repo foo RW master = sitaram # notice we had to expand 'teamleads' from foo's definition in the # template-data section - master = @all But where do you place them? The answer is, at least before the base template is defined . Otherwise, the RW+ in the base template will kick in, and this restriction will fail to take effect. Having said that, I would rather add a new template to deal with this, placing it just before repo @base ): repo @limits_master RW master = teamleads - master = @all and then add limits_master to the list of templates that foo uses. This has the advantages of being able to reuse that logic for other repos, but even more important, you're avoiding repeating the actual teamleads name(s) in more than one place! (Potentially a huge future inconsistency if someone forgot to update both places when the teamleads change!) You can also do multiple repos in one shot, as well as repo groups: # before the '=begin' line @repogroup1 = r1 r2 r3 ... ... ... =begin template-data repo foo bar @repogroup1 = base is_public has_releases ... ... ... =end","title":"usage and syntax"},{"location":"templates.html#bypassing-gitoliteconf-for-huge-sites","text":"Some sites have all their access control information in a web-based system, and generate gitolite.conf as needed. If they have tens of thousands of repos, this \"generated\" gitolite.conf becomes humongous, and slows down compiles. Worse, the more repos you have, the more churn you have in terms of changes to users accesses, so you do more compiles per hour than a smaller site, which only makes things worse! With this feature, you can bypass gitolite.conf and directly create/update those text files to change the users and rule-sets for a given repo. It doesn't even have to touch gitolite or gitolite.conf (assuming the templates and roles are already defined in gitolite.conf and ~/.gitolite.rc of course!)","title":"bypassing gitolite.conf for huge sites"},{"location":"templates.html#generating-the-text-files-externally","text":"The actual text files involved are very simple. Remember these files go into ~/repositories/$REPO.git (or more accurately, $(gitolite query-rc GL_REPO_BASE)/$REPO.git ). For the example above, here's the file gl-repo-groups in repo foo: $ cat ~/repositories/foo.git/gl-repo-groups base is_public has_releases As you can see, this text is just what is after the = sign in the repo line in the template data section of gitolite.conf. and the file gl-perms is: $ cat ~/repositories/foo.git/gl-perms teamleads = sitaram team = dilbert wally READERS = ashok release_managers = alice Again, this text is exactly the same as in the gitolite.conf!","title":"generating the text files externally"},{"location":"templates.html#creating-new-repos","text":"Gitolite has no mechanism to create repos out of thin air, so if you don't want to go via gitolite.conf, one way to do this is to add the following lines to the conf file (one-time): repo [a-zA-Z0-9].* C = gitolite-admin and then, at the server, run this: GL_USER=gitolite-admin gitolite create foo/bar That creates the repo, and you can now populate its gl-perms and gl-repo-groups files.","title":"creating new repos"},{"location":"templates.html#thanks-to","text":"...pingou on irc, and the Fedora project, for having 42,000 repos in a conf file over 560,000 lines long. Which made me think about this real hard for days, including two false starts (one of which I published and have just now reverted, and one which was so kludgey I refuse to acknowledge it exists -- thank God I did not publish that!)","title":"thanks to..."},{"location":"templates.html#miscellanea","text":"This feature is not the same as wild repos; repos here are created by the gitolite admin or a server-side backend, not by a gitolite user. (However, this feature piggy-backs on a lot of the code for wild repos, adding just a wee bit -- the \"duh\" comment earlier in this document -- to complete it).","title":"miscellanea"},{"location":"testing.html","text":"testing gitolite \uf0c1 WARNING: this will clobber these files and directories in your $HOME . Ideally, you should use a throwaway userid . Running gitolite's test suite is really just a superset of trying it out safely . To run the full test suite, create a throw-away userid , log in to it, then run these commands: git config --global include.path ~/.gitconfig.local git clone https://github.com/sitaramc/gitolite cd gitolite prove You will get an error that forces you to read t/README and set an env var before the test can proceed. This is intentional; I've had people who don't pay attention to the \"data loss\" warning, and then complain that it was not prominent enough. Forcing them to read a much smaller page appears to focus their attention better! The test suite should run fine on most recent Linuxes and Unixes. Although gitolite itself should work fine with any git after 1.6.6 or so, the test suite generally requires a more recent git. Make sure: $HOME/bin is in $PATH sshd allows incoming ssh to this userid, at least from localhost Gitolite's test suite is mostly written using tsh -- the \"testing shell\". Take a look at some of the scripts and you will see what it looks like. It has a few quirks and nuances, but it's fine for what I need here. The tests also use a somewhat convoluted system of environment variables in order to run entirely as a local user, without going through ssh at all. This lets a complete test suite run in about a lot less time than it would otherwise take. If you think that defeats the purpose of the testing, you haven't read this yet. appendix 1 -- the clobber list \uf0c1 When you try out gitolite or run the test suite, the following files and directories in your \\$HOME are potentially clobbered. .gitconfig .gitolite/ .gitolite.rc projects.list repositories/ .ssh/","title":"testing gitolite"},{"location":"testing.html#testing-gitolite","text":"WARNING: this will clobber these files and directories in your $HOME . Ideally, you should use a throwaway userid . Running gitolite's test suite is really just a superset of trying it out safely . To run the full test suite, create a throw-away userid , log in to it, then run these commands: git config --global include.path ~/.gitconfig.local git clone https://github.com/sitaramc/gitolite cd gitolite prove You will get an error that forces you to read t/README and set an env var before the test can proceed. This is intentional; I've had people who don't pay attention to the \"data loss\" warning, and then complain that it was not prominent enough. Forcing them to read a much smaller page appears to focus their attention better! The test suite should run fine on most recent Linuxes and Unixes. Although gitolite itself should work fine with any git after 1.6.6 or so, the test suite generally requires a more recent git. Make sure: $HOME/bin is in $PATH sshd allows incoming ssh to this userid, at least from localhost Gitolite's test suite is mostly written using tsh -- the \"testing shell\". Take a look at some of the scripts and you will see what it looks like. It has a few quirks and nuances, but it's fine for what I need here. The tests also use a somewhat convoluted system of environment variables in order to run entirely as a local user, without going through ssh at all. This lets a complete test suite run in about a lot less time than it would otherwise take. If you think that defeats the purpose of the testing, you haven't read this yet.","title":"testing gitolite"},{"location":"testing.html#appendix-1-the-clobber-list","text":"When you try out gitolite or run the test suite, the following files and directories in your \\$HOME are potentially clobbered. .gitconfig .gitolite/ .gitolite.rc projects.list repositories/ .ssh/","title":"appendix 1 -- the clobber list"},{"location":"triggers.html","text":"gitolite triggers \uf0c1 Gitolite runs trigger code at several different times. The features you enable in the rc file determine what commands to run (or functions in perl modules to call) at each trigger point. Example of trigger points are INPUT , PRE_GIT , POST_COMPILE , etc.; the full list is examined later in this page. Quick tip: triggers are to gitolite what hooks are to git; we simply use a different name to avoid constantly having to clarify which hooks we mean! The other difference in gitolite is that each trigger runs multiple pieces of code, not just one program with the same name as the hook, like git does. types of trigger programs \uf0c1 There are two types of trigger programs. Standalone scripts are placed in triggers or its subdirectories. Such scripts are quick and easy to write in any language of your choice. Triggers written as perl modules are placed in lib/Gitolite/Triggers. Perl modules have to follow some conventions (see some of the shipped modules for ideas) but the advantage is that they can set environment variables and change the argument list of the gitolite-shell program that invokes them. If you intend to write your own triggers, it's a good idea to examine a default install of gitolite, paying attention to: the path names in various trigger lists in the rc file, corresponding path names in the src/ directory in gitolite source, and for perl modules, the package names and function names within. manually firing triggers \uf0c1 It's easy to manually fire triggers from the server command line. For example: gitolite trigger POST_COMPILE However if the triggered code depends on arguments (see next section) this won't work. (The POST_COMPILE trigger programs all just happen to not require any arguments, so it works). common arguments \uf0c1 Triggers receive the following arguments: Any arguments mentioned in the rc file (for an example, see the renice command). The name of the trigger as a string (example, \"POST_COMPILE\" ), so you can call the same program from multiple triggers and it can know where it was called from. And finally, zero or more arguments specific to the trigger, as given in the next section. trigger-specific arguments and other details \uf0c1 Here are the rest of the arguments for each trigger, plus a brief description of when the trigger runs. (Note that when the repo name is passed in as an argument, it is without the '.git' suffix). INPUT runs before pretty much anything else. INPUT trigger scripts must be in perl, since they manipulate the arguments and the environment of the 'gitolite-shell' program itself. Most commonly they will read/change @ARGV , and/or $ENV{SSH_ORIGINAL_COMMAND} . There are certain conventions to adhere to; please see some of the shipped samples or ask me if you need help writing your own. ACCESS_1 runs after the first access check. Extra arguments: repo user 'R' or 'W' 'any' result (see notes below) 'result' is the return value of the access() function. If it contains the uppercase word \"DENIED\", the access was rejected. Otherwise it is the refex that caused the access to succeed. Note that if access is rejected, gitolite-shell will die as soon as it returns from the trigger. ACCESS_2 runs after the second access check, which is invoked by the update hook to check the ref. Extra arguments: repo user any of W, +, C, D, WM, +M, CM, DM the ref being updated (e.g., 'refs/heads/master') result old SHA new SHA ACCESS_2 also runs on each VREF that gets checked. In this case the \"ref\" argument will start with \"VREF/\", and the last two arguments won't be passed. 'result' is similar to ACCESS_1 , except that it is the update hook which dies as soon as access is rejected for the ref or any of the VREFs. Control then returns to git, and then to gitolite-shell, so the POST_GIT trigger will run. PRE_GIT and POST_GIT run just before and after the git command. Extra arguments: repo user 'R' or 'W' 'any' the git command ('git-receive-pack', 'git-upload-pack', or 'git-upload-archive') being invoked. Note that the POST_GIT trigger has no way of knowing if the push succeeded, because 'git-shell' (or maybe 'git-receive-pack', I don't know) exits cleanly even if the update hook died. PRE_CREATE and POST_CREATE run just before and after a new repo is created. In addition, any command that creates a repo (like 'fork') or potentially changes permissions (like 'perms') may choose to run POST_CREATE . Extra arguments for normal repo creation (i.e., by adding a \"repo foo\" line to the conf file): repo Extra arguments for wild repo creation: repo user invoking operation 'R' for fetch/clone/ls-remote, 'W' for push can also be anything set by the command running the trigger (e.g., see the perms and fork commands). This lets the trigger code know how it was invoked. POST_COMPILE runs after an admin push has successfully \"compiled\" the config file. By default, the next thing is to update the ssh authkeys file, then all the 'git-config's, gitweb access, and daemon access. No extra arguments. adding your own scripts to a trigger \uf0c1 Note: for gitolite v3.3 or less, adding your own scripts to a trigger list was simply a matter of finding the trigger name in the rc file and adding an entry to it. Even for gitolite v3.4 or higher, if your rc file was created before v3.4, it will continue to work, and you can continue to add triggers to it the same way as before . The rc file (from v3.4 on) does not have trigger lists; it has a simple list of \"features\" within a list called \"ENABLE\" in the rc file. Simply comment out or uncomment appropriate entries, and gitolite will internally create the trigger lists correctly. This is fine for triggers that are shipped with gitolite, but does present a problem when you want to add your own. Here's how to do that: Let's say you wrote yourself a trigger script called 'foo', to be invoked from the POST_CREATE trigger list. To do that, just add the following to the rc file, just before the ENABLE section: POST_CREATE => [ 'foo' ], Since the ENABLE list pulls in the rest of the trigger entries, this will be effectively as if you had done this in a v3.3 rc file: POST_CREATE => [ 'foo', 'post-compile/update-git-configs', 'post-compile/update-gitweb-access-list', 'post-compile/update-git-daemon-access-list', ], As you can see, the 'foo' gets added to the top of the list. adding a perl module as a trigger \uf0c1 If your trigger is a perl module, as opposed to a standalone script or executable, the process is almost the same as above, except what you add to the rc file it looks like this: POST_CREATE => [ 'Foo::post_create' ], Gitolite will add the Gitolite::Triggers:: prefix to the name given there. The subroutine to be run (in this example, post_create ) is looked for in the Gitolite::Triggers::Foo package, so this requires that the perl module start with a package header like this: package Gitolite::Triggers::Foo; displaying the resulting trigger list \uf0c1 You can use the 'gitolite query-rc' command to see what the trigger list actually looks like. For example: gitolite query-rc POST_CREATE tips and examples \uf0c1 If you have code that latches onto more than one trigger, collecting data (such as for logging), then the outputs may be intermixed. You can record the value of the environment variable GL_TID to tie together related entries. The documentation on the log file format has more on this. If you look at CpuTime.pm, you'll see that it's input() function doesn't set or change anything, but does set a package variable to record the start time. Later, when the same module's post_git() function is invoked, it uses this variable to determine elapsed time. (This is a very nice and simple example of how you can implement features by latching onto multiple events and sharing data to do something) . You can even change the reponame the user sees, behind his back. Alias.pm handles that. Finally, as an exercise for the reader, consider how you would create a brand new env var that contains the comment field of the ssh pubkey that was used to gain access, using the information here .","title":"gitolite triggers"},{"location":"triggers.html#gitolite-triggers","text":"Gitolite runs trigger code at several different times. The features you enable in the rc file determine what commands to run (or functions in perl modules to call) at each trigger point. Example of trigger points are INPUT , PRE_GIT , POST_COMPILE , etc.; the full list is examined later in this page. Quick tip: triggers are to gitolite what hooks are to git; we simply use a different name to avoid constantly having to clarify which hooks we mean! The other difference in gitolite is that each trigger runs multiple pieces of code, not just one program with the same name as the hook, like git does.","title":"gitolite triggers"},{"location":"triggers.html#types-of-trigger-programs","text":"There are two types of trigger programs. Standalone scripts are placed in triggers or its subdirectories. Such scripts are quick and easy to write in any language of your choice. Triggers written as perl modules are placed in lib/Gitolite/Triggers. Perl modules have to follow some conventions (see some of the shipped modules for ideas) but the advantage is that they can set environment variables and change the argument list of the gitolite-shell program that invokes them. If you intend to write your own triggers, it's a good idea to examine a default install of gitolite, paying attention to: the path names in various trigger lists in the rc file, corresponding path names in the src/ directory in gitolite source, and for perl modules, the package names and function names within.","title":"types of trigger programs"},{"location":"triggers.html#manually-firing-triggers","text":"It's easy to manually fire triggers from the server command line. For example: gitolite trigger POST_COMPILE However if the triggered code depends on arguments (see next section) this won't work. (The POST_COMPILE trigger programs all just happen to not require any arguments, so it works).","title":"manually firing triggers"},{"location":"triggers.html#common-arguments","text":"Triggers receive the following arguments: Any arguments mentioned in the rc file (for an example, see the renice command). The name of the trigger as a string (example, \"POST_COMPILE\" ), so you can call the same program from multiple triggers and it can know where it was called from. And finally, zero or more arguments specific to the trigger, as given in the next section.","title":"common arguments"},{"location":"triggers.html#trigger-specific-arguments-and-other-details","text":"Here are the rest of the arguments for each trigger, plus a brief description of when the trigger runs. (Note that when the repo name is passed in as an argument, it is without the '.git' suffix). INPUT runs before pretty much anything else. INPUT trigger scripts must be in perl, since they manipulate the arguments and the environment of the 'gitolite-shell' program itself. Most commonly they will read/change @ARGV , and/or $ENV{SSH_ORIGINAL_COMMAND} . There are certain conventions to adhere to; please see some of the shipped samples or ask me if you need help writing your own. ACCESS_1 runs after the first access check. Extra arguments: repo user 'R' or 'W' 'any' result (see notes below) 'result' is the return value of the access() function. If it contains the uppercase word \"DENIED\", the access was rejected. Otherwise it is the refex that caused the access to succeed. Note that if access is rejected, gitolite-shell will die as soon as it returns from the trigger. ACCESS_2 runs after the second access check, which is invoked by the update hook to check the ref. Extra arguments: repo user any of W, +, C, D, WM, +M, CM, DM the ref being updated (e.g., 'refs/heads/master') result old SHA new SHA ACCESS_2 also runs on each VREF that gets checked. In this case the \"ref\" argument will start with \"VREF/\", and the last two arguments won't be passed. 'result' is similar to ACCESS_1 , except that it is the update hook which dies as soon as access is rejected for the ref or any of the VREFs. Control then returns to git, and then to gitolite-shell, so the POST_GIT trigger will run. PRE_GIT and POST_GIT run just before and after the git command. Extra arguments: repo user 'R' or 'W' 'any' the git command ('git-receive-pack', 'git-upload-pack', or 'git-upload-archive') being invoked. Note that the POST_GIT trigger has no way of knowing if the push succeeded, because 'git-shell' (or maybe 'git-receive-pack', I don't know) exits cleanly even if the update hook died. PRE_CREATE and POST_CREATE run just before and after a new repo is created. In addition, any command that creates a repo (like 'fork') or potentially changes permissions (like 'perms') may choose to run POST_CREATE . Extra arguments for normal repo creation (i.e., by adding a \"repo foo\" line to the conf file): repo Extra arguments for wild repo creation: repo user invoking operation 'R' for fetch/clone/ls-remote, 'W' for push can also be anything set by the command running the trigger (e.g., see the perms and fork commands). This lets the trigger code know how it was invoked. POST_COMPILE runs after an admin push has successfully \"compiled\" the config file. By default, the next thing is to update the ssh authkeys file, then all the 'git-config's, gitweb access, and daemon access. No extra arguments.","title":"trigger-specific arguments and other details"},{"location":"triggers.html#adding-your-own-scripts-to-a-trigger","text":"Note: for gitolite v3.3 or less, adding your own scripts to a trigger list was simply a matter of finding the trigger name in the rc file and adding an entry to it. Even for gitolite v3.4 or higher, if your rc file was created before v3.4, it will continue to work, and you can continue to add triggers to it the same way as before . The rc file (from v3.4 on) does not have trigger lists; it has a simple list of \"features\" within a list called \"ENABLE\" in the rc file. Simply comment out or uncomment appropriate entries, and gitolite will internally create the trigger lists correctly. This is fine for triggers that are shipped with gitolite, but does present a problem when you want to add your own. Here's how to do that: Let's say you wrote yourself a trigger script called 'foo', to be invoked from the POST_CREATE trigger list. To do that, just add the following to the rc file, just before the ENABLE section: POST_CREATE => [ 'foo' ], Since the ENABLE list pulls in the rest of the trigger entries, this will be effectively as if you had done this in a v3.3 rc file: POST_CREATE => [ 'foo', 'post-compile/update-git-configs', 'post-compile/update-gitweb-access-list', 'post-compile/update-git-daemon-access-list', ], As you can see, the 'foo' gets added to the top of the list.","title":"adding your own scripts to a trigger"},{"location":"triggers.html#adding-a-perl-module-as-a-trigger","text":"If your trigger is a perl module, as opposed to a standalone script or executable, the process is almost the same as above, except what you add to the rc file it looks like this: POST_CREATE => [ 'Foo::post_create' ], Gitolite will add the Gitolite::Triggers:: prefix to the name given there. The subroutine to be run (in this example, post_create ) is looked for in the Gitolite::Triggers::Foo package, so this requires that the perl module start with a package header like this: package Gitolite::Triggers::Foo;","title":"adding a perl module as a trigger"},{"location":"triggers.html#displaying-the-resulting-trigger-list","text":"You can use the 'gitolite query-rc' command to see what the trigger list actually looks like. For example: gitolite query-rc POST_CREATE","title":"displaying the resulting trigger list"},{"location":"triggers.html#tips-and-examples","text":"If you have code that latches onto more than one trigger, collecting data (such as for logging), then the outputs may be intermixed. You can record the value of the environment variable GL_TID to tie together related entries. The documentation on the log file format has more on this. If you look at CpuTime.pm, you'll see that it's input() function doesn't set or change anything, but does set a package variable to record the start time. Later, when the same module's post_git() function is invoked, it uses this variable to determine elapsed time. (This is a very nice and simple example of how you can implement features by latching onto multiple events and sharing data to do something) . You can even change the reponame the user sees, behind his back. Alias.pm handles that. Finally, as an exercise for the reader, consider how you would create a brand new env var that contains the comment field of the ssh pubkey that was used to gain access, using the information here .","title":"tips and examples"},{"location":"user.html","text":"the users' view \uf0c1 This page talks about what gitolite looks like to non-admins, and the commands and features available to them. accessing gitolite \uf0c1 The most common setup is based on ssh, where your admin asks you to send him your public key, and uses that to setup your access. Your actual access is either a git command (like git clone git@server:reponame , or an ssh command (like ssh git@server info ). Note that you do not get a shell on the server -- the whole point of gitolite is to prevent that! Note to people who think gitolite requires or can only handle a specific syntax for the URL : Gitolite is designed in such a way that, unless there is an access violation, the client need not even know that something called gitolite is sitting between it and git on the server. In particular, this means any URL syntax listed in 'man git-clone' for ssh and/or http will work. The only things to note are: In ssh mode, you must use key-based authentication (i.e., passwords won't work; see the two pages linked from the ssh page for why). The path of the repo is what you put into the conf file (e.g., \"testing\", and not \"repositories/testing\" or \"/home/git/repositories/testing\" or such). A good rule of thumb is to use the exact name the info command (see below) shows you. The \".git\" at the end is optional for git commands (i.e., you can use \"testing.git\" instead of \"testing\" for clone, fetch, push, etc., if you like) but gitolite commands in general (see below) will not like the additional \".git\" at the end. the info command \uf0c1 The only command that is always available to every user is the info command (run ssh git@host info -h for help), which tells you what version of gitolite and git are on the server, and what repositories you have access to. The list of repos is very useful if you have doubts about the spelling of some new repo that you know was setup. normal and wild repos \uf0c1 Gitolite has two kinds of repos. Normal repos are specified by their full names in the config file. \"Wildcard\" repos are specified by a regex in the config file. Try the info command and see if it shows any lines that look like regex patterns, (with a \"C\" permission). If you see any, it means you are allowed to create brand new repos whose names fit that regex. Normally, you create such repos simply by cloning them or pushing to them -- gitolite automatically creates the repo on the server side. (If your site is different, your admin will tell you). When you create such a repo, your \"ownership\" of it (as far as gitolite is concerned) is automatically recorded by gitolite. other commands \uf0c1 set/get additional permissions for repos you created \uf0c1 The gitolite config may have several permissions lines for your repo, like so: repo pub/CREATOR/..* C = ...some list of users allowed to create repos... RW+ = CREATOR RW = user1 user2 R = user3 If that's all it had, you really can't do much. Any changes to access must be done by the administrator. (Note that \"CREATOR\" is a reserved word that gets expanded to your userid in some way, so the admin can literally add just the first three lines, and every user listed in the second line (or every authenticated user , if you specified @all there) has his own personal repo namespace, starting with pub/<username>/ ). To give some flexibility to users, the admin could add rules like this: RW = WRITERS R = READERS (he could also add other roles but then he needs to read the documentation). Once he does this, you can then use the perms command (run ssh git@host perms -h for help) to set permissions for other users by specifying which users are in the list of \"READERS\", and which in \"WRITERS\". If you think of READERS and WRITERS as \"roles\", it will help. You can't change what access a role has, but you can say which users have that role. Note: There isn't a way for you to see the actual rule list unless you're given read access to the special 'gitolite-admin' repo. Sorry. The idea is that your admin will tell you what \"roles\" he added into rules for your repos, and what permissions those roles have. adding a description to repos you created \uf0c1 The desc command is extremely simple. Run ssh git@host desc -h for help. \"site-local\" commands \uf0c1 The main purpose of gitolite is to prevent you from getting a shell. But there are commands that you often need to run on the server (i.e., cannot be done by pushing something to a repo). To enable this, gitolite allows the admin to setup scripts in a special directory that users can then run. Gitolite comes with a set of working scripts that your admin may install, or may use as a starting point for his own, if he chooses. Think of these commands as equivalent to those in COMMAND_DIR in man git-shell . You can get a list of available commands by running ssh git@host help . \"personal\" branches \uf0c1 \"personal\" branches are great for environments where developers need to share work but can't directly pull from each other (usually due to either a networking or authentication related reason, both common in corporate setups). Personal branches exist in a sub-tree of the ref/heads/[...] hierarchy. The syntax is RW+ personal /USER/ = @userlist where (a) the \"personal\" can be anything you like, but cannot be empty, (b) the \"/USER/\" part is necessary (including both slashes) , and (c) the trailing slash can be optionally followed by additional restrictions on the ref name. A user \"alice\" (if she's in the userlist) can then push any branches inside personal/alice/ (i.e., she can push personal/alice/foo and personal/alice/bar , but NOT personal/alice ). As another example personal/USER/[a-zA-Z0-9_]+$ would mean that alice can create personal/alice/foo , but not personal/alice/foo/bar , because a / is not allowed by the expression following the /USER/ . (Background: at runtime the \"USER\" component will be replaced by the name of the invoking user. Access is determined by the right hand side, as usual). Compared to using arbitrary branch names on the same server, this: Reduces namespace pollution by corralling all these ad hoc branches into the \"personal/\" namespace. Reduces branch name collision by giving each developer her own sub-hierarchy within that. Removes the need to think about access control, because a user can push only to his own sub-hierarchy.","title":"your users' view"},{"location":"user.html#the-users-view","text":"This page talks about what gitolite looks like to non-admins, and the commands and features available to them.","title":"the users' view"},{"location":"user.html#accessing-gitolite","text":"The most common setup is based on ssh, where your admin asks you to send him your public key, and uses that to setup your access. Your actual access is either a git command (like git clone git@server:reponame , or an ssh command (like ssh git@server info ). Note that you do not get a shell on the server -- the whole point of gitolite is to prevent that! Note to people who think gitolite requires or can only handle a specific syntax for the URL : Gitolite is designed in such a way that, unless there is an access violation, the client need not even know that something called gitolite is sitting between it and git on the server. In particular, this means any URL syntax listed in 'man git-clone' for ssh and/or http will work. The only things to note are: In ssh mode, you must use key-based authentication (i.e., passwords won't work; see the two pages linked from the ssh page for why). The path of the repo is what you put into the conf file (e.g., \"testing\", and not \"repositories/testing\" or \"/home/git/repositories/testing\" or such). A good rule of thumb is to use the exact name the info command (see below) shows you. The \".git\" at the end is optional for git commands (i.e., you can use \"testing.git\" instead of \"testing\" for clone, fetch, push, etc., if you like) but gitolite commands in general (see below) will not like the additional \".git\" at the end.","title":"accessing gitolite"},{"location":"user.html#the-info-command","text":"The only command that is always available to every user is the info command (run ssh git@host info -h for help), which tells you what version of gitolite and git are on the server, and what repositories you have access to. The list of repos is very useful if you have doubts about the spelling of some new repo that you know was setup.","title":"the info command"},{"location":"user.html#normal-and-wild-repos","text":"Gitolite has two kinds of repos. Normal repos are specified by their full names in the config file. \"Wildcard\" repos are specified by a regex in the config file. Try the info command and see if it shows any lines that look like regex patterns, (with a \"C\" permission). If you see any, it means you are allowed to create brand new repos whose names fit that regex. Normally, you create such repos simply by cloning them or pushing to them -- gitolite automatically creates the repo on the server side. (If your site is different, your admin will tell you). When you create such a repo, your \"ownership\" of it (as far as gitolite is concerned) is automatically recorded by gitolite.","title":"normal and wild repos"},{"location":"user.html#other-commands","text":"","title":"other commands"},{"location":"user.html#setget-additional-permissions-for-repos-you-created","text":"The gitolite config may have several permissions lines for your repo, like so: repo pub/CREATOR/..* C = ...some list of users allowed to create repos... RW+ = CREATOR RW = user1 user2 R = user3 If that's all it had, you really can't do much. Any changes to access must be done by the administrator. (Note that \"CREATOR\" is a reserved word that gets expanded to your userid in some way, so the admin can literally add just the first three lines, and every user listed in the second line (or every authenticated user , if you specified @all there) has his own personal repo namespace, starting with pub/<username>/ ). To give some flexibility to users, the admin could add rules like this: RW = WRITERS R = READERS (he could also add other roles but then he needs to read the documentation). Once he does this, you can then use the perms command (run ssh git@host perms -h for help) to set permissions for other users by specifying which users are in the list of \"READERS\", and which in \"WRITERS\". If you think of READERS and WRITERS as \"roles\", it will help. You can't change what access a role has, but you can say which users have that role. Note: There isn't a way for you to see the actual rule list unless you're given read access to the special 'gitolite-admin' repo. Sorry. The idea is that your admin will tell you what \"roles\" he added into rules for your repos, and what permissions those roles have.","title":"set/get additional permissions for repos you created"},{"location":"user.html#adding-a-description-to-repos-you-created","text":"The desc command is extremely simple. Run ssh git@host desc -h for help.","title":"adding a description to repos you created"},{"location":"user.html#site-local-commands","text":"The main purpose of gitolite is to prevent you from getting a shell. But there are commands that you often need to run on the server (i.e., cannot be done by pushing something to a repo). To enable this, gitolite allows the admin to setup scripts in a special directory that users can then run. Gitolite comes with a set of working scripts that your admin may install, or may use as a starting point for his own, if he chooses. Think of these commands as equivalent to those in COMMAND_DIR in man git-shell . You can get a list of available commands by running ssh git@host help .","title":"\"site-local\" commands"},{"location":"user.html#personal-branches","text":"\"personal\" branches are great for environments where developers need to share work but can't directly pull from each other (usually due to either a networking or authentication related reason, both common in corporate setups). Personal branches exist in a sub-tree of the ref/heads/[...] hierarchy. The syntax is RW+ personal /USER/ = @userlist where (a) the \"personal\" can be anything you like, but cannot be empty, (b) the \"/USER/\" part is necessary (including both slashes) , and (c) the trailing slash can be optionally followed by additional restrictions on the ref name. A user \"alice\" (if she's in the userlist) can then push any branches inside personal/alice/ (i.e., she can push personal/alice/foo and personal/alice/bar , but NOT personal/alice ). As another example personal/USER/[a-zA-Z0-9_]+$ would mean that alice can create personal/alice/foo , but not personal/alice/foo/bar , because a / is not allowed by the expression following the /USER/ . (Background: at runtime the \"USER\" component will be replaced by the name of the invoking user. Access is determined by the right hand side, as usual). Compared to using arbitrary branch names on the same server, this: Reduces namespace pollution by corralling all these ad hoc branches into the \"personal/\" namespace. Reduces branch name collision by giving each developer her own sub-hierarchy within that. Removes the need to think about access control, because a user can push only to his own sub-hierarchy.","title":"\"personal\" branches"},{"location":"vref-2.html","text":"virtual refs \uf0c1 (part 2) VREF-makers shipped with gitolite \uf0c1 restricting pushes by dir/file name \uf0c1 The \"NAME\" VREF allows you to restrict pushes by the names of dirs and files changed. (Side note: the NAME VREF is the only one directly implemented within the update hook, so you won't find it in the VREF directory). Here's an example. Say you don't want junior developers pushing changes to the Makefile, because it's quite complex: repo foo RW+ = @senior_devs RW = @junior_devs - VREF/ NAME/ Makefile = @junior_devs When a senior dev pushes, the VREF is not invoked at all. But when a junior dev pushes, the VREF is invoked, and it returns a list of files changed as virtual refs , looking like this: VREF/NAME/file-1 VREF/NAME/dir-2/file-3 ...etc... Each of these refs is matched against the access rules. If one of them happens to be the Makefile, then the ref returned ( VREF/NAME/Makefile ) will match the deny rule and kill the push. Another way to use this is when you know what is allowed instead of what is not allowed. Let's say the QA person is only allowed to touch a file called CHANGELOG and any files in a directory called ReleaseNotes: repo foo RW+ = @senior_devs RW = @junior_devs RW+ = QA-guy RW+ VREF/ NAME/ CHANGELOG = QA-guy RW+ VREF/ NAME/ ReleaseNotes/ = QA-guy - VREF/ NAME/ = QA-guy number of changed or new files \uf0c1 The COUNT VREF is used like this: - VREF/COUNT/9 = @junior-developers In response, if anyone in the user list pushes a commit series that changes more than 9 files, a virtual ref of VREF/COUNT/9 is returned. Gitolite uses that as a \"ref\" to match against all the rules, hits the same rule that invoked it, and denies the request. If the user did not push more than 9 files, the VREF code returns nothing, and nothing happens. COUNT can take one more argument: - VREF/COUNT/9/NEWFILES = @junior-developers This is the same as before, but have to be more than 9 new files not just changed files. advanced filetype detection \uf0c1 Note: this is more for illustration than use; it's rather specific to one of the projects I manage but the idea is the important thing. Sometimes a file has a standard extension (that cannot be 'gitignore'd), but it is actually automatically generated. Here's one way to catch it: - VREF/FILETYPE/AUTOGENERATED = @all You can look at src/VREF/FILETYPE to see how it handles the 'AUTOGENERATED' option. You could also have a more generic option, like perhaps BINARY, and handle that in the FILETYPE vref too. checking author email \uf0c1 Some people want to ensure that \"you can only push your own commits\". If you force it on everyone, this is a very silly idea (see \"Philosophical Notes\" section of src/VREF/EMAIL-CHECK ). But there may be value in enforcing it just for the junior developers. The neat thing is that the existing contrib/update.email-check was just copied to src/VREF/EMAIL-CHECK and it works, because VREFs get the same first 3 arguments and those are all that it cares about. (Note: you have to change one subroutine in that script if you want to use it) voting on commits \uf0c1 Although gitolite can't/won't do the whole \"code review + workflow enforcement\" thing that Gerrit Code Review does, a basic implementation of voting on a commit is surprisingly easy. See src/VREF/VOTES for details (and note that the actual code is just 2-3 lines; the rest is inline documentation). other ideas -- code welcome! \uf0c1 \"no non-merge first-parents\" \uf0c1 Shruggar on #gitolite wanted this. Possible code to implement it would be something like this (untested) [ -z \"$(git rev-list --first-parent --no-merges $2..$3)\" ] This can be implemented using src/VREF/MERGE-CHECK as a model. That script does what the 'M' qualifier does in access rules (see last part of this ), although the syntax to be used in conf/gitolite will be quite different. other ideas for VREFs \uf0c1 Here are some more ideas: Number of commits ( git rev-list --count $old $new ). Number of binary files in commit (currently I only know to count occurrences of Bin in the output of git diff --stat . Number of new binary files (count Bin 0 -> in git diff --stat output). Time of day/day of week (see example snippet somewhere above). IP address. Phase of the moon. Note that pretty much anything that involves $oldsha..$newsha will have to deal with the issue that when you push a new tag or branch, the \"old\" part is all 0's, and unless you consider --all existing branches and tags it becomes meaningless in terms of \"number of new files\" etc.","title":"virtual refs (part 2)"},{"location":"vref-2.html#virtual-refs","text":"(part 2)","title":"virtual refs"},{"location":"vref-2.html#vref-makers-shipped-with-gitolite","text":"","title":"VREF-makers shipped with gitolite"},{"location":"vref-2.html#restricting-pushes-by-dirfile-name","text":"The \"NAME\" VREF allows you to restrict pushes by the names of dirs and files changed. (Side note: the NAME VREF is the only one directly implemented within the update hook, so you won't find it in the VREF directory). Here's an example. Say you don't want junior developers pushing changes to the Makefile, because it's quite complex: repo foo RW+ = @senior_devs RW = @junior_devs - VREF/ NAME/ Makefile = @junior_devs When a senior dev pushes, the VREF is not invoked at all. But when a junior dev pushes, the VREF is invoked, and it returns a list of files changed as virtual refs , looking like this: VREF/NAME/file-1 VREF/NAME/dir-2/file-3 ...etc... Each of these refs is matched against the access rules. If one of them happens to be the Makefile, then the ref returned ( VREF/NAME/Makefile ) will match the deny rule and kill the push. Another way to use this is when you know what is allowed instead of what is not allowed. Let's say the QA person is only allowed to touch a file called CHANGELOG and any files in a directory called ReleaseNotes: repo foo RW+ = @senior_devs RW = @junior_devs RW+ = QA-guy RW+ VREF/ NAME/ CHANGELOG = QA-guy RW+ VREF/ NAME/ ReleaseNotes/ = QA-guy - VREF/ NAME/ = QA-guy","title":"restricting pushes by dir/file name"},{"location":"vref-2.html#number-of-changed-or-new-files","text":"The COUNT VREF is used like this: - VREF/COUNT/9 = @junior-developers In response, if anyone in the user list pushes a commit series that changes more than 9 files, a virtual ref of VREF/COUNT/9 is returned. Gitolite uses that as a \"ref\" to match against all the rules, hits the same rule that invoked it, and denies the request. If the user did not push more than 9 files, the VREF code returns nothing, and nothing happens. COUNT can take one more argument: - VREF/COUNT/9/NEWFILES = @junior-developers This is the same as before, but have to be more than 9 new files not just changed files.","title":"number of changed or new files"},{"location":"vref-2.html#advanced-filetype-detection","text":"Note: this is more for illustration than use; it's rather specific to one of the projects I manage but the idea is the important thing. Sometimes a file has a standard extension (that cannot be 'gitignore'd), but it is actually automatically generated. Here's one way to catch it: - VREF/FILETYPE/AUTOGENERATED = @all You can look at src/VREF/FILETYPE to see how it handles the 'AUTOGENERATED' option. You could also have a more generic option, like perhaps BINARY, and handle that in the FILETYPE vref too.","title":"advanced filetype detection"},{"location":"vref-2.html#checking-author-email","text":"Some people want to ensure that \"you can only push your own commits\". If you force it on everyone, this is a very silly idea (see \"Philosophical Notes\" section of src/VREF/EMAIL-CHECK ). But there may be value in enforcing it just for the junior developers. The neat thing is that the existing contrib/update.email-check was just copied to src/VREF/EMAIL-CHECK and it works, because VREFs get the same first 3 arguments and those are all that it cares about. (Note: you have to change one subroutine in that script if you want to use it)","title":"checking author email"},{"location":"vref-2.html#voting-on-commits","text":"Although gitolite can't/won't do the whole \"code review + workflow enforcement\" thing that Gerrit Code Review does, a basic implementation of voting on a commit is surprisingly easy. See src/VREF/VOTES for details (and note that the actual code is just 2-3 lines; the rest is inline documentation).","title":"voting on commits"},{"location":"vref-2.html#other-ideas-code-welcome","text":"","title":"other ideas -- code welcome!"},{"location":"vref-2.html#no-non-merge-first-parents","text":"Shruggar on #gitolite wanted this. Possible code to implement it would be something like this (untested) [ -z \"$(git rev-list --first-parent --no-merges $2..$3)\" ] This can be implemented using src/VREF/MERGE-CHECK as a model. That script does what the 'M' qualifier does in access rules (see last part of this ), although the syntax to be used in conf/gitolite will be quite different.","title":"\"no non-merge first-parents\""},{"location":"vref-2.html#other-ideas-for-vrefs","text":"Here are some more ideas: Number of commits ( git rev-list --count $old $new ). Number of binary files in commit (currently I only know to count occurrences of Bin in the output of git diff --stat . Number of new binary files (count Bin 0 -> in git diff --stat output). Time of day/day of week (see example snippet somewhere above). IP address. Phase of the moon. Note that pretty much anything that involves $oldsha..$newsha will have to deal with the issue that when you push a new tag or branch, the \"old\" part is all 0's, and unless you consider --all existing branches and tags it becomes meaningless in terms of \"number of new files\" etc.","title":"other ideas for VREFs"},{"location":"vref.html","text":"virtual refs \uf0c1 (part 1) VREFs are a mechanism to add additional constraints to a push. They are also the simplest way to add your old update hooks to gitolite -- they'll just work, no coding changes needed. If that's all you need, you should head over to the cookbook and look for the section on \"adding your own update hooks\". IMPORTANT: Fallthru is success in VREFs, unlike for normal refs. That won't make sense until you read further, but I had to put it up here for folks who stop reading halfway! quick intro/example \uf0c1 Here's an example to start you off. To disallow junior developers from changing more than five files, or from touching the Makefile, you can do this: repo foo RW+ = @all-devs - VREF/COUNT/5 = @junior-devs - VREF/ NAME/ Makefile = @junior-devs Here's a pictorial representation of what happens, at a very high level, based on the VREF/COUNT/5 rule in the rule list above. To start with, git-receive-pack calls the update hook with what we will call a \"real\" ref, something like \"refs/heads/master\", or \"refs/tags/v1.0\" -- in general, something that starts with \"refs/\". This ref is sent through \" check #2 \" (please click to refresh your memory if needed). Any rules that specify a refex starting with \"VREF/\" clearly won't match and are ignored in this check. Assuming that check did not fail, the gitolite code in the update hook then starts looking at each \"VREF\" rule in the rule list that applies to that repo accessed by that user. For each one, it runs the actual VREF program whose name is given in the word after VREF/ . (The rest of the words, if any, along with all sorts of other information, are supplied as arguments ). The STDOUT of the called program is captured and any line that starts with the characters VREF/ is taken as a \" virtual \" ref, and is run through the same \" check #2 \". The only difference is that, unlike for a regular ref, fallthru does not result in failure, but success. basic use and understanding \uf0c1 Normally, rules deal with branches and tags (which git collectively calls \"refs\"). The \"ref\" is a property of the push which gitolite checks against the set of rules. \"Virtual refs\" are other properties of a push that gitolite can be told to check, in addition to the normal ref. For example, \"this push has more than 5 changed files\" could be one property. Or \"this push changed the file called Makefile\" could be another. These properties are represented as \"virtual refs\" that start with VREF/ . (Recall that \"normal\" refs start with refs/ ). The simplest way to use them is as additional \"deny\" rules to fail a push that might otherwise have passed. This is what the example at the top shows. It helps to separate VREF rules from normal rules, since no access rule can match both a normal ref and a virtual ref. Here's a good way to structure your rules: Put your normal ref rules first. These apply to the branch name or tag name that git itself knows about and sends to gitolite's update hook. Fallthru is failure here, which means the ref being pushed must match some rule in this set for the push to succeed. Put your VREF rules next. These apply to the virtual refs you want to use as additional checks for the push. Fallthru is success here, which means the (virtual) ref must be explicitly denied in order for the push to fail. advanced use \uf0c1 More complex uses are possible, but may be harder to understand. You may want to experiment with the rules to solidify your understanding as you read this. differences from normal refs \uf0c1 We know where normal refs (like refs/heads/master or refs/tags/v1.0 ) come from -- they are supplied by git itself when it calls the update hook. Virtual refs have two differences with normal refs: Gitolite has to generate them somehow. Fallthru is success, not failure. Here's how it works. First, the normal (\"real\") ref is checked. As you already know, the push dies if the ref hits a deny rule or it falls through without hitting an allow rule. Next, virtual refs are generated and checked one by one. We'll talk about the generaton later, but for the check, a virtual ref kills the push only if it meets an explicit deny rule (\"-\"); fallthru does not cause failure. Other than that, the checking is done the same way as for a normal ref, viz., as described in the flow for check #2 . generating virtual refs \uf0c1 Gitolite uses the VREF rules themselves to help it generate the virtual refs. Specifically, it looks at each rule that contains a VREF (there are 2 in the above example) and calls a VREF-maker for each of them. We'll take the COUNT example rule above. When gitolite sees that rule, it calls the \"COUNT\" VREF-maker. Specifically, this is the VREF/COUNT program (See here for actual locations on disk). Gitolite passes it the string \"5\" as an argument (actually, as the eighth argument; details later). The program (which can be written in any language) is expected to do one of two things: If the condition is satisfied (i.e., there are more than 5 files in this push), it should print VREF/COUNT/5 to STDOUT. You can see that when this virtual ref is processed through the rules, it will encounter the \"deny\" rule, and thus kill the push. Otherwise it should print nothing. That is, there is no virtual ref to run through \" check #2 \", so nothing happens. It should exit with an exit code of zero in either case. If it exits with a non-zero, the push dies regardless of what is printed (see \"mimicking a plain old update hook\" for why this is useful). more details and nuances \uf0c1 mimicking a plain old update hook \uf0c1 If the VREF maker exits with a non-zero exit code, then regardless of what it prints or does not, the push dies. This is just like a plain 'update' hook. Since the first 3 arguments (see later) are also the same that a plain 'update' hook receives, you can actually use any existing update hook as a VREF-maker. To repurpose an existing update hook as a VREF-maker, just copy it to the VREF directory (again, see here for actual locations on disk). Then add this rule to your repos: repo foo # or maybe even 'repo @all' - VREF/my-update-hook = @all That's it. what if the VREF-maker prints a different virtual ref? \uf0c1 Unless you know what you're upto, don't do that. But it's allowed and the behaviour is defined. The VREF-maker for the NAME VREF is a good example. It ignores the arguments and just makes VREFs out of the name of every file that was changed in the push. Here's another example. Consider the problem of not allowing pushes at specific times. Let's say repo 'foo' cannot be pushed between 4 and 7pm, and repo 'bar' can only be pushed before 9am. And of course all this only applies to the junior developers, the poor guys! In this example, we write the \"Hour\" VREF-maker to ignore the argument passed and just print VREF/Hour/NN where NN can be between 00 to 23 inclusive and of course represents the current hour. If foo is pushed at 6:30pm, the VREF-maker prints VREF/Hour/18, which satisfies the third rule and is rejected. If bar is pushed at, say, 7:20am, the vref printed is VREF/Hour/07, which does not match any of the rules. And fallthru is success so it passes. repo foo RW+ = @all - VREF/Hour/16 = @junior-devs - VREF/Hour/17 = @junior-devs - VREF/Hour/18 = @junior-devs repo bar RW+ = @all - VREF/Hour/09 = @junior-devs - VREF/Hour/1[0-9] = @junior-devs - VREF/Hour/2[0-9] = @junior-devs why is fallthru considered success with VREFs \uf0c1 Virtual refs are best used (1) as additional \"deny\" rules, performing extra checks that core gitolite cannot. You usually want such extra checks only for some people. When fallthru is success, you can simply ignore all the other users (for whom such additional checks are not needed). If fallthru were to be considered 'failure', you'd be forced to add a \"success rule\" like this for every virtual ref you used in this repo, in each case listing every user who was not already mentioned in the context of that vref: RW+ VREF/VREFNAME = @userlist # uggh! what a pain! Worse, since every virtual ref involves calling an external program, many of these calls may be wasted. (1) \"best used as...\" does not mean \"only used as...\". For example it's perfectly easy to turn this around if, instead of having a list of people who do need extra checks, all you have is the complementary list: RW+ VREF/ NAME/ Makefile = @senior-devs - VREF/ NAME/ Makefile = @all what if the VREF-maker prints something that's not even a virtual ref? \uf0c1 The VREF-maker can print anything it wants to STDOUT. Lines not starting with VREF/ are printed as is (so your VREF-maker can do mostly-normal printing to STDOUT). This is especially useful if you've turned an existing update hook into a VREF-maker, and it prints stuff meant for the user, but you don't want to touch the code. For lines starting with VREF/ , the first word in each such line will be treated as a virtual ref, while the rest, if any, is a message to be added to the standard \"...DENIED...\" message that gitolite will print if that refex matches and the rule is a deny rule. in what order are VREF-makers called? \uf0c1 VREF-makers are called in the sequence in which they appear in the conf file. There are some optimisations to prevent calling the same VREF-maker with the same arguments more than once, and the VREF-maker code for the NAME VREF (which is special) is called only once regardless of how many times it appears but these details should not concern anyone but a developer. what arguments are passed to the vref-maker? \uf0c1 Arguments 1, 2, 3 : the ref , oldsha , and newsha that git passed to the update hook (see man githooks ). This, combined with the fact that non-zero exits are detected, mean that you can simply use an existing update.secondary as a VREF-maker as-is, no changes needed. Arguments 4 and 5 : the 'oldtree' and 'newtree' SHAs. These are the same as the oldsha and newsha values, except if one of them is all-0. (indicating a ref creation or deletion). In that case the corresponding 'tree' SHA is set (by gitolite, as a courtesy) to the special SHA 4b825dc642cb6eb9a060e54bf8d69288fbee4904 , which is the hash of an empty tree. (None of these shenanigans would have been needed if git diff $oldsha $newsha would not error out when passed an all-0 SHA.) Argument 6 : the attempted access flag. Typically W or + , but could also be C , D , or any of these 4 followed by M . If you have to ask what they mean, you haven't read enough gitolite documentation to be able to make virtual refs work. Argument 7 : is the entire refex; say VREF/COUNT/3/NEWFILES . Arguments 8 onward : are the split out (by / ) portions of the refex, excluding the first two components. In our example they would be 3 followed by NEWFILES . Yes, argument 7 is redundant if you have 8 and 9. It's just more convenient for scripts to have both available, without having to split/join.","title":"virtual refs (part 1)"},{"location":"vref.html#virtual-refs","text":"(part 1) VREFs are a mechanism to add additional constraints to a push. They are also the simplest way to add your old update hooks to gitolite -- they'll just work, no coding changes needed. If that's all you need, you should head over to the cookbook and look for the section on \"adding your own update hooks\". IMPORTANT: Fallthru is success in VREFs, unlike for normal refs. That won't make sense until you read further, but I had to put it up here for folks who stop reading halfway!","title":"virtual refs"},{"location":"vref.html#quick-introexample","text":"Here's an example to start you off. To disallow junior developers from changing more than five files, or from touching the Makefile, you can do this: repo foo RW+ = @all-devs - VREF/COUNT/5 = @junior-devs - VREF/ NAME/ Makefile = @junior-devs Here's a pictorial representation of what happens, at a very high level, based on the VREF/COUNT/5 rule in the rule list above. To start with, git-receive-pack calls the update hook with what we will call a \"real\" ref, something like \"refs/heads/master\", or \"refs/tags/v1.0\" -- in general, something that starts with \"refs/\". This ref is sent through \" check #2 \" (please click to refresh your memory if needed). Any rules that specify a refex starting with \"VREF/\" clearly won't match and are ignored in this check. Assuming that check did not fail, the gitolite code in the update hook then starts looking at each \"VREF\" rule in the rule list that applies to that repo accessed by that user. For each one, it runs the actual VREF program whose name is given in the word after VREF/ . (The rest of the words, if any, along with all sorts of other information, are supplied as arguments ). The STDOUT of the called program is captured and any line that starts with the characters VREF/ is taken as a \" virtual \" ref, and is run through the same \" check #2 \". The only difference is that, unlike for a regular ref, fallthru does not result in failure, but success.","title":"quick intro/example"},{"location":"vref.html#basic-use-and-understanding","text":"Normally, rules deal with branches and tags (which git collectively calls \"refs\"). The \"ref\" is a property of the push which gitolite checks against the set of rules. \"Virtual refs\" are other properties of a push that gitolite can be told to check, in addition to the normal ref. For example, \"this push has more than 5 changed files\" could be one property. Or \"this push changed the file called Makefile\" could be another. These properties are represented as \"virtual refs\" that start with VREF/ . (Recall that \"normal\" refs start with refs/ ). The simplest way to use them is as additional \"deny\" rules to fail a push that might otherwise have passed. This is what the example at the top shows. It helps to separate VREF rules from normal rules, since no access rule can match both a normal ref and a virtual ref. Here's a good way to structure your rules: Put your normal ref rules first. These apply to the branch name or tag name that git itself knows about and sends to gitolite's update hook. Fallthru is failure here, which means the ref being pushed must match some rule in this set for the push to succeed. Put your VREF rules next. These apply to the virtual refs you want to use as additional checks for the push. Fallthru is success here, which means the (virtual) ref must be explicitly denied in order for the push to fail.","title":"basic use and understanding"},{"location":"vref.html#advanced-use","text":"More complex uses are possible, but may be harder to understand. You may want to experiment with the rules to solidify your understanding as you read this.","title":"advanced use"},{"location":"vref.html#differences-from-normal-refs","text":"We know where normal refs (like refs/heads/master or refs/tags/v1.0 ) come from -- they are supplied by git itself when it calls the update hook. Virtual refs have two differences with normal refs: Gitolite has to generate them somehow. Fallthru is success, not failure. Here's how it works. First, the normal (\"real\") ref is checked. As you already know, the push dies if the ref hits a deny rule or it falls through without hitting an allow rule. Next, virtual refs are generated and checked one by one. We'll talk about the generaton later, but for the check, a virtual ref kills the push only if it meets an explicit deny rule (\"-\"); fallthru does not cause failure. Other than that, the checking is done the same way as for a normal ref, viz., as described in the flow for check #2 .","title":"differences from normal refs"},{"location":"vref.html#generating-virtual-refs","text":"Gitolite uses the VREF rules themselves to help it generate the virtual refs. Specifically, it looks at each rule that contains a VREF (there are 2 in the above example) and calls a VREF-maker for each of them. We'll take the COUNT example rule above. When gitolite sees that rule, it calls the \"COUNT\" VREF-maker. Specifically, this is the VREF/COUNT program (See here for actual locations on disk). Gitolite passes it the string \"5\" as an argument (actually, as the eighth argument; details later). The program (which can be written in any language) is expected to do one of two things: If the condition is satisfied (i.e., there are more than 5 files in this push), it should print VREF/COUNT/5 to STDOUT. You can see that when this virtual ref is processed through the rules, it will encounter the \"deny\" rule, and thus kill the push. Otherwise it should print nothing. That is, there is no virtual ref to run through \" check #2 \", so nothing happens. It should exit with an exit code of zero in either case. If it exits with a non-zero, the push dies regardless of what is printed (see \"mimicking a plain old update hook\" for why this is useful).","title":"generating virtual refs"},{"location":"vref.html#more-details-and-nuances","text":"","title":"more details and nuances"},{"location":"vref.html#mimicking-a-plain-old-update-hook","text":"If the VREF maker exits with a non-zero exit code, then regardless of what it prints or does not, the push dies. This is just like a plain 'update' hook. Since the first 3 arguments (see later) are also the same that a plain 'update' hook receives, you can actually use any existing update hook as a VREF-maker. To repurpose an existing update hook as a VREF-maker, just copy it to the VREF directory (again, see here for actual locations on disk). Then add this rule to your repos: repo foo # or maybe even 'repo @all' - VREF/my-update-hook = @all That's it.","title":"mimicking a plain old update hook"},{"location":"vref.html#what-if-the-vref-maker-prints-a-different-virtual-ref","text":"Unless you know what you're upto, don't do that. But it's allowed and the behaviour is defined. The VREF-maker for the NAME VREF is a good example. It ignores the arguments and just makes VREFs out of the name of every file that was changed in the push. Here's another example. Consider the problem of not allowing pushes at specific times. Let's say repo 'foo' cannot be pushed between 4 and 7pm, and repo 'bar' can only be pushed before 9am. And of course all this only applies to the junior developers, the poor guys! In this example, we write the \"Hour\" VREF-maker to ignore the argument passed and just print VREF/Hour/NN where NN can be between 00 to 23 inclusive and of course represents the current hour. If foo is pushed at 6:30pm, the VREF-maker prints VREF/Hour/18, which satisfies the third rule and is rejected. If bar is pushed at, say, 7:20am, the vref printed is VREF/Hour/07, which does not match any of the rules. And fallthru is success so it passes. repo foo RW+ = @all - VREF/Hour/16 = @junior-devs - VREF/Hour/17 = @junior-devs - VREF/Hour/18 = @junior-devs repo bar RW+ = @all - VREF/Hour/09 = @junior-devs - VREF/Hour/1[0-9] = @junior-devs - VREF/Hour/2[0-9] = @junior-devs","title":"what if the VREF-maker prints a different virtual ref?"},{"location":"vref.html#why-is-fallthru-considered-success-with-vrefs","text":"Virtual refs are best used (1) as additional \"deny\" rules, performing extra checks that core gitolite cannot. You usually want such extra checks only for some people. When fallthru is success, you can simply ignore all the other users (for whom such additional checks are not needed). If fallthru were to be considered 'failure', you'd be forced to add a \"success rule\" like this for every virtual ref you used in this repo, in each case listing every user who was not already mentioned in the context of that vref: RW+ VREF/VREFNAME = @userlist # uggh! what a pain! Worse, since every virtual ref involves calling an external program, many of these calls may be wasted. (1) \"best used as...\" does not mean \"only used as...\". For example it's perfectly easy to turn this around if, instead of having a list of people who do need extra checks, all you have is the complementary list: RW+ VREF/ NAME/ Makefile = @senior-devs - VREF/ NAME/ Makefile = @all","title":"why is fallthru considered success with VREFs"},{"location":"vref.html#what-if-the-vref-maker-prints-something-thats-not-even-a-virtual-ref","text":"The VREF-maker can print anything it wants to STDOUT. Lines not starting with VREF/ are printed as is (so your VREF-maker can do mostly-normal printing to STDOUT). This is especially useful if you've turned an existing update hook into a VREF-maker, and it prints stuff meant for the user, but you don't want to touch the code. For lines starting with VREF/ , the first word in each such line will be treated as a virtual ref, while the rest, if any, is a message to be added to the standard \"...DENIED...\" message that gitolite will print if that refex matches and the rule is a deny rule.","title":"what if the VREF-maker prints something that's not even a virtual ref?"},{"location":"vref.html#in-what-order-are-vref-makers-called","text":"VREF-makers are called in the sequence in which they appear in the conf file. There are some optimisations to prevent calling the same VREF-maker with the same arguments more than once, and the VREF-maker code for the NAME VREF (which is special) is called only once regardless of how many times it appears but these details should not concern anyone but a developer.","title":"in what order are VREF-makers called?"},{"location":"vref.html#what-arguments-are-passed-to-the-vref-maker","text":"Arguments 1, 2, 3 : the ref , oldsha , and newsha that git passed to the update hook (see man githooks ). This, combined with the fact that non-zero exits are detected, mean that you can simply use an existing update.secondary as a VREF-maker as-is, no changes needed. Arguments 4 and 5 : the 'oldtree' and 'newtree' SHAs. These are the same as the oldsha and newsha values, except if one of them is all-0. (indicating a ref creation or deletion). In that case the corresponding 'tree' SHA is set (by gitolite, as a courtesy) to the special SHA 4b825dc642cb6eb9a060e54bf8d69288fbee4904 , which is the hash of an empty tree. (None of these shenanigans would have been needed if git diff $oldsha $newsha would not error out when passed an all-0 SHA.) Argument 6 : the attempted access flag. Typically W or + , but could also be C , D , or any of these 4 followed by M . If you have to ask what they mean, you haven't read enough gitolite documentation to be able to make virtual refs work. Argument 7 : is the entire refex; say VREF/COUNT/3/NEWFILES . Arguments 8 onward : are the split out (by / ) portions of the refex, excluding the first two components. In our example they would be 3 followed by NEWFILES . Yes, argument 7 is redundant if you have 8 and 9. It's just more convenient for scripts to have both available, without having to split/join.","title":"what arguments are passed to the vref-maker?"},{"location":"wild.html","text":"\"wild\" repos (user created repos) \uf0c1 The wildrepos feature allows you to specify access control rules using regular expression patterns, so you can have many actual repos being served by a single set of rules in the config file. The regex can also include the word CREATOR in it, allowing you to parametrise the name of the user creating the repo. quick intro/example \uf0c1 If you're curious about the feature but you aren't sure if you want to read the whole page, here's a very simple example. This is what the admin added to the conf file: @users = u1 u2 u3 repo foo/CREATOR/[a-z]..* C = u1 u2 u3 RW+ = CREATOR RW = WRITERS R = READERS User 'u1' then runs git clone git@host:foo/u1/bar , creating the repo. Notice the repo name matches the regex, if you substitute the user's name for the word CREATOR. This is the effective rule list for 'foo/u1/bar' immediately after the user creates it: repo foo/u1/bar RW+ = u1 RW = WRITERS R = READERS Most of this is fixed, but the creator (user 'u1') can use the perms command to add other users as 'READERS' or 'WRITERS'. For example he could add 'u2' as a writer and 'u3' and 'u5' as readers: This is the effective rule list that applies to the repo if he does that: repo foo/u1/bar RW+ = u1 RW = u2 R = u3 u5 Note that both these \"effective rule lists\" were created without touching the actual conf file or any admin intervention. And that's it for our quick intro example. The rest of this page will explain all this in much more detail. declaring wild repos in the conf file \uf0c1 Here's a slightly more detailed example, starting with what the admin puts in the conf file: @prof = u1 @TAs = u2 u3 @students = u4 u5 u6 repo assignments/CREATOR/a[0-9][0-9] C = @students RW+ = CREATOR RW = WRITERS @TAs R = READERS @prof Note the \"C\" permission. This is a standalone \"C\", which gives the named users the right to create a repo . This is not to be confused with the \"RWC\" permission or its variants described elsewhere , which are about creating branches , not repos . ( user ) creating a specific repo \uf0c1 For now, ignore the special usernames READERS and WRITERS, and just create a new repo, as user \"u4\" (a student): $ git clone git@server:assignments/u4/a12 Initialized empty Git repository in /home/git/repositories/assignments/u4/a12.git/ warning: You appear to have cloned an empty repository. a slightly different example \uf0c1 Here's how the same example would look if you did not want the CREATOR's name to be part of the actual repo name. repo assignments/a[0-9][0-9] C = @students RW+ = CREATOR RW = WRITERS @TAs R = READERS @prof We haven't changed anything except the repo name regex. This means that the first student that creates, say, assignments/a12 becomes the owner. Mistakes (such as claiming a12 instead of a13) need to be rectified by an admin logging on to the back end, though it's not too difficult. You could also replace the C line like this: C = @TAs and have a TA create the repos in advance. repo regex patterns \uf0c1 regex pattern versus normal repo \uf0c1 Due to projects like gtk+ , the + character is now considered a valid character for an ordinary repo. Therefore, a regex like foo/.+ does not look like a regex to gitolite. Use foo/..* if you want that. Also, ..* by itself is not considered a valid repo regex. Try [a-zA-Z0-9].* . CREATOR/..* will also work. line-anchored regexes \uf0c1 A regex like repo assignments/S[0-9]+/A[0-9]+ would match assignments/S02/A37 . It will not match assignments/S02/ABC , or assignments/S02/a37 , obviously. But you may be surprised to find that it does not match even assignments/S02/A37/B99 . This is because internally, gitolite line-anchors the given regex; so that regex actually becomes ^assignments/S[0-9]+/A[0-9]+$ -- notice the line beginning and ending metacharacters. Side-note: contrast with refexes Just for interest, note that this is in contrast to the refexes for the normal \"branch\" permissions. Refexes are only anchored at the start; a regex like refs/heads/master actually can match refs/heads/master01/bar as well, even if no one will actually push such a branch! You can anchor both sides if you really care, by using master$ instead of master , but that is not the default for refexes. roles \uf0c1 The words READERS and WRITERS are called \"role\" names. The access rules in the conf file decide what permissions these roles have, but they don't say what users are in each of these roles. That needs to be done by the creator of the repo, using the perms command. You can run ssh git@host perms -h for detailed help, but in brief, that command lets you give and take away roles to users. This has some more detail. adding other roles \uf0c1 If you want to have more than just the 2 default roles, say something like: You can add the new names to the ROLES hash in the rc file ; see comments in that file for how to do that. Be sure to run the 2 commands mentioned there after you have added the roles. repo foo/..* C = u1 RW refs/tags/ = TESTERS - refs/tags/ = @all RW+ = WRITERS RW = INTERNS R = READERS RW+D = MANAGERS IMPORTANT WARNING ABOUT THIS FEATURE \uf0c1 Please make sure that none of the role names conflict with any of the user names or group names in the system. For example, if you have a user called \"foo\" or a group called \"@foo\", make sure you do not include \"foo\" as a valid role in the ROLES hash. You can keep things sane by using UPPERCASE names for roles, while keeping all your user and group names lowercase; then you don't have to worry about this problem. setting default roles \uf0c1 You can setup some default role assignments as soon as a new wild repo is created. Here's how: Enable the 'set-default-roles' feature in the rc file by uncommenting it if it is already present or adding it to the ENABLE list if it is not. Supply a set of default role assignments for a wild repo regex by adding lines like this to the repo config para: option default.roles-1 = READERS @all option default.roles-2 = WRITERS @senior-devs This will then behave as if the perms command was used immediately after the repo was created to add those two role assignments. If you want to simulate the old (pre v3.5) DEFAULT_ROLE_PERMS rc file variable, just add them under a repo @all line. (Remember that this only affects newly created wild repos, despite the '@all' name). specifying owners \uf0c1 See the section on OWNER_ROLENAME in the rc file page . listing wild repos \uf0c1 In order to see what repositories were created from a wildcard, use the 'info' command. Try ssh git@host info -h to get help on the info command. deleting a wild repo \uf0c1 Run the whimsically named \"D\" command -- try ssh git@host D -h for more info on how to delete a wild repo. (Yes the command is \"D\"; it's meant to be a counterpart to the \"C\" permission that allowed you to create the repo in the first place). Of course this only works if your admin has enabled the command (gitolite ships with the command disabled for remote use). appendix 1: owner and creator \uf0c1 A wild repo is created by one specific user. This user is usually called the creator of the repo: his username is placed in a file called gl-creator in the (bare) repo directory, any permissions given in the gitolite.conf file to \"CREATOR\" will be applicable to this user, he is the only person who can give permissions to other users (by running the 'perms' command), etc. But, as I said in this mail : Until about a year ago, Gitolite only knew the concept of a \"creator\", and there was only one. But then people started seeing the need for more than one \"owner\", because wild repos may be *created* by one person, but they often needed to be *administered* by one of several people. So now, even though large parts of the documentation probably conflate \"creator\" and \"owner\", you can see wild.html ([wild]) and rc.html ([rc]) to actually understand how this larger group become the \"owner\".","title":"ad hoc user-created (\"wild\") repos"},{"location":"wild.html#wild-repos-user-created-repos","text":"The wildrepos feature allows you to specify access control rules using regular expression patterns, so you can have many actual repos being served by a single set of rules in the config file. The regex can also include the word CREATOR in it, allowing you to parametrise the name of the user creating the repo.","title":"\"wild\" repos (user created repos)"},{"location":"wild.html#quick-introexample","text":"If you're curious about the feature but you aren't sure if you want to read the whole page, here's a very simple example. This is what the admin added to the conf file: @users = u1 u2 u3 repo foo/CREATOR/[a-z]..* C = u1 u2 u3 RW+ = CREATOR RW = WRITERS R = READERS User 'u1' then runs git clone git@host:foo/u1/bar , creating the repo. Notice the repo name matches the regex, if you substitute the user's name for the word CREATOR. This is the effective rule list for 'foo/u1/bar' immediately after the user creates it: repo foo/u1/bar RW+ = u1 RW = WRITERS R = READERS Most of this is fixed, but the creator (user 'u1') can use the perms command to add other users as 'READERS' or 'WRITERS'. For example he could add 'u2' as a writer and 'u3' and 'u5' as readers: This is the effective rule list that applies to the repo if he does that: repo foo/u1/bar RW+ = u1 RW = u2 R = u3 u5 Note that both these \"effective rule lists\" were created without touching the actual conf file or any admin intervention. And that's it for our quick intro example. The rest of this page will explain all this in much more detail.","title":"quick intro/example"},{"location":"wild.html#declaring-wild-repos-in-the-conf-file","text":"Here's a slightly more detailed example, starting with what the admin puts in the conf file: @prof = u1 @TAs = u2 u3 @students = u4 u5 u6 repo assignments/CREATOR/a[0-9][0-9] C = @students RW+ = CREATOR RW = WRITERS @TAs R = READERS @prof Note the \"C\" permission. This is a standalone \"C\", which gives the named users the right to create a repo . This is not to be confused with the \"RWC\" permission or its variants described elsewhere , which are about creating branches , not repos .","title":"declaring wild repos in the conf file"},{"location":"wild.html#user-creating-a-specific-repo","text":"For now, ignore the special usernames READERS and WRITERS, and just create a new repo, as user \"u4\" (a student): $ git clone git@server:assignments/u4/a12 Initialized empty Git repository in /home/git/repositories/assignments/u4/a12.git/ warning: You appear to have cloned an empty repository.","title":"(user) creating a specific repo"},{"location":"wild.html#a-slightly-different-example","text":"Here's how the same example would look if you did not want the CREATOR's name to be part of the actual repo name. repo assignments/a[0-9][0-9] C = @students RW+ = CREATOR RW = WRITERS @TAs R = READERS @prof We haven't changed anything except the repo name regex. This means that the first student that creates, say, assignments/a12 becomes the owner. Mistakes (such as claiming a12 instead of a13) need to be rectified by an admin logging on to the back end, though it's not too difficult. You could also replace the C line like this: C = @TAs and have a TA create the repos in advance.","title":"a slightly different example"},{"location":"wild.html#repo-regex-patterns","text":"","title":"repo regex patterns"},{"location":"wild.html#regex-pattern-versus-normal-repo","text":"Due to projects like gtk+ , the + character is now considered a valid character for an ordinary repo. Therefore, a regex like foo/.+ does not look like a regex to gitolite. Use foo/..* if you want that. Also, ..* by itself is not considered a valid repo regex. Try [a-zA-Z0-9].* . CREATOR/..* will also work.","title":"regex pattern versus normal repo"},{"location":"wild.html#line-anchored-regexes","text":"A regex like repo assignments/S[0-9]+/A[0-9]+ would match assignments/S02/A37 . It will not match assignments/S02/ABC , or assignments/S02/a37 , obviously. But you may be surprised to find that it does not match even assignments/S02/A37/B99 . This is because internally, gitolite line-anchors the given regex; so that regex actually becomes ^assignments/S[0-9]+/A[0-9]+$ -- notice the line beginning and ending metacharacters. Side-note: contrast with refexes Just for interest, note that this is in contrast to the refexes for the normal \"branch\" permissions. Refexes are only anchored at the start; a regex like refs/heads/master actually can match refs/heads/master01/bar as well, even if no one will actually push such a branch! You can anchor both sides if you really care, by using master$ instead of master , but that is not the default for refexes.","title":"line-anchored regexes"},{"location":"wild.html#roles","text":"The words READERS and WRITERS are called \"role\" names. The access rules in the conf file decide what permissions these roles have, but they don't say what users are in each of these roles. That needs to be done by the creator of the repo, using the perms command. You can run ssh git@host perms -h for detailed help, but in brief, that command lets you give and take away roles to users. This has some more detail.","title":"roles"},{"location":"wild.html#adding-other-roles","text":"If you want to have more than just the 2 default roles, say something like: You can add the new names to the ROLES hash in the rc file ; see comments in that file for how to do that. Be sure to run the 2 commands mentioned there after you have added the roles. repo foo/..* C = u1 RW refs/tags/ = TESTERS - refs/tags/ = @all RW+ = WRITERS RW = INTERNS R = READERS RW+D = MANAGERS","title":"adding other roles"},{"location":"wild.html#important-warning-about-this-feature","text":"Please make sure that none of the role names conflict with any of the user names or group names in the system. For example, if you have a user called \"foo\" or a group called \"@foo\", make sure you do not include \"foo\" as a valid role in the ROLES hash. You can keep things sane by using UPPERCASE names for roles, while keeping all your user and group names lowercase; then you don't have to worry about this problem.","title":"IMPORTANT WARNING ABOUT THIS FEATURE"},{"location":"wild.html#setting-default-roles","text":"You can setup some default role assignments as soon as a new wild repo is created. Here's how: Enable the 'set-default-roles' feature in the rc file by uncommenting it if it is already present or adding it to the ENABLE list if it is not. Supply a set of default role assignments for a wild repo regex by adding lines like this to the repo config para: option default.roles-1 = READERS @all option default.roles-2 = WRITERS @senior-devs This will then behave as if the perms command was used immediately after the repo was created to add those two role assignments. If you want to simulate the old (pre v3.5) DEFAULT_ROLE_PERMS rc file variable, just add them under a repo @all line. (Remember that this only affects newly created wild repos, despite the '@all' name).","title":"setting default roles"},{"location":"wild.html#specifying-owners","text":"See the section on OWNER_ROLENAME in the rc file page .","title":"specifying owners"},{"location":"wild.html#listing-wild-repos","text":"In order to see what repositories were created from a wildcard, use the 'info' command. Try ssh git@host info -h to get help on the info command.","title":"listing wild repos"},{"location":"wild.html#deleting-a-wild-repo","text":"Run the whimsically named \"D\" command -- try ssh git@host D -h for more info on how to delete a wild repo. (Yes the command is \"D\"; it's meant to be a counterpart to the \"C\" permission that allowed you to create the repo in the first place). Of course this only works if your admin has enabled the command (gitolite ships with the command disabled for remote use).","title":"deleting a wild repo"},{"location":"wild.html#appendix-1-owner-and-creator","text":"A wild repo is created by one specific user. This user is usually called the creator of the repo: his username is placed in a file called gl-creator in the (bare) repo directory, any permissions given in the gitolite.conf file to \"CREATOR\" will be applicable to this user, he is the only person who can give permissions to other users (by running the 'perms' command), etc. But, as I said in this mail : Until about a year ago, Gitolite only knew the concept of a \"creator\", and there was only one. But then people started seeing the need for more than one \"owner\", because wild repos may be *created* by one person, but they often needed to be *administered* by one of several people. So now, even though large parts of the documentation probably conflate \"creator\" and \"owner\", you can see wild.html ([wild]) and rc.html ([rc]) to actually understand how this larger group become the \"owner\".","title":"appendix 1: owner and creator"},{"location":"contrib/README-emacs.html","text":"Emacs major mode for gitolite.conf \uf0c1 Emacs major mode for gitolite.conf can be found here: GitHub","title":"Emacs major mode"},{"location":"contrib/README-emacs.html#emacs-major-mode-for-gitoliteconf","text":"Emacs major mode for gitolite.conf can be found here: GitHub","title":"Emacs major mode for gitolite.conf"},{"location":"contrib/putty.html","text":"putty and msysgit \uf0c1 Copyright: Thomas Berezansky (tsbere (at) mvlc (dot) org). Licensed under CC-BY-SA unported 3.0, https://creativecommons.org/licenses/by-sa/3.0/ This document is intended for those who wish to use Putty/Plink with msysgit. If you need more help with putty or component programs I suggest looking at the official putty documentation . If you are not already using Putty for SSH it is recommended you do NOT use it with msysgit. Please note that this only covers the client side of things, and does not involve server side components to troubleshooting. For that, please see the ssh-troubleshooting document . msysgit setup \uf0c1 Provided you have putty sessions msysgit should give you the option of specifying a location to plink. If it did not then you will need to add an environment variable named \"GIT_SSH\" to point at plink.exe, wherever you have that sitting. How to do that on your version of windows will likely vary, and is not covered here. For purposes of example, on a 64 bit Windows Vista machine the GIT_SSH value could be: C:\\Program Files (x86)\\PuTTY\\plink.exe Note the lack of quotes. Testing that msysgit is properly configured can be done from the git bash shell. Simply type (case sensitive, include the quotes): \"$GIT_SSH\" -V You should get a response similar to this: plink: Release 0.60 If instead you get a \"command not found\" type error you likely have a typo in your environment variable. Going back to OpenSSH \uf0c1 If you wish to go back to OpenSSH all you need to do is delete the GIT_SSH environment variable. This will vary by your version of windows and thus is not covered here. Putty keys \uf0c1 If you do not already have putty private key files (.ppk) you will need to make at least one. You can either make a new one or convert an existing key to putty private key format. Either way, you will want to use puttygen. Note that you can go the other way if you want to stop using putty but keep the key by exporting the key to OpenSSH format. Creating a new key \uf0c1 To make it simple, I suggest SSH-2 RSA and a bit size of at least 1024. Larger keys will take longer to generate and will take longer to authenticate you on most systems. Making the key is as simple at hitting \"Generate\". It is recommended to give the key a meaningful comment. Importing an existing key \uf0c1 If you already have an OpenSSH or ssh.com key you can import it using the \"Import\" option on the \"Conversions\" menu. If the key does not have a meaningful comment I would suggest adding one at this point. Loading an existing key \uf0c1 If you need to load an existing key to edit or view it you can do so from the File menu. Public key \uf0c1 To get your public key for use with gitolite, load (or generate, or import) your key into puttygen. There is a box labeled \"Public key for pasting into OpenSSH authorized_keys file\" there. Copy the text into your preferred text editor and save. Putty ageant \uf0c1 Though not required in all cases you may wish to use the putty ageant, pageant, to load your key(s). This will allow for your key(s) to be passphrase protected but not have to enter the passphrase when you go to use them, provided you have already loaded the key into the ageant. Sessionless or raw hostname usage \uf0c1 When using plink without a putty session you pretty much have to load your keys with putty ageant, if only so that plink can find them. Putty sessions \uf0c1 In addition to hostnames msysgit can, when using putty, use putty sessions. This works in a manner similar to definitions in OpenSSH's ssh_config file. All settings in the session that apply to plink usage will be loaded, including the key file to use and even the username to connect to. Thus, instead of: ssh://user@host.example.ext:port/repo You can use: ssh://session_name/repo Host key authentication \uf0c1 Whether you are using hostnames or sessions you still run into one potential problem. Plink currently wants to validate the server's SSH host key before allowing you to connect, and when git calls plink there is no way to tell it yes. Thus, you may get something like this: The server's host key is not cached in the registry. You have no guarantee that the server is the computer you think it is. The server's rsa2 key fingerprint is: ssh-rsa 2048 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 Connection abandoned. fatal: The remote end hung up unexpectedly Or, in the case of the host key changing, something like this: WARNING - POTENTIAL SECURITY BREACH! The server's host key does not match the one PuTTY has cached in the registry. This means that either the server administrator has changed the host key, or you have actually connected to another computer pretending to be the server. The new rsa2 key fingerprint is: ssh-rsa 2048 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 Connection abandoned. fatal: The remote end hung up unexpectedly The solution is to call plink directly, or start putty and connect with it first. To use plink, open the Git Bash shell and enter: \"$GIT_SSH\" hostname_or_session_name When you do you will see something like this: The server's host key is not cached in the registry. You have no guarantee that the server is the computer you think it is. The server's rsa2 key fingerprint is: ssh-rsa 2048 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 If you trust this host, enter \"y\" to add the key to PuTTY's cache and carry on connecting. If you want to carry on connecting just once, without adding the key to the cache, enter \"n\". If you do not trust this host, press Return to abandon the connection. Store key in cache? (y/n) Or, in the case of a changed key, a response like this: WARNING - POTENTIAL SECURITY BREACH! The server's host key does not match the one PuTTY has cached in the registry. This means that either the server administrator has changed the host key, or you have actually connected to another computer pretending to be the server. The new rsa2 key fingerprint is: ssh-rsa 2048 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 If you were expecting this change and trust the new key, enter \"y\" to update PuTTY's cache and continue connecting. If you want to carry on connecting but without updating the cache, enter \"n\". If you want to abandon the connection completely, press Return to cancel. Pressing Return is the ONLY guaranteed safe choice. Update cached key? (y/n, Return cancels connection) In either case hit y and the key will be stored. Debugging multiple putty ageant keys \uf0c1 In the event you are using putty ageant with multiple keys loaded you may see the wrong key being used. In general, pageant keys are tried in the order they were loaded into the ageant. If you have descriptive comment on each of your keys you can try connecting with plink in verbose mode to see what keys are being tried. Simply open the Git bash shell and run: \"$GIT_SSH\" -v user@hostname Or, if using sessions with a pre-entered username: \"$GIT_SSH\" -v session_name In either case, you should look for lines like: Trying Pageant key #0 Authenticating with public key \"My Key\" from agent The first says which (numerical) key the ageant is trying. The second tells you the key comment for the authenticating key. To my knowledge the second line should only show up once, for the valid key. Setperms and other commands \uf0c1 When using wildcard repos the setperms command is very important, and other commands can come in handy as well. See their documentation for how to use them, but where they use: ssh user@host command etc etc You will want to use: \"$GIT_SSH\" user@host command etc etc Otherwise everything should be identical. About this document \uf0c1 This document was written by Thomas Berezansky (tsbere (at) mvlc (dot) org) in the hopes that it would be useful to those using putty on windows and wishing to use git/gitolite with their putty keys and sessions.","title":"Putty and Msysgit"},{"location":"contrib/putty.html#putty-and-msysgit","text":"Copyright: Thomas Berezansky (tsbere (at) mvlc (dot) org). Licensed under CC-BY-SA unported 3.0, https://creativecommons.org/licenses/by-sa/3.0/ This document is intended for those who wish to use Putty/Plink with msysgit. If you need more help with putty or component programs I suggest looking at the official putty documentation . If you are not already using Putty for SSH it is recommended you do NOT use it with msysgit. Please note that this only covers the client side of things, and does not involve server side components to troubleshooting. For that, please see the ssh-troubleshooting document .","title":"putty and msysgit"},{"location":"contrib/putty.html#msysgit-setup","text":"Provided you have putty sessions msysgit should give you the option of specifying a location to plink. If it did not then you will need to add an environment variable named \"GIT_SSH\" to point at plink.exe, wherever you have that sitting. How to do that on your version of windows will likely vary, and is not covered here. For purposes of example, on a 64 bit Windows Vista machine the GIT_SSH value could be: C:\\Program Files (x86)\\PuTTY\\plink.exe Note the lack of quotes. Testing that msysgit is properly configured can be done from the git bash shell. Simply type (case sensitive, include the quotes): \"$GIT_SSH\" -V You should get a response similar to this: plink: Release 0.60 If instead you get a \"command not found\" type error you likely have a typo in your environment variable.","title":"msysgit setup"},{"location":"contrib/putty.html#going-back-to-openssh","text":"If you wish to go back to OpenSSH all you need to do is delete the GIT_SSH environment variable. This will vary by your version of windows and thus is not covered here.","title":"Going back to OpenSSH"},{"location":"contrib/putty.html#putty-keys","text":"If you do not already have putty private key files (.ppk) you will need to make at least one. You can either make a new one or convert an existing key to putty private key format. Either way, you will want to use puttygen. Note that you can go the other way if you want to stop using putty but keep the key by exporting the key to OpenSSH format.","title":"Putty keys"},{"location":"contrib/putty.html#creating-a-new-key","text":"To make it simple, I suggest SSH-2 RSA and a bit size of at least 1024. Larger keys will take longer to generate and will take longer to authenticate you on most systems. Making the key is as simple at hitting \"Generate\". It is recommended to give the key a meaningful comment.","title":"Creating a new key"},{"location":"contrib/putty.html#importing-an-existing-key","text":"If you already have an OpenSSH or ssh.com key you can import it using the \"Import\" option on the \"Conversions\" menu. If the key does not have a meaningful comment I would suggest adding one at this point.","title":"Importing an existing key"},{"location":"contrib/putty.html#loading-an-existing-key","text":"If you need to load an existing key to edit or view it you can do so from the File menu.","title":"Loading an existing key"},{"location":"contrib/putty.html#public-key","text":"To get your public key for use with gitolite, load (or generate, or import) your key into puttygen. There is a box labeled \"Public key for pasting into OpenSSH authorized_keys file\" there. Copy the text into your preferred text editor and save.","title":"Public key"},{"location":"contrib/putty.html#putty-ageant","text":"Though not required in all cases you may wish to use the putty ageant, pageant, to load your key(s). This will allow for your key(s) to be passphrase protected but not have to enter the passphrase when you go to use them, provided you have already loaded the key into the ageant.","title":"Putty ageant"},{"location":"contrib/putty.html#sessionless-or-raw-hostname-usage","text":"When using plink without a putty session you pretty much have to load your keys with putty ageant, if only so that plink can find them.","title":"Sessionless or raw hostname usage"},{"location":"contrib/putty.html#putty-sessions","text":"In addition to hostnames msysgit can, when using putty, use putty sessions. This works in a manner similar to definitions in OpenSSH's ssh_config file. All settings in the session that apply to plink usage will be loaded, including the key file to use and even the username to connect to. Thus, instead of: ssh://user@host.example.ext:port/repo You can use: ssh://session_name/repo","title":"Putty sessions"},{"location":"contrib/putty.html#host-key-authentication","text":"Whether you are using hostnames or sessions you still run into one potential problem. Plink currently wants to validate the server's SSH host key before allowing you to connect, and when git calls plink there is no way to tell it yes. Thus, you may get something like this: The server's host key is not cached in the registry. You have no guarantee that the server is the computer you think it is. The server's rsa2 key fingerprint is: ssh-rsa 2048 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 Connection abandoned. fatal: The remote end hung up unexpectedly Or, in the case of the host key changing, something like this: WARNING - POTENTIAL SECURITY BREACH! The server's host key does not match the one PuTTY has cached in the registry. This means that either the server administrator has changed the host key, or you have actually connected to another computer pretending to be the server. The new rsa2 key fingerprint is: ssh-rsa 2048 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 Connection abandoned. fatal: The remote end hung up unexpectedly The solution is to call plink directly, or start putty and connect with it first. To use plink, open the Git Bash shell and enter: \"$GIT_SSH\" hostname_or_session_name When you do you will see something like this: The server's host key is not cached in the registry. You have no guarantee that the server is the computer you think it is. The server's rsa2 key fingerprint is: ssh-rsa 2048 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 If you trust this host, enter \"y\" to add the key to PuTTY's cache and carry on connecting. If you want to carry on connecting just once, without adding the key to the cache, enter \"n\". If you do not trust this host, press Return to abandon the connection. Store key in cache? (y/n) Or, in the case of a changed key, a response like this: WARNING - POTENTIAL SECURITY BREACH! The server's host key does not match the one PuTTY has cached in the registry. This means that either the server administrator has changed the host key, or you have actually connected to another computer pretending to be the server. The new rsa2 key fingerprint is: ssh-rsa 2048 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 If you were expecting this change and trust the new key, enter \"y\" to update PuTTY's cache and continue connecting. If you want to carry on connecting but without updating the cache, enter \"n\". If you want to abandon the connection completely, press Return to cancel. Pressing Return is the ONLY guaranteed safe choice. Update cached key? (y/n, Return cancels connection) In either case hit y and the key will be stored.","title":"Host key authentication"},{"location":"contrib/putty.html#debugging-multiple-putty-ageant-keys","text":"In the event you are using putty ageant with multiple keys loaded you may see the wrong key being used. In general, pageant keys are tried in the order they were loaded into the ageant. If you have descriptive comment on each of your keys you can try connecting with plink in verbose mode to see what keys are being tried. Simply open the Git bash shell and run: \"$GIT_SSH\" -v user@hostname Or, if using sessions with a pre-entered username: \"$GIT_SSH\" -v session_name In either case, you should look for lines like: Trying Pageant key #0 Authenticating with public key \"My Key\" from agent The first says which (numerical) key the ageant is trying. The second tells you the key comment for the authenticating key. To my knowledge the second line should only show up once, for the valid key.","title":"Debugging multiple putty ageant keys"},{"location":"contrib/putty.html#setperms-and-other-commands","text":"When using wildcard repos the setperms command is very important, and other commands can come in handy as well. See their documentation for how to use them, but where they use: ssh user@host command etc etc You will want to use: \"$GIT_SSH\" user@host command etc etc Otherwise everything should be identical.","title":"Setperms and other commands"},{"location":"contrib/putty.html#about-this-document","text":"This document was written by Thomas Berezansky (tsbere (at) mvlc (dot) org) in the hopes that it would be useful to those using putty on windows and wishing to use git/gitolite with their putty keys and sessions.","title":"About this document"},{"location":"contrib/ssh-and-http.html","text":"Making repositories available to both ssh and http mode clients \uf0c1 Copyright Thomas Hager (duke at sigsegv dot at). Licensed under CC-BY-NC-SA unported 3.0, https://creativecommons.org/licenses/by-nc-sa/3.0/ Assumptions: Apache 2.x with CGI and Suexec support installed. Git and Gitolite installed with user \"git\" and group \"git\", and pubkey SSH access configured and working. Git plumbing installed to /usr/libexec/git-core Gitolite base located at /opt/git Apache DOCUMENT_ROOT set to /var/www Apache runs with user www and group www Please adjust the instructions below to reflect your setup (users and paths). Edit your .gitolite.rc and add $ENV{PATH} .= \":/opt/git/bin\"; at the very top (as described in t/smart-http.root-setup ). Next, check which document root your Apache's suexec accepts: # suexec -V -D AP_DOC_ROOT=\"/var/www\" -D AP_GID_MIN=100 -D AP_HTTPD_USER=\"www\" -D AP_LOG_EXEC=\"/var/log/apache/suexec.log\" -D AP_SAFE_PATH=\"/usr/local/bin:/usr/bin:/bin\" -D AP_UID_MIN=100 -D AP_USERDIR_SUFFIX=\"public_html\" We're interested in AP_DOC_ROOT , which is set to /var/www in our case. Create a bin and a git directory in AP_DOC_ROOT : install -d -m 0755 -o git -g git /var/www/bin install -d -m 0755 -o www -g www /var/www/git /var/www/git is just a dummy directory used as Apache's document root (see below). Next, create a shell script inside /var/www/bin named gitolite-suexec-wrapper.sh , with mode 0700 and owned by user and group git . Add the following content: #!/bin/bash # # Suexec wrapper for gitolite-shell # export GIT_PROJECT_ROOT=\"/opt/git/repositories\" export GITOLITE_HTTP_HOME=\"/opt/git\" exec ${GITOLITE_HTTP_HOME}/gitolite-source/src/gitolite-shell Edit your Apache's config to add http pull/push support, preferably in a dedicated VirtualHost section: <VirtualHost *:80> ServerName git.example.com ServerAlias git ServerAdmin you@example.com DocumentRoot /var/www/git <Directory /var/www/git> Options None AllowOverride none Order allow,deny Allow from all </Directory> SuexecUserGroup git git ScriptAlias /git/ /var/www/bin/gitolite-suexec-wrapper.sh/ ScriptAlias /gitmob/ /var/www/bin/gitolite-suexec-wrapper.sh/ <Location /git> AuthType Basic AuthName \"Git Access\" Require valid-user AuthUserFile /etc/apache/git.passwd </Location> </VirtualHost> This Apache config is just an example, you probably should adapt the authentication section and use https instead of http! Finally, add an R = daemon access rule to all repositories you want to make available via http.","title":"Using both ssh and http"},{"location":"contrib/ssh-and-http.html#making-repositories-available-to-both-ssh-and-http-mode-clients","text":"Copyright Thomas Hager (duke at sigsegv dot at). Licensed under CC-BY-NC-SA unported 3.0, https://creativecommons.org/licenses/by-nc-sa/3.0/ Assumptions: Apache 2.x with CGI and Suexec support installed. Git and Gitolite installed with user \"git\" and group \"git\", and pubkey SSH access configured and working. Git plumbing installed to /usr/libexec/git-core Gitolite base located at /opt/git Apache DOCUMENT_ROOT set to /var/www Apache runs with user www and group www Please adjust the instructions below to reflect your setup (users and paths). Edit your .gitolite.rc and add $ENV{PATH} .= \":/opt/git/bin\"; at the very top (as described in t/smart-http.root-setup ). Next, check which document root your Apache's suexec accepts: # suexec -V -D AP_DOC_ROOT=\"/var/www\" -D AP_GID_MIN=100 -D AP_HTTPD_USER=\"www\" -D AP_LOG_EXEC=\"/var/log/apache/suexec.log\" -D AP_SAFE_PATH=\"/usr/local/bin:/usr/bin:/bin\" -D AP_UID_MIN=100 -D AP_USERDIR_SUFFIX=\"public_html\" We're interested in AP_DOC_ROOT , which is set to /var/www in our case. Create a bin and a git directory in AP_DOC_ROOT : install -d -m 0755 -o git -g git /var/www/bin install -d -m 0755 -o www -g www /var/www/git /var/www/git is just a dummy directory used as Apache's document root (see below). Next, create a shell script inside /var/www/bin named gitolite-suexec-wrapper.sh , with mode 0700 and owned by user and group git . Add the following content: #!/bin/bash # # Suexec wrapper for gitolite-shell # export GIT_PROJECT_ROOT=\"/opt/git/repositories\" export GITOLITE_HTTP_HOME=\"/opt/git\" exec ${GITOLITE_HTTP_HOME}/gitolite-source/src/gitolite-shell Edit your Apache's config to add http pull/push support, preferably in a dedicated VirtualHost section: <VirtualHost *:80> ServerName git.example.com ServerAlias git ServerAdmin you@example.com DocumentRoot /var/www/git <Directory /var/www/git> Options None AllowOverride none Order allow,deny Allow from all </Directory> SuexecUserGroup git git ScriptAlias /git/ /var/www/bin/gitolite-suexec-wrapper.sh/ ScriptAlias /gitmob/ /var/www/bin/gitolite-suexec-wrapper.sh/ <Location /git> AuthType Basic AuthName \"Git Access\" Require valid-user AuthUserFile /etc/apache/git.passwd </Location> </VirtualHost> This Apache config is just an example, you probably should adapt the authentication section and use https instead of http! Finally, add an R = daemon access rule to all repositories you want to make available via http.","title":"Making repositories available to both ssh and http mode clients"},{"location":"contrib/sskm.html","text":"changing keys -- self service key management \uf0c1 Copyright: Jeff Mitchell (jmitchell@kde.org). Licensed under CC-BY-NC-SA unported 3.0, https://creativecommons.org/licenses/by-nc-sa/3.0/ [Note on v3 version: this has been manually spot-tested; there is no test suite. Changes from v2 version are minimal so it should all work fine but please report errors!] Follow this guide to add keys to or remove keys from your account. Note that you cannot use this method to add your first key to the account; you must still email your initial key to your admin. The key management is done using a command called sskm . This command must be enabled for remote use by the admin (see here for more on this). Important! \uf0c1 There are a few things that you should know before using the key management system. Please do not ignore this section! Key fingerprints \uf0c1 Keys are identified in some of these subcommands by their fingerprints. To see the fingerprint for a public key on your computer, use the following syntax: ssh-keygen -l -f <path_to_public_key.pub> You'll get output like: jeff@baklava ~ $ ssh-keygen -l -f .ssh/jeffskey.pub 2048 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 .ssh/jeffskey.pub (RSA) Active keys \uf0c1 Any keys that you can use to interact with the system are active keys. (Inactive keys are keys that are, for instance, scheduled to be added or removed.) Keys are identified with their keyid ; see the section below on listing keys. If you have no current active keys, you will be locked out of the system (in which case email your admin for help). Therefore, be sure that you are never removing your only active key! Selecting which key to use \uf0c1 Although you can identify yourself to the Gitolite system with any of your active keys on the server, at times it is necessary to specifically pick which key you are identifying with. To pick the key to use, pass the -i flag into ssh : jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git info hello jeff, the gitolite version here is v2.0.1-11-g1cd3414 the gitolite config gives you the following access: @C R W [a-zA-Z0-9][a-zA-Z0-9_\\-\\.]+[a-zA-Z0-9] .... N.B. : If you have any keys loaded into ssh-agent (i.e., ssh-add -l shows at least one key), then this may not work properly. ssh has a bug which makes it ignore -i values when that key has not been loaded into the agent. One solution is to add the key you want to use (e.g., ssh-add .ssh/jeffskey ). The other is to remove all the keys from the agent or disable the agent, using one of these commands: Terminate ssh-agent or use ssh-add -D flag to remove identities from it If using keychain , run keychain --clear to remove identities Unset the SSH_AUTH_SOCK and SSH_AGENT_PID variables in the current shell Public vs. private keys \uf0c1 In this guide, all keys are using their full suffix. In other words, if you see a .pub at the end of a key, it's the public key; if you don't, it's the private key. For instance, when using the -i flag with ssh , you are specifying private keys to use. When you are submitting a key for addition to the system, you are using the public key. Listing your existing keys \uf0c1 To see a list of your existing keys, use the list argument to sskm : jeff@baklava ~ $ ssh git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub Notice the @ sign in each key's name? That sign and the text after that up until the .pub is the keyid . This is what you will use when identifying keys to the system. Above, for instance, one of my keys has the keyid of @key3 . A keyid may be empty ; in fact to start with you may only have a single jeff.pub key, depending on how your admin added your initial key. You can use any keyid you wish when adding keys (like @home , @laptop , ...); the only rules are that it must start with the @ character and after that contain only digits, letters, or underscores. Adding or Replacing a key \uf0c1 Step 1: Adding the Key \uf0c1 Adding and replacing a key is the same process. What matters is the keyid . When adding a new key, use a new keyid ; when replacing a key, pass in the keyid of the key you want to replace, as found by using the list subcommand. Pretty simple! To add a key, pipe in the text of your new key using cat to the add subcommand. In the example below, I explicitly select which existing, active pubkey to identify with for the command (using the -i parameter to ssh) for clarity: jeff@baklava ~ $ cat .ssh/newkey.pub | ssh -i .ssh/jeffskey git@git sskm add @key4 hello jeff, you are currently using a normal (\"active\") key please supply the new key on STDIN. (I recommend you don't try to do this interactively, but use a pipe) If you now run the list command you'll see that it's scheduled for addition: jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub == keys marked for addition/replacement == 1: ff:92:a2:20:6d:42:6b:cf:20:e8:a2:4a:3b:b0:32:3a : jeff@key4.pub Step 2: Confirming the addition \uf0c1 Gitolite uses Git internally to store the keys. Just like with Git, where you commit locally before push -ing up to the server, you need to confirm the key addition (see the next section if you made a mistake). We use the confirm-add subcommand to do this, but : to verify that you truly have ownership of the corresponding private key, you must use the key you are adding itself to do the confirmation! (Inconvenient like most security, but very necessary from a security perspective.) This is where using the -i flag of ssh comes in handy: jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm confirm-add @key4 hello jeff, you are currently using a key in the 'marked for add' state Listing keys again shows that all four keys are now active: jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub 4: ff:92:a2:20:6d:42:6b:cf:20:e8:a2:4a:3b:b0:32:3a : jeff@key4.pub Optional: Undoing a mistaken add (before confirmation) \uf0c1 Another advantage of Gitolite using Git internally is that that if we mistakenly add the wrong key, we can undo it before it's confirmed by passing in the keyid we want to remove into the undo-add subcommand: jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git sskm undo-add @key4 hello jeff, you are currently using a normal (\"active\") key Listing the keys shows that that new key has been removed: jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub Removing a key \uf0c1 Step 1: Mark the key for deletion \uf0c1 Deleting a key works very similarly to adding a key, with del substituted for add . Let's say that I have my four keys from the example above: jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub 4: ff:92:a2:20:6d:42:6b:cf:20:e8:a2:4a:3b:b0:32:3a : jeff@key4.pub I would like to remove the key that on my box is called newkey and in the Gitolite system is known as @key4 . I simply pass in the identifier to the del subcommand of sskm : jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm del @key4 hello jeff, you are currently using a normal (\"active\") key Listing the keys now shows that it is marked for deletion: jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm list hello jeff, you are currently using a key in the 'marked for del' state you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub == keys marked for deletion == 1: ff:92:a2:20:6d:42:6b:cf:20:e8:a2:4a:3b:b0:32:3a : jeff@key4.pub Step 2: Confirming the deletion \uf0c1 Just like with Git, where you commit locally before push -ing up to the server, you need to confirm the key addition (see the next section if you made a mistake). We use the confirm-del subcommand to do this, but : unlike the confirm-add subcommand, you must use a different key than the key you are deleting to do the confirmation! This prevents you from accidentally locking yourself out of the system by removing all active keys: jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git sskm confirm-del @key4 hello jeff, you are currently using a normal (\"active\") key Listing keys again shows that the fourth key has been removed: jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub Optional: Undoing a mistaken delete (before confirmation) \uf0c1 Another advantage of Gitolite using Git internally is that that if we mistakenly delete the wrong key, we can undo it before it's confirmed by passing in the keyid we want to keep into the undo-del subcommand. Note that this operation must be performed using the private key that corresponds to the key you are trying to keep! (Security reasons, similar to the reason that you must confirm an addition this way; it prevents anyone from undoing a deletion, and therefore keeping in the system, a key that they cannot prove (by having the corresponding private key) should stay in the system): jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm undo-del @key4 hello jeff, you are currently using a key in the 'marked for del' state You're undeleting a key that is currently marked for deletion. Hit ENTER to undelete this key Hit Ctrl-C to cancel the undelete Please see documentation for caveats on the undelete process as well as how to actually delete it. (Go ahead and hit ENTER there; the caveats are really only on the administrative side of things.) Listing the keys shows that that new key is now marked active again: jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub 4: ff:92:a2:20:6d:42:6b:cf:20:e8:a2:4a:3b:b0:32:3a : jeff@key4.pub important notes for the admin \uf0c1 These are the things that can break if you allow your users to use this command: \"sskm\" clones, changes, and pushes back the gitolite-admin repo. This means, even if you're the only administrator, you should never 'git push -f', in case you end up overwriting something sskm did. There is no way to distinguish foo/alice.pub from bar/alice.pub using this command. You can distinguish foo/alice.pub from bar/alice@home.pub , but that's not because of the foo and bar, it's because the two files have different keyids. In other words, sskm only works with the older style, not with the \"subdirectory\" style of multi-key management. Keys placed in specific folders (for whatever reasons), will probably not stay in those folders if this command is used. Even a key delete, followed by undoing the delete, will cause the key to effectively move to the root of the key store (i.e., the keydir directory in the gitolite-admin repo).","title":"Self-service key management"},{"location":"contrib/sskm.html#changing-keys-self-service-key-management","text":"Copyright: Jeff Mitchell (jmitchell@kde.org). Licensed under CC-BY-NC-SA unported 3.0, https://creativecommons.org/licenses/by-nc-sa/3.0/ [Note on v3 version: this has been manually spot-tested; there is no test suite. Changes from v2 version are minimal so it should all work fine but please report errors!] Follow this guide to add keys to or remove keys from your account. Note that you cannot use this method to add your first key to the account; you must still email your initial key to your admin. The key management is done using a command called sskm . This command must be enabled for remote use by the admin (see here for more on this).","title":"changing keys -- self service key management"},{"location":"contrib/sskm.html#important","text":"There are a few things that you should know before using the key management system. Please do not ignore this section!","title":"Important!"},{"location":"contrib/sskm.html#key-fingerprints","text":"Keys are identified in some of these subcommands by their fingerprints. To see the fingerprint for a public key on your computer, use the following syntax: ssh-keygen -l -f <path_to_public_key.pub> You'll get output like: jeff@baklava ~ $ ssh-keygen -l -f .ssh/jeffskey.pub 2048 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 .ssh/jeffskey.pub (RSA)","title":"Key fingerprints"},{"location":"contrib/sskm.html#active-keys","text":"Any keys that you can use to interact with the system are active keys. (Inactive keys are keys that are, for instance, scheduled to be added or removed.) Keys are identified with their keyid ; see the section below on listing keys. If you have no current active keys, you will be locked out of the system (in which case email your admin for help). Therefore, be sure that you are never removing your only active key!","title":"Active keys"},{"location":"contrib/sskm.html#selecting-which-key-to-use","text":"Although you can identify yourself to the Gitolite system with any of your active keys on the server, at times it is necessary to specifically pick which key you are identifying with. To pick the key to use, pass the -i flag into ssh : jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git info hello jeff, the gitolite version here is v2.0.1-11-g1cd3414 the gitolite config gives you the following access: @C R W [a-zA-Z0-9][a-zA-Z0-9_\\-\\.]+[a-zA-Z0-9] .... N.B. : If you have any keys loaded into ssh-agent (i.e., ssh-add -l shows at least one key), then this may not work properly. ssh has a bug which makes it ignore -i values when that key has not been loaded into the agent. One solution is to add the key you want to use (e.g., ssh-add .ssh/jeffskey ). The other is to remove all the keys from the agent or disable the agent, using one of these commands: Terminate ssh-agent or use ssh-add -D flag to remove identities from it If using keychain , run keychain --clear to remove identities Unset the SSH_AUTH_SOCK and SSH_AGENT_PID variables in the current shell","title":"Selecting which key to use"},{"location":"contrib/sskm.html#public-vs-private-keys","text":"In this guide, all keys are using their full suffix. In other words, if you see a .pub at the end of a key, it's the public key; if you don't, it's the private key. For instance, when using the -i flag with ssh , you are specifying private keys to use. When you are submitting a key for addition to the system, you are using the public key.","title":"Public vs. private keys"},{"location":"contrib/sskm.html#listing-your-existing-keys","text":"To see a list of your existing keys, use the list argument to sskm : jeff@baklava ~ $ ssh git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub Notice the @ sign in each key's name? That sign and the text after that up until the .pub is the keyid . This is what you will use when identifying keys to the system. Above, for instance, one of my keys has the keyid of @key3 . A keyid may be empty ; in fact to start with you may only have a single jeff.pub key, depending on how your admin added your initial key. You can use any keyid you wish when adding keys (like @home , @laptop , ...); the only rules are that it must start with the @ character and after that contain only digits, letters, or underscores.","title":"Listing your existing keys"},{"location":"contrib/sskm.html#adding-or-replacing-a-key","text":"","title":"Adding or Replacing a key"},{"location":"contrib/sskm.html#step-1-adding-the-key","text":"Adding and replacing a key is the same process. What matters is the keyid . When adding a new key, use a new keyid ; when replacing a key, pass in the keyid of the key you want to replace, as found by using the list subcommand. Pretty simple! To add a key, pipe in the text of your new key using cat to the add subcommand. In the example below, I explicitly select which existing, active pubkey to identify with for the command (using the -i parameter to ssh) for clarity: jeff@baklava ~ $ cat .ssh/newkey.pub | ssh -i .ssh/jeffskey git@git sskm add @key4 hello jeff, you are currently using a normal (\"active\") key please supply the new key on STDIN. (I recommend you don't try to do this interactively, but use a pipe) If you now run the list command you'll see that it's scheduled for addition: jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub == keys marked for addition/replacement == 1: ff:92:a2:20:6d:42:6b:cf:20:e8:a2:4a:3b:b0:32:3a : jeff@key4.pub","title":"Step 1: Adding the Key"},{"location":"contrib/sskm.html#step-2-confirming-the-addition","text":"Gitolite uses Git internally to store the keys. Just like with Git, where you commit locally before push -ing up to the server, you need to confirm the key addition (see the next section if you made a mistake). We use the confirm-add subcommand to do this, but : to verify that you truly have ownership of the corresponding private key, you must use the key you are adding itself to do the confirmation! (Inconvenient like most security, but very necessary from a security perspective.) This is where using the -i flag of ssh comes in handy: jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm confirm-add @key4 hello jeff, you are currently using a key in the 'marked for add' state Listing keys again shows that all four keys are now active: jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub 4: ff:92:a2:20:6d:42:6b:cf:20:e8:a2:4a:3b:b0:32:3a : jeff@key4.pub","title":"Step 2: Confirming the addition"},{"location":"contrib/sskm.html#optional-undoing-a-mistaken-add-before-confirmation","text":"Another advantage of Gitolite using Git internally is that that if we mistakenly add the wrong key, we can undo it before it's confirmed by passing in the keyid we want to remove into the undo-add subcommand: jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git sskm undo-add @key4 hello jeff, you are currently using a normal (\"active\") key Listing the keys shows that that new key has been removed: jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub","title":"Optional: Undoing a mistaken add (before confirmation)"},{"location":"contrib/sskm.html#removing-a-key","text":"","title":"Removing a key"},{"location":"contrib/sskm.html#step-1-mark-the-key-for-deletion","text":"Deleting a key works very similarly to adding a key, with del substituted for add . Let's say that I have my four keys from the example above: jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub 4: ff:92:a2:20:6d:42:6b:cf:20:e8:a2:4a:3b:b0:32:3a : jeff@key4.pub I would like to remove the key that on my box is called newkey and in the Gitolite system is known as @key4 . I simply pass in the identifier to the del subcommand of sskm : jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm del @key4 hello jeff, you are currently using a normal (\"active\") key Listing the keys now shows that it is marked for deletion: jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm list hello jeff, you are currently using a key in the 'marked for del' state you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub == keys marked for deletion == 1: ff:92:a2:20:6d:42:6b:cf:20:e8:a2:4a:3b:b0:32:3a : jeff@key4.pub","title":"Step 1: Mark the key for deletion"},{"location":"contrib/sskm.html#step-2-confirming-the-deletion","text":"Just like with Git, where you commit locally before push -ing up to the server, you need to confirm the key addition (see the next section if you made a mistake). We use the confirm-del subcommand to do this, but : unlike the confirm-add subcommand, you must use a different key than the key you are deleting to do the confirmation! This prevents you from accidentally locking yourself out of the system by removing all active keys: jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git sskm confirm-del @key4 hello jeff, you are currently using a normal (\"active\") key Listing keys again shows that the fourth key has been removed: jeff@baklava ~ $ ssh -i .ssh/jeffskey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub","title":"Step 2: Confirming the deletion"},{"location":"contrib/sskm.html#optional-undoing-a-mistaken-delete-before-confirmation","text":"Another advantage of Gitolite using Git internally is that that if we mistakenly delete the wrong key, we can undo it before it's confirmed by passing in the keyid we want to keep into the undo-del subcommand. Note that this operation must be performed using the private key that corresponds to the key you are trying to keep! (Security reasons, similar to the reason that you must confirm an addition this way; it prevents anyone from undoing a deletion, and therefore keeping in the system, a key that they cannot prove (by having the corresponding private key) should stay in the system): jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm undo-del @key4 hello jeff, you are currently using a key in the 'marked for del' state You're undeleting a key that is currently marked for deletion. Hit ENTER to undelete this key Hit Ctrl-C to cancel the undelete Please see documentation for caveats on the undelete process as well as how to actually delete it. (Go ahead and hit ENTER there; the caveats are really only on the administrative side of things.) Listing the keys shows that that new key is now marked active again: jeff@baklava ~ $ ssh -i .ssh/newkey git@git sskm list hello jeff, you are currently using a normal (\"active\") key you have the following keys: == active keys == 1: 72:ef:a3:e0:f5:06:f8:aa:6f:a2:88:9d:50:86:25:4e : jeff@key1.pub 2: 61:38:a7:9f:ba:cb:99:81:4f:49:2c:8b:c8:63:8e:33 : jeff@key2.pub 3: 2d:78:d4:2c:b1:6d:9a:dc:d9:0d:94:3c:d8:c2:65:44 : jeff@key3.pub 4: ff:92:a2:20:6d:42:6b:cf:20:e8:a2:4a:3b:b0:32:3a : jeff@key4.pub","title":"Optional: Undoing a mistaken delete (before confirmation)"},{"location":"contrib/sskm.html#important-notes-for-the-admin","text":"These are the things that can break if you allow your users to use this command: \"sskm\" clones, changes, and pushes back the gitolite-admin repo. This means, even if you're the only administrator, you should never 'git push -f', in case you end up overwriting something sskm did. There is no way to distinguish foo/alice.pub from bar/alice.pub using this command. You can distinguish foo/alice.pub from bar/alice@home.pub , but that's not because of the foo and bar, it's because the two files have different keyids. In other words, sskm only works with the older style, not with the \"subdirectory\" style of multi-key management. Keys placed in specific folders (for whatever reasons), will probably not stay in those folders if this command is used. Even a key delete, followed by undoing the delete, will cause the key to effectively move to the root of the key store (i.e., the keydir directory in the gitolite-admin repo).","title":"important notes for the admin"},{"location":"contrib/ukm.html","text":"user key management \uf0c1 Copyright 2012-2013 Ralf Hemmecke ralf@hemmecke.org . Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License User key management allows certain users to add and remove keys. The key management is done using a command called ukm . This command must be enabled for remote use by both the sysadmin and the gitolite-admin (see here for more on this) or look below. Important Warning! \uf0c1 User key management undermines the fundamental principle of gitolite (see authentication versus authorisation ) by allowing certain users to juggle with ssh public keys. Make sure someone (sysadmin?) can login to the server with a password , just in case something breaks and the .ssh/authorized_keys file for the user running gitolite on the server is messed up. General note \uf0c1 Although gitolite deals in its core only with authorisation, by default it uses ssh as its authentication mechanism. Sure, ssh is not at all part of gitolite and it can be replaced by other means, but still there is a directory gitolite-admin/keydir that is reserved for public ssh keys. In fact, management of users and multiple keys per user is not actually a gitolite administration stuff. It's external to gitolite. In a future version, ukm could be used as an equivalent of the keydir/ directory from the gitolite-admin repo (currently it just manages that directory) and thus ukm could be seen as such an external tool that does what its name suggests: user (key) management. In the following description we assume that there is an entry like Host gitserver IdentityFile ~/.ssh/id_rsa # choose your gitolite key here HostName gitolite.example.org # location where gitolite is installed User git # user that runs gitolite in the client's ~/.ssh/config file. Who might be interested? \uf0c1 The gitolite admin \uf0c1 Adding a new public key to the system means to copy the key into gitolite/keydir commit and push. With ukm it would be cat FOO.PUB | ssh gitserver ukm add KEYID This would be a setup where only the gitolite administrator uses ukm . Not a big benefit, but ukm prevents adding identical keys under different userids. This consistency check might be an advantage. Furthermore, ukm does not allow the gitolite administrator to remove his/her last, i.e., it prevents the administrator from locking him-/herself out of the system. (Note, we assume that the gitolite administrator has no shell access to the server; only the sysadmin has shell access.) Users that want more control over who can access their repositories \uf0c1 Suppose the gitolite administrator of a research institute has set up gitolite to provide wild repositories for example with a gitolite.conf like this. repo gitolite-admin RW+ = gitadmin # These people are allowed to create wild repositories. @creators = alice bob ... # wildcard repositories for the users repo CREATOR/..* C = @creators RW+ = CREATOR RW = WRITERS R = READERS Researchers Alice and Bob want to write an article together. Alice creates a wild repository alice/article and adds Bob via the perms command to the WRITERS of her repository. After a while they realize that Otto from another institute would be a reasonable third author. However, if they cannot give him write access to the repository, they would have to exchange the article via email. Back to the stone age? Better, Alice asks Otto to send her his public ssh key. Alice then forwards that key to the gitolite administrator and asks him to include that key into the system. (Hopefully, all that didn't happen on a holiday or on the weekend.) After 3 days the gitolite administrater finds some time. Since he doesn't know Otto, he simply trusts Alice and adds the public key into the system. With ukm Alice can save bothering the gitolite administrator and is perhaps even faster in saying: cat otto.pub | ssh gitserver ukm add otto@other.institute.edu ssh gitserver perms alice/article + WRITERS otto@other.institute.edu The effect would be the same. Users that want to manage multiple keys \uf0c1 Suppose, you have different computers and a different ssh key for each of them. You would like to tell gitolite that all these different keys belong to just one gitolite identity. Your gitolite administrator creates your gitolite identity with one of your keys as your initial key. This key can only be managed by the gitolite administrator, not by you. It basically determines under which name you are known to gitolite. You can add new keys to this identity and remove them at your will. How to enable user key management? \uf0c1 The ukm command is contributed code and lives under contrib/commands/ukm in the gitolite source tree. A sysadmin of the gitserver has to copy or link this script to the right location. cd src/commands ln -s ../../contrib/commands/ukm . Furthermore, a sysadmin must add the string 'ukm' to the ENABLE array, i.e., ENABLE => [ ..., 'ukm', ... ], in .gitolite.rc . (That's the preferred way for gitolite starting with version v3.4.) Instead of the above (in particular in gitolite v3.0-v3.3), add 'ukm' => 1 to the COMMANDS hash. COMMANDS => {..., 'ukm' => 1, ... }, How to configure user key management and who can use it? \uf0c1 As described above there are three main use cases for ukm . Each of them requires different values in the respective config files. There are two files where ukm must be configured. .gitolite.rc (managed by a sysadmin of the gitserver) gitolite-admin/conf/gitolite.conf (managed by a gitolite administrator ) Besides sysadmin and gitolite administrator , ukm knows 3 roles. super key manager guest key manager self key manager Super key managers \uf0c1 When ukm is enabled, nothing else must be configured. Guest key managers \uf0c1 The gitolite administrator defines guest key managers by creating a group @guest-key-managers in gitolite-admin/conf/gitolite.conf and adding (trusted) users to this group. WARNING : If the gitolite administrator includes @all into this list, it allows guests to add new public keys. If, additionally, there is @creators=@all , it basically allows the initial guest key managers to start a hierarchy of new users with the same rights as the initial users. The system administrator must configure ukm for guest key managers in .gitolite.rc by adding something like UKM_CONFIG => { FORBIDDEN_GUEST_PATTERN => qr(FORBIDDEN-PATTERN), }, to the %RC hash. If FORBIDDEN_GUEST_PATTERN is missing, it defaults to the following. FORBIDDEN_GUEST_PATTERN => qr(.) Any KEYID that matches this pattern is rejected, i.e., the default value basically allows only the super key managers to add/del keys. If ukm is supposed to work for guest key managers , FORBIDDEN_GUEST_PATTERN must be set to some reasonable value. If your company has email addresses of the form first.last@company.com you might want to write something like this UKM_CONFIG => { FORBIDDEN_GUEST_PATTERN => qr(@company.com$) }, which would only allow KEYIDs in the form of email addresses that do not come from your company. For the very brave only!!! The variable REQUIRED_GUEST_PATTERN is optional. It is strongly discouraged to set it. However, if you know, what you are doing, it allows for a bit more flexibility. Don't complain if you modify the default value!!! REQUIRED_GUEST_PATTERN defaults to a regular expression that only allows KEYIDs in the form of email addresses (see the source code if you want to see this regular expression). You can write UKM_CONFIG => { REQUIRED_GUEST_PATTERN => qr(REQUIRED-PATTERN), FORBIDDEN_GUEST_PATTERN => qr(FORBIDDEN-PATTERN), }, with the meaning that the KEYID must match qr(^(REQUIRED-PATTERN)$) (note that ^ and $ are automatically added to the pattern) and must not match qr(FORBIDDEN-PATTERN) in order for ukm to proceed with this KEYID for a guest key manager . Gitolite's namespace for USERIDs is flat. The REQUIRED_GUEST_PATTERN and FORBIDDEN_GUEST_PATTERN serve two purposes. Restrict permissions for what guest key managers can do. Patterns that cannot be used for guests can still be used by super key managers . In other words, those patterns are reserved for in-house USERIDs . Self key managers \uf0c1 The gitolite administrator defines self key managers by creating a group @self-key-managers in gitolite-admin/conf/gitolite.conf and adding (trusted) users to this group. WARNING : A gitolite administrator shouldn't include @all into this list. If guest key management is enabled, then also guests would be allowed to add their own keys. Since guest key managers would have no access to those keys, only gitolite administrators would be able to remove those additional keys. In fact, ukm was designed to allow only one key per guest. Don't complain, if you enable a setup where guests can have multiple keys. It's a security issue. (Suppose Alice has added a guest foo@example.org and MrBad generates a new ssh key and adds it under foo@example.org@attacker to the list of his guests. That would give MrBad all the permissions that foo@example.org has.) The system administrator must enable ukm for self key managers in .gitolite.rc by adding UKM_CONGFIG => { SELFKEY_MANAGEMENT => 1, }, to the %RC hash. Since by design self keys start with an @ sign, and thus cannot conflict with guest keys (which are not allowed to start with an @ ), there is no problem to enable self key and guest key management at the same time. UKM_CONFIG => { FORBIDDEN_GUEST_PATTERN => qr(FORBIDDEN-PATTERN), SELFKEY_MANAGEMENT => 1, }, How to use user key management? \uf0c1 There are three subcommands of ukm , namely list (the default), add , and del . Depending on whether or not the respective KEYID starts with an @ sign, ukm distinguishes between guest and self key management. Self keys start with @ and are followed by letters and/or digits. For super key managers there is not such a distinction. Rather, the KEYID is the full path of the actual public key file relative to gitolite-admin/keydir/ with the .pub file extension removed. By convention, take as guest key the proper email address of the guest. That not only makes for a unique ID, it also gives you a hint to whom this key belongs. List managed keys \uf0c1 A guest key manager and self key manager can list all their personally managed keys via: ssh gitserver ukm or ssh gitserver ukm list If this command is issued by a super key manager , it lists all keys that are stored under keydir/ . The result will show the fingerprints of the keys, the corresponding USERID and the KEYID by which one can refer to the key on the commandline. Add a new public key \uf0c1 Add a new key as a super key manager \uf0c1 A super key manager can nearly add any key, but ukm does not accept a different key, i.e., different fingerprint, for the same KEYID . Also a double dot is not allowed in the KEYID . Add a new key as a guest key manager \uf0c1 The command for this is: cat foo.pub | ssh gitserver ukm add foo@example.com There are several situations when the above command fails, i.e., rejects to add the key. The KEYID foo@example.com does not match the pattern given by REQUIRED_GUEST_PATTERN in .gitolite.rc . The KEYID foo@example.com matches the pattern given by FORBIDDEN_GUEST_PATTERN in .gitolite.rc . The public key foo.pub is already known to the system and does not belong to the USERID foo@example.com . The KEYID foo@example.com is already in use and it corresponds to a key with another public key. In other words, ukm will not simply override a key. One has to delete the old key first and then add a new one. The KEYID contains a / character or two @ characters, i.e., guest key managers are not allowed to add multiple keys for one user. Add a new key as a self key manager \uf0c1 Adding a self key is a bit more complicated, since the user must confirm that he/she is in possession of the corresponding private key. The command sequence is as follows. Note that the second call of ssh is done with the key foo and not the default ssh key. cat foo.pub | ssh gitserver ukm add @two > session cat session | ssh -i foo gitserver ukm If you don't want to create an intermediate file call it like this: cat foo.pub | ssh gitserver ukm add @two | (sleep 2; ssh -i foo gitserver ukm) Make sure that the second ssh call only happens after the fist one has done its job. Otherwise you might be asked for a password of the git user on the gitserver . After successfully completing the first ssh call, the new key is scheduled for addition and a session key is returned on stdin. That session key must be used to confirm the addition of the new public key as shown above. Delete a key \uf0c1 A super key manager can delete any key by simply giving its KEYID in a command like this ssh gitserver ukm del some/dir/foo@example.com The ukm command, however, prevents a super key manager from removing his/her last key. Delete a guest key \uf0c1 The command for this is: ssh gitserver ukm del foo@example.com If the given KEYID is not among the managed keys of the user who issues the del command, the command will fail. IMPORTANT! You should not forget to remove from all of your repositories all the permissions you gave to foo@example.com , because this key might still be managed by another guest key manager . You might want to run ssh gitserver info -lc \\ | perl -e 'chomp($u=<>);$u=~s/hello //;$u=~s/,.*$//;' \\ -e 'while(<>){if(/\\s(\\S+)\\s+$u$/){print \"$1\\n\"}}' \\ | while read r; do ssh gitserver perms $r - WRITERS foo@example.com; done Repeat this for other roles such as READERS instead of WRITERS . Delete a self key \uf0c1 The command for this is: ssh gitserver ukm del @two ssh gitserver ukm del @two Yes, you have to give that command twice. The first call will bring the key @two into a \"pending-del\" state. The second time, the command will only delete the key @two , if the login was not done with exactly that key. If logging in with the key corresponding to @two , it will bring back the @two key from its \"pending-del\" state to a non-pending state. Note: This safety net is not absolutely necessary, since a self key manager is not allowed to delete his/her initial key (added by the gitolite administrator ). The command ukm wants to make sure that the user still has a key that can be used for login. (Think about having lost the passphrase for the initial key. -- Maybe this over complication will be simplified in the future. Losing a passphrase is not a good excuse and should result in removal of the corresponding key from the system, i.e., contacting the gitolite administrator .) Generic Errors \uf0c1 Key management is done via creating a temporary clone of the gitolite-admin repository, changing, committing, and pushing back. In cases where two people are trying to modify the gitolite-admin repository at the same time, one of the push commands will most probably fail. Then simply redo the command after a while. Glossary \uf0c1 sysadmin : A person who is able to edit the .gitolite.rc file on the server machine. gitolite administrator : A user with write access to the gitolite-admin repositoriy. super key manager : A user who has write access to the keydir/ inside the gitolite-admin repository. A gitolite administrator is always a super key manager. Super key managers have no restriction on how KEYIDs must look like. They can do (nearly) everything inside keydir/ that a gitolite administrator can do when pushing to the gitolite-admin repository directly. guest key manager : A user who is a member of the @guest-key-managers group. A guest key manager can manage a set of guest keys. self key manager : A user who is a member of the @self-key-managers group. A self key manager can manage a set of his/her own keys. KEYID : an identifier for a key given on the command line The KEYID is normalized to lowercase letters. If the script is called by one of the super key managers, then the KEYID is the path to the pubkey file relative to the keydir/ without the .pub extension. If called by a guest key manager it's an email address and if called by a self key manager, it's an alphanumeric identifier with an @ prepended. USERID : The KEYID given on the command line will be translated into a USERID which is used inside conf/gitolite.conf or for the perms command of gitolite. Security note \uf0c1 Super key managers can basically add any key. Guest key managers are not allowed to add multiple keys and this restriction is hardcoded. Suppose Alice adds bob.pub as bob@example.org and David adds eve.pub under the keyid bob@example.org@foo . (Of course, only Eve and not Bob has the private key correspoinding to eve.pub .) This basically gives Eve the same rights as Bob. Important notes for the admin \uf0c1 Note that ukm clones, changes, and pushes back the gitolite-admin repo. This means, even if you are the only administrator, you should never git push -f , because that might override something ukm did. Ideas \uf0c1 The command ukm has been created with also having the keysubdirs-as-groups syntactic sugar in mind. If a super key manager manages the respective keys in sub-directories with names guest-key-managers/ and self-key-managers/ , respectively, he/she can use the ukm command to control who is allowed to manage keys.","title":"User key management"},{"location":"contrib/ukm.html#user-key-management","text":"Copyright 2012-2013 Ralf Hemmecke ralf@hemmecke.org . Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License User key management allows certain users to add and remove keys. The key management is done using a command called ukm . This command must be enabled for remote use by both the sysadmin and the gitolite-admin (see here for more on this) or look below.","title":"user key management"},{"location":"contrib/ukm.html#important-warning","text":"User key management undermines the fundamental principle of gitolite (see authentication versus authorisation ) by allowing certain users to juggle with ssh public keys. Make sure someone (sysadmin?) can login to the server with a password , just in case something breaks and the .ssh/authorized_keys file for the user running gitolite on the server is messed up.","title":"Important Warning!"},{"location":"contrib/ukm.html#general-note","text":"Although gitolite deals in its core only with authorisation, by default it uses ssh as its authentication mechanism. Sure, ssh is not at all part of gitolite and it can be replaced by other means, but still there is a directory gitolite-admin/keydir that is reserved for public ssh keys. In fact, management of users and multiple keys per user is not actually a gitolite administration stuff. It's external to gitolite. In a future version, ukm could be used as an equivalent of the keydir/ directory from the gitolite-admin repo (currently it just manages that directory) and thus ukm could be seen as such an external tool that does what its name suggests: user (key) management. In the following description we assume that there is an entry like Host gitserver IdentityFile ~/.ssh/id_rsa # choose your gitolite key here HostName gitolite.example.org # location where gitolite is installed User git # user that runs gitolite in the client's ~/.ssh/config file.","title":"General note"},{"location":"contrib/ukm.html#who-might-be-interested","text":"","title":"Who might be interested?"},{"location":"contrib/ukm.html#the-gitolite-admin","text":"Adding a new public key to the system means to copy the key into gitolite/keydir commit and push. With ukm it would be cat FOO.PUB | ssh gitserver ukm add KEYID This would be a setup where only the gitolite administrator uses ukm . Not a big benefit, but ukm prevents adding identical keys under different userids. This consistency check might be an advantage. Furthermore, ukm does not allow the gitolite administrator to remove his/her last, i.e., it prevents the administrator from locking him-/herself out of the system. (Note, we assume that the gitolite administrator has no shell access to the server; only the sysadmin has shell access.)","title":"The gitolite admin"},{"location":"contrib/ukm.html#users-that-want-more-control-over-who-can-access-their-repositories","text":"Suppose the gitolite administrator of a research institute has set up gitolite to provide wild repositories for example with a gitolite.conf like this. repo gitolite-admin RW+ = gitadmin # These people are allowed to create wild repositories. @creators = alice bob ... # wildcard repositories for the users repo CREATOR/..* C = @creators RW+ = CREATOR RW = WRITERS R = READERS Researchers Alice and Bob want to write an article together. Alice creates a wild repository alice/article and adds Bob via the perms command to the WRITERS of her repository. After a while they realize that Otto from another institute would be a reasonable third author. However, if they cannot give him write access to the repository, they would have to exchange the article via email. Back to the stone age? Better, Alice asks Otto to send her his public ssh key. Alice then forwards that key to the gitolite administrator and asks him to include that key into the system. (Hopefully, all that didn't happen on a holiday or on the weekend.) After 3 days the gitolite administrater finds some time. Since he doesn't know Otto, he simply trusts Alice and adds the public key into the system. With ukm Alice can save bothering the gitolite administrator and is perhaps even faster in saying: cat otto.pub | ssh gitserver ukm add otto@other.institute.edu ssh gitserver perms alice/article + WRITERS otto@other.institute.edu The effect would be the same.","title":"Users that want more control over who can access their repositories"},{"location":"contrib/ukm.html#users-that-want-to-manage-multiple-keys","text":"Suppose, you have different computers and a different ssh key for each of them. You would like to tell gitolite that all these different keys belong to just one gitolite identity. Your gitolite administrator creates your gitolite identity with one of your keys as your initial key. This key can only be managed by the gitolite administrator, not by you. It basically determines under which name you are known to gitolite. You can add new keys to this identity and remove them at your will.","title":"Users that want to manage multiple keys"},{"location":"contrib/ukm.html#how-to-enable-user-key-management","text":"The ukm command is contributed code and lives under contrib/commands/ukm in the gitolite source tree. A sysadmin of the gitserver has to copy or link this script to the right location. cd src/commands ln -s ../../contrib/commands/ukm . Furthermore, a sysadmin must add the string 'ukm' to the ENABLE array, i.e., ENABLE => [ ..., 'ukm', ... ], in .gitolite.rc . (That's the preferred way for gitolite starting with version v3.4.) Instead of the above (in particular in gitolite v3.0-v3.3), add 'ukm' => 1 to the COMMANDS hash. COMMANDS => {..., 'ukm' => 1, ... },","title":"How to enable user key management?"},{"location":"contrib/ukm.html#how-to-configure-user-key-management-and-who-can-use-it","text":"As described above there are three main use cases for ukm . Each of them requires different values in the respective config files. There are two files where ukm must be configured. .gitolite.rc (managed by a sysadmin of the gitserver) gitolite-admin/conf/gitolite.conf (managed by a gitolite administrator ) Besides sysadmin and gitolite administrator , ukm knows 3 roles. super key manager guest key manager self key manager","title":"How to configure user key management and who can use it?"},{"location":"contrib/ukm.html#super-key-managers","text":"When ukm is enabled, nothing else must be configured.","title":"Super key managers"},{"location":"contrib/ukm.html#guest-key-managers","text":"The gitolite administrator defines guest key managers by creating a group @guest-key-managers in gitolite-admin/conf/gitolite.conf and adding (trusted) users to this group. WARNING : If the gitolite administrator includes @all into this list, it allows guests to add new public keys. If, additionally, there is @creators=@all , it basically allows the initial guest key managers to start a hierarchy of new users with the same rights as the initial users. The system administrator must configure ukm for guest key managers in .gitolite.rc by adding something like UKM_CONFIG => { FORBIDDEN_GUEST_PATTERN => qr(FORBIDDEN-PATTERN), }, to the %RC hash. If FORBIDDEN_GUEST_PATTERN is missing, it defaults to the following. FORBIDDEN_GUEST_PATTERN => qr(.) Any KEYID that matches this pattern is rejected, i.e., the default value basically allows only the super key managers to add/del keys. If ukm is supposed to work for guest key managers , FORBIDDEN_GUEST_PATTERN must be set to some reasonable value. If your company has email addresses of the form first.last@company.com you might want to write something like this UKM_CONFIG => { FORBIDDEN_GUEST_PATTERN => qr(@company.com$) }, which would only allow KEYIDs in the form of email addresses that do not come from your company. For the very brave only!!! The variable REQUIRED_GUEST_PATTERN is optional. It is strongly discouraged to set it. However, if you know, what you are doing, it allows for a bit more flexibility. Don't complain if you modify the default value!!! REQUIRED_GUEST_PATTERN defaults to a regular expression that only allows KEYIDs in the form of email addresses (see the source code if you want to see this regular expression). You can write UKM_CONFIG => { REQUIRED_GUEST_PATTERN => qr(REQUIRED-PATTERN), FORBIDDEN_GUEST_PATTERN => qr(FORBIDDEN-PATTERN), }, with the meaning that the KEYID must match qr(^(REQUIRED-PATTERN)$) (note that ^ and $ are automatically added to the pattern) and must not match qr(FORBIDDEN-PATTERN) in order for ukm to proceed with this KEYID for a guest key manager . Gitolite's namespace for USERIDs is flat. The REQUIRED_GUEST_PATTERN and FORBIDDEN_GUEST_PATTERN serve two purposes. Restrict permissions for what guest key managers can do. Patterns that cannot be used for guests can still be used by super key managers . In other words, those patterns are reserved for in-house USERIDs .","title":"Guest key managers"},{"location":"contrib/ukm.html#self-key-managers","text":"The gitolite administrator defines self key managers by creating a group @self-key-managers in gitolite-admin/conf/gitolite.conf and adding (trusted) users to this group. WARNING : A gitolite administrator shouldn't include @all into this list. If guest key management is enabled, then also guests would be allowed to add their own keys. Since guest key managers would have no access to those keys, only gitolite administrators would be able to remove those additional keys. In fact, ukm was designed to allow only one key per guest. Don't complain, if you enable a setup where guests can have multiple keys. It's a security issue. (Suppose Alice has added a guest foo@example.org and MrBad generates a new ssh key and adds it under foo@example.org@attacker to the list of his guests. That would give MrBad all the permissions that foo@example.org has.) The system administrator must enable ukm for self key managers in .gitolite.rc by adding UKM_CONGFIG => { SELFKEY_MANAGEMENT => 1, }, to the %RC hash. Since by design self keys start with an @ sign, and thus cannot conflict with guest keys (which are not allowed to start with an @ ), there is no problem to enable self key and guest key management at the same time. UKM_CONFIG => { FORBIDDEN_GUEST_PATTERN => qr(FORBIDDEN-PATTERN), SELFKEY_MANAGEMENT => 1, },","title":"Self key managers"},{"location":"contrib/ukm.html#how-to-use-user-key-management","text":"There are three subcommands of ukm , namely list (the default), add , and del . Depending on whether or not the respective KEYID starts with an @ sign, ukm distinguishes between guest and self key management. Self keys start with @ and are followed by letters and/or digits. For super key managers there is not such a distinction. Rather, the KEYID is the full path of the actual public key file relative to gitolite-admin/keydir/ with the .pub file extension removed. By convention, take as guest key the proper email address of the guest. That not only makes for a unique ID, it also gives you a hint to whom this key belongs.","title":"How to use user key management?"},{"location":"contrib/ukm.html#list-managed-keys","text":"A guest key manager and self key manager can list all their personally managed keys via: ssh gitserver ukm or ssh gitserver ukm list If this command is issued by a super key manager , it lists all keys that are stored under keydir/ . The result will show the fingerprints of the keys, the corresponding USERID and the KEYID by which one can refer to the key on the commandline.","title":"List managed keys"},{"location":"contrib/ukm.html#add-a-new-public-key","text":"","title":"Add a new public key"},{"location":"contrib/ukm.html#add-a-new-key-as-a-super-key-manager","text":"A super key manager can nearly add any key, but ukm does not accept a different key, i.e., different fingerprint, for the same KEYID . Also a double dot is not allowed in the KEYID .","title":"Add a new key as a super key manager"},{"location":"contrib/ukm.html#add-a-new-key-as-a-guest-key-manager","text":"The command for this is: cat foo.pub | ssh gitserver ukm add foo@example.com There are several situations when the above command fails, i.e., rejects to add the key. The KEYID foo@example.com does not match the pattern given by REQUIRED_GUEST_PATTERN in .gitolite.rc . The KEYID foo@example.com matches the pattern given by FORBIDDEN_GUEST_PATTERN in .gitolite.rc . The public key foo.pub is already known to the system and does not belong to the USERID foo@example.com . The KEYID foo@example.com is already in use and it corresponds to a key with another public key. In other words, ukm will not simply override a key. One has to delete the old key first and then add a new one. The KEYID contains a / character or two @ characters, i.e., guest key managers are not allowed to add multiple keys for one user.","title":"Add a new key as a guest key manager"},{"location":"contrib/ukm.html#add-a-new-key-as-a-self-key-manager","text":"Adding a self key is a bit more complicated, since the user must confirm that he/she is in possession of the corresponding private key. The command sequence is as follows. Note that the second call of ssh is done with the key foo and not the default ssh key. cat foo.pub | ssh gitserver ukm add @two > session cat session | ssh -i foo gitserver ukm If you don't want to create an intermediate file call it like this: cat foo.pub | ssh gitserver ukm add @two | (sleep 2; ssh -i foo gitserver ukm) Make sure that the second ssh call only happens after the fist one has done its job. Otherwise you might be asked for a password of the git user on the gitserver . After successfully completing the first ssh call, the new key is scheduled for addition and a session key is returned on stdin. That session key must be used to confirm the addition of the new public key as shown above.","title":"Add a new key as a self key manager"},{"location":"contrib/ukm.html#delete-a-key","text":"A super key manager can delete any key by simply giving its KEYID in a command like this ssh gitserver ukm del some/dir/foo@example.com The ukm command, however, prevents a super key manager from removing his/her last key.","title":"Delete a key"},{"location":"contrib/ukm.html#delete-a-guest-key","text":"The command for this is: ssh gitserver ukm del foo@example.com If the given KEYID is not among the managed keys of the user who issues the del command, the command will fail. IMPORTANT! You should not forget to remove from all of your repositories all the permissions you gave to foo@example.com , because this key might still be managed by another guest key manager . You might want to run ssh gitserver info -lc \\ | perl -e 'chomp($u=<>);$u=~s/hello //;$u=~s/,.*$//;' \\ -e 'while(<>){if(/\\s(\\S+)\\s+$u$/){print \"$1\\n\"}}' \\ | while read r; do ssh gitserver perms $r - WRITERS foo@example.com; done Repeat this for other roles such as READERS instead of WRITERS .","title":"Delete a guest key"},{"location":"contrib/ukm.html#delete-a-self-key","text":"The command for this is: ssh gitserver ukm del @two ssh gitserver ukm del @two Yes, you have to give that command twice. The first call will bring the key @two into a \"pending-del\" state. The second time, the command will only delete the key @two , if the login was not done with exactly that key. If logging in with the key corresponding to @two , it will bring back the @two key from its \"pending-del\" state to a non-pending state. Note: This safety net is not absolutely necessary, since a self key manager is not allowed to delete his/her initial key (added by the gitolite administrator ). The command ukm wants to make sure that the user still has a key that can be used for login. (Think about having lost the passphrase for the initial key. -- Maybe this over complication will be simplified in the future. Losing a passphrase is not a good excuse and should result in removal of the corresponding key from the system, i.e., contacting the gitolite administrator .)","title":"Delete a self key"},{"location":"contrib/ukm.html#generic-errors","text":"Key management is done via creating a temporary clone of the gitolite-admin repository, changing, committing, and pushing back. In cases where two people are trying to modify the gitolite-admin repository at the same time, one of the push commands will most probably fail. Then simply redo the command after a while.","title":"Generic Errors"},{"location":"contrib/ukm.html#glossary","text":"sysadmin : A person who is able to edit the .gitolite.rc file on the server machine. gitolite administrator : A user with write access to the gitolite-admin repositoriy. super key manager : A user who has write access to the keydir/ inside the gitolite-admin repository. A gitolite administrator is always a super key manager. Super key managers have no restriction on how KEYIDs must look like. They can do (nearly) everything inside keydir/ that a gitolite administrator can do when pushing to the gitolite-admin repository directly. guest key manager : A user who is a member of the @guest-key-managers group. A guest key manager can manage a set of guest keys. self key manager : A user who is a member of the @self-key-managers group. A self key manager can manage a set of his/her own keys. KEYID : an identifier for a key given on the command line The KEYID is normalized to lowercase letters. If the script is called by one of the super key managers, then the KEYID is the path to the pubkey file relative to the keydir/ without the .pub extension. If called by a guest key manager it's an email address and if called by a self key manager, it's an alphanumeric identifier with an @ prepended. USERID : The KEYID given on the command line will be translated into a USERID which is used inside conf/gitolite.conf or for the perms command of gitolite.","title":"Glossary"},{"location":"contrib/ukm.html#security-note","text":"Super key managers can basically add any key. Guest key managers are not allowed to add multiple keys and this restriction is hardcoded. Suppose Alice adds bob.pub as bob@example.org and David adds eve.pub under the keyid bob@example.org@foo . (Of course, only Eve and not Bob has the private key correspoinding to eve.pub .) This basically gives Eve the same rights as Bob.","title":"Security note"},{"location":"contrib/ukm.html#important-notes-for-the-admin","text":"Note that ukm clones, changes, and pushes back the gitolite-admin repo. This means, even if you are the only administrator, you should never git push -f , because that might override something ukm did.","title":"Important notes for the admin"},{"location":"contrib/ukm.html#ideas","text":"The command ukm has been created with also having the keysubdirs-as-groups syntactic sugar in mind. If a super key manager manages the respective keys in sub-directories with names guest-key-managers/ and self-key-managers/ , respectively, he/she can use the ukm command to control who is allowed to manage keys.","title":"Ideas"}]}