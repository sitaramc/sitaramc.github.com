<head>
<title>HTML Slidy</title>
<base href="http://sitaramc.github.com/" />
<link rel="stylesheet" href="../tools/slidy.css" type="text/css">
<meta name="font-size-adjustment" content="3">
<script src="../tools/slidy.js" charset="utf-8" type="text/javascript">
</script>
</head>
<body>

<div class="slide cover">
<center>
<br/>
<br/>
<br/>
<br/>
<img src="tools/git.png">
<br/>
<br/>
<br/>
<br/>
<h1>presentation on git, a DVCS</h1>
<br/>
<br/>


</center>
</div>

<h1>why</h1>

<p><center><img src="images/projects-sans-vcs.png"></center>
</p>

<h1>why use a VCS</h1>

<ul>
<li>reversibility or rollback, aka C-Y-A!
<ul>
<li>linear (on the time axis), simple to implement</li>
</ul></li>
<li>concurrency
<ul>
<li>non-linear, all the complexity is here</li>
<li>make or break productivity
<ul>
<li>individual productivity also, if it can make context switching
trivial</li>
</ul></li>
</ul></li>
<li>annotation</li>
</ul>

<h1>VCSs in common use</h1>

<ul>
<li>open source
<ul>
<li>CVS</li>
<li>SVN (Subversion)</li>
<li>Darcs/TLA/Bazaar/Monotone, Mercurial, Git</li>
</ul></li>
<li>proprietary
<ul>
<li>VSS, Clearcase, Perforce</li>
<li>Bitkeeper</li>
<li>others??</li>
</ul></li>
</ul>

<h1>"distributed"?</h1>

<ul>
<li>every dev has his/her own repository
<ul>
<li>on their own workstation</li>
<li>no single point of failure/contention</li>
</ul></li>
<li>all repos are (usually) "clones" of the central repository</li>
<li>easy to work offline
<ul>
<li>e.g., long weekend+laptop :-)</li>
<li>commits made while offline retain their identity</li>
<li>they don't get collapsed into one big commit</li>
</ul></li>
<li>commit-then-merge, not merge-then-commit</li>
</ul>

<h1>what's different about git?</h1>

<ul>
<li>cryptographically secure integrity checks builtin</li>
<li>fast
<ul>
<li>most operations are local</li>
<li>network operations are highly optimised</li>
<li><strong>ideal</strong> for distributed teams</li>
</ul></li>
<li>easy to setup/deploy
<ul>
<li>server requires minimal hardware</li>
<li>no license costs</li>
</ul></li>
</ul>

<h1>what's different about git? (cont'd)</h1>

<ul>
<li>very small repo size
<ul>
<li>Mozilla repo in CVS: 2.7 GB</li>
<li>imported to SVN 8.2 GB</li>
<li>imported to GIT: 450 MB!</li>
<li>(a full checkout is 350 MB)</li>
</ul></li>
<li>very, very, cheap branching</li>
<li>excellent merging</li>
</ul>

<h1>caveats about git</h1>

<ul>
<li>no partial checkouts -- it's the whole project or nothing
<ul>
<li>but you can use the "submodule" mechanism if you know in advance what
pieces will be separately needed</li>
</ul></li>
<li>will not track
<ul>
<li>permissions and ownership, except the "x" (executable) bit
<ul>
<li>in unix terms, only cares about the first "x" in rwxrwxrwx</li>
</ul></li>
<li>empty directories</li>
</ul></li>
<li>not optimised for tracking <strong>very large</strong> binary files (movies, etc.)</li>
</ul>

<h1>history</h1>

<ul>
<li>initially designed as a file system!</li>
<li>originally only a backend, now all in one</li>
<li>reputation for being hard to use, now no longer valid</li>
<li>focus on large projects with many developers
<ul>
<li>but that doesn't mean small projects can't use it</li>
<li>remember: multi-tasking</li>
</ul></li>
</ul>

<h1>working with git</h1>

<ul>
<li>CLI is the most powerful</li>
<li>don't like the CLI?
<ul>
<li>3 excellent GUI tools come with git</li>
<li>very powerful; for an excellent intro to these tools, see
http://nathanj.github.com/gitguide</li>
<li>plugins: Eclipse and VS plugins available</li>
<li>but you miss many features <strong>unique</strong> to git if you only use these
plugins</li>
</ul></li>
</ul>

<h1>some mindset changes needed...</h1>

<ul>
<li>learn to make many fine-grained commits rather than a few large ones</li>
<li>commit locally before performing any remote operations
<ul>
<li>example, in the typical "svn update" scenario, if your changes are not
yet ready to be sent to the server, you can either
<ul>
<li>avoid doing the update</li>
<li>do it and pray :-)</li>
</ul></li>
<li>in git, you just commit locally before doing the "git pull"</li>
</ul></li>
</ul>

<h1>normal workflow - CVCSs</h1>

<p><center><img src="images/flow-CVCS.png"></center>
</p>

<h1>normal workflow - most DVCSs</h1>

<p><center><img src="images/flow-DVCS.png"></center>
</p>

<h1>normal workflow - Git</h1>

<p><center><img src="images/flow-Git.png"></center>
</p>

<h1>something unique to git</h1>

<ul>
<li>index
<ul>
<li>a staging area for the next commit</li>
<li>stuff gets sent here when you "add"</li>
<li>when you "commit", the current index is turned into a real commit
object</li>
</ul></li>
<li>helps in reviewing changes</li>
<li>helps when fixing conflicts during a complex merge</li>
</ul>

<h1>problems in SVN</h1>

<ul>
<li>slow on large repositories</li>
<li>.SVN directories all over the place
<ul>
<li>often as large as the entire git repo!</li>
</ul></li>
<li>refactor/rename support missing</li>
<li>branching is fine...
<ul>
<li>but merging...?</li>
</ul></li>
</ul>

<h1>problems in SVN (cont'd)</h1>

<ul>
<li>merge tracking not very well done
<ul>
<li>does not record who did the branch (attributes all changes to the dev
who did the merge)</li>
<li>does not record "merge-only" changes separately from the two branches</li>
<li>can make repeated merges very difficult
<ul>
<li>SVN mergeinfo has many limitations</li>
</ul></li>
</ul></li>
<li>merges can be slow</li>
<li>large merges can be painful</li>
</ul>

<h1>branching in most older VCSs</h1>

<ul>
<li>branching is considered advanced and people avoid it
<ul>
<li>either the tool has no branching,</li>
<li>or has really bad merging</li>
</ul></li>
<li>and branching is useless without good merging</li>
<li>so lots of parallelism goes unused
<ul>
<li>or you need "SCM admins" to do the merge!</li>
</ul></li>
</ul>

<h1>problems in SVN (cont'd)</h1>

<ul>
<li>lack of local commits
<ul>
<li>you don't want to "break the build"</li>
<li>so you keep lots of uncommitted changes outside the VCS</li>
<li>and do one big checkin when you're ready</li>
</ul></li>
</ul>

<h1>productivity advantages of git</h1>

<ul>
<li>history tracking handled much better; makes repeated merges a breeze
<ul>
<li>all "commits" identified by a SHA-1 checksum
<ul>
<li>this is what gives it the cryptographically secure integrity
check)</li>
</ul></li>
<li>a branch is just a pointer to some commit</li>
<li>every commit records its parent commit's sha</li>
<li>a merge is just a commit with more than one parent commit</li>
</ul></li>
<li>so, every commit knows all of its ancestors
<ul>
<li>regardless of repository, branch, etc</li>
</ul></li>
</ul>

<h1>Linus on merging</h1>

<ul>
<li>merging is the most important activity
<ul>
<li>"I merge 22,000 files several times a day, and I get unhappy if a
merge takes more than 5 seconds" -- Linus</li>
<li>the linux kernel has 22000 files and has averaged 4.5 merges/day over
the last 2 years</li>
</ul></li>
</ul>

<h1>Linus on merging (cont'd)</h1>

<ul>
<li>make it fast and painless
<ul>
<li>...and people will start using it every day</li>
</ul></li>
<li>merge often, merge early</li>
<li>otherwise you have huge conflicts to resolve later!</li>
</ul>

<h1>productivity advantages of git (cont'd)</h1>

<ul>
<li>complex merges handled much better; frees devs from worrying about it most
of the time
<ul>
<li>merges involving renames</li>
<li>criss-cross merges</li>
</ul></li>
<li>encourages many small commits instead of few large commits
<ul>
<li>easier code reviews</li>
<li>easier debugging</li>
<li>easier cherry picking</li>
<li>easier merging/rebasing (conflict resolution happens in much smaller
units)</li>
</ul></li>
</ul>

<h1>productivity advantages of git (cont'd)</h1>

<ul>
<li>encourages creating local branches
<ul>
<li>no need to pollute the central server</li>
<li>experimental code can be developed "on the side"
<ul>
<li>if it works, promote it to the central server, with the full
history of commits intact</li>
<li>otherwise, delete it; no need to immortalise failed experiments on
the central server :-)</li>
</ul></li>
<li>branch <strong>names</strong> are also local
<ul>
<li>we can all have a branch called "my-test" or "test" or whatever,
without worrying about "is someone else using the same branch
name?"</li>
</ul></li>
</ul></li>
</ul>

<h1>productivity advantages of git (cont'd)</h1>

<ul>
<li>encourages using the tools available
<ul>
<li>important vcs operations (like "diff") do not need network access</li>
<li>blazingly fast
<ul>
<li>even against a very old revision</li>
<li>or a version in some other branch</li>
</ul></li>
<li>centralised VCSs take too long
<ul>
<li>painful to use</li>
<li>so programmers avoid them (?)</li>
</ul></li>
</ul></li>
</ul>

<h1>maintainability -- refactor/rename support</h1>

<ul>
<li>in most VCSs, renaming a file
<ul>
<li>is treated as a copy+delete</li>
<li>loses history (?)</li>
</ul></li>
<li>how about...
<ul>
<li>rename + move + edit a file in one branch</li>
<li>while making some bugfixes to it in another?</li>
</ul></li>
<li>git handles this without any fuss -- demo 09</li>
</ul>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-01.png"></center>
</p>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-02.png"></center>
</p>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-03.png"></center>
</p>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-04.png"></center>
</p>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-05.png"></center>
</p>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-06.png"></center>
</p>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-07.png"></center>
</p>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-08.png"></center>
</p>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-09.png"></center>
</p>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-10.png"></center>
</p>

<h1>demo 09 in pictures</h1>

<p><center><img src="images/demo-09-11.png"></center>
</p>

<h1>maintainability: code movement detection</h1>

<ul>
<li>example
<ul>
<li>move an important function with lots of history to some other file</li>
</ul></li>
<li>what would other VCSs do to the <strong>history</strong>?</li>
<li>next 5 slides show code movement
<ul>
<li>displayed using "git gui blame", one of the 3 GUI tools that come with
git</li>
</ul></li>
</ul>

<h1>code movement detection in pictures</h1>

<p><center><img src="images/gui-blame-1.png"></center>
</p>

<h1>code movement detection in pictures</h1>

<p><center><img src="images/gui-blame-2.png"></center>
</p>

<h1>code movement detection in pictures</h1>

<p><center><img src="images/gui-blame-3.png"></center>
</p>

<h1>code movement detection in pictures</h1>

<p><center><img src="images/gui-blame-4.png"></center>
</p>

<h1>code movement detection in pictures</h1>

<p><center><img src="images/gui-blame-5.png"></center>
</p>

<h1>maintainability: code movement detection (cont'd)</h1>

<ul>
<li>this is <strong>way</strong> beyond what any other VCS can even dream of</li>
<li>great help for new people trying to understand existing code base</li>
<li>here's a secret...
<ul>
<li>the information you see is not <strong>stored</strong> in the repository</li>
<li>it is <strong>computed</strong> on demand, dynamically!</li>
<li>which means you can get the same tracability for all your existing
code
<ul>
<li>simply by converting to git!</li>
</ul></li>
</ul></li>
</ul>

<h1>maintainability: revision history viewer</h1>

<ul>
<li>git has another GUI to show you the version history graph
<ul>
<li>very intuitive, shows merges etc very nicely</li>
<li>lots of "right click" options in various places, to help track things
down...</li>
<li>(one small example follows; there are many, many, more features --
there is not enough time to talk about more!)</li>
</ul></li>
</ul>

<h1>revision history viewer</h1>

<p><center><img src="images/gitk-1.png"></center>
</p>

<h1>revision history viewer</h1>

<p><center><img src="images/gitk-2.png"></center>
</p>

<h1>revision history viewer</h1>

<p><center><img src="images/gitk-3.png"></center>
</p>

<h1>git concepts</h1>

<ul>
<li>repo
<ul>
<li>self-contained; remove ".git" and it's all gone</li>
</ul></li>
<li>branch
<ul>
<li>active line of development</li>
<li>a repo can track any number of branches</li>
</ul></li>
<li>master
<ul>
<li>default branch in a new git project</li>
</ul></li>
</ul>

<h1>concept detail: branches</h1>

<ul>
<li>easy and inexpensive</li>
<li>can have separate branches for separate features</li>
<li>many being worked on "simultaneously"!</li>
<li>you can switch rapidly between branches</li>
<li>boosts individual productivity as well as team productivity</li>
<li>almost all existing VCSs suck at this</li>
</ul>

<h1>git concepts (cont'd)</h1>

<ul>
<li>working tree
<ul>
<li>is associated with only one branch</li>
</ul></li>
<li>head
<ul>
<li>the tip of a branch</li>
</ul></li>
<li>HEAD
<ul>
<li>the tip of the branch associated with your working tree; this is where
commits go</li>
</ul></li>
</ul>

<h1>git concepts (cont'd)</h1>

<ul>
<li>index: holding area for changes approved for commit
<ul>
<li>git tracks content, not files</li>
<li>lets you select some files to commit while postponing others</li>
<li>lets you keep uncommited changes hanging around</li>
</ul></li>
<li>remote</li>
<li>origin</li>
</ul>

<h1>some more git concepts</h1>

<ul>
<li>commit ancestry</li>
<li>commit ancestry as a DAG
<ul>
<li>the essence of git is to build and traverse this DAG</li>
</ul></li>
</ul>

<h1>CVS/SVN equivalence</h1>

<pre><code>    CVS                  GIT
    ---                  ---
    checkout             clone
    update               pull
    checkin              commit + push
    add                  add
    remove               rm
    ???                  mv
</code></pre>

<h1>cool stuff</h1>

<ul>
<li>the reflog, reachability, and garbage collection</li>
<li>demo 10 -- cherry picking</li>
<li>rebase</li>
<li>bisect</li>
<li>stash</li>
</ul>

<h1>demo 10 in pictures</h1>

<p><center><img src="images/demo-10-01.png"></center>
</p>

<h1>demo 10 in pictures</h1>

<p><center><img src="images/demo-10-02.png"></center>
</p>

<h1>demo 10 in pictures</h1>

<p><center><img src="images/demo-10-03.png"></center>
</p>

<h1>rebase -- what and why</h1>

<ul>
<li>what</li>
<li>why
<ul>
<li>parallel and serial branching</li>
<li>getting the best out of bisect</li>
</ul></li>
</ul>

<h1>rebase -- when and how</h1>

<ul>
<li>killing off an old commit</li>
<li>re-arranging your commits interactively -- demo 11</li>
<li><strong>when not to use it!</strong></li>
<li>origin has moved
<ul>
<li>demo 12 -- parallel branch using merge</li>
<li>demo 13 -- serial branch using rebase</li>
</ul></li>
<li>same, but after some of your changes have gone upstream
<ul>
<li>and they have DIFFERENT SHA1s now!!</li>
</ul></li>
</ul>

<h1>demo 11 in pictures</h1>

<p><center><img src="images/demo-11-01.png"></center>
</p>

<ul>
<li>and now we do:
<ul>
<li><code>git rebase -i HEAD~8</code></li>
</ul></li>
</ul>

<h1>demo 11 in pictures</h1>

<p><center><img src="images/demo-11-02.png"></center>
</p>

<h1>demo 11 in pictures</h1>

<p><center><img src="images/demo-11-03.png"></center>
</p>

<h1>demo 11 in pictures</h1>

<p><center><img src="images/demo-11-04.png"></center>
</p>

<h1>demo 11 in pictures</h1>

<p><center><img src="images/demo-11-05.png"></center>
</p>

<h1>demo 11 in pictures</h1>

<p><center><img src="images/demo-11-06.png"></center>
</p>

<h1>demo 12 (normal merge)</h1>

<p><center><img src="images/demo-12-01.png"></center>
</p>

<h1>demo 12 (normal merge)</h1>

<p><center><img src="images/demo-12-02.png"></center>
</p>

<h1>demo 12 (normal merge)</h1>

<p><center><img src="images/demo-12-03.png"></center>
</p>

<h1>demo 12 (normal merge)</h1>

<p><center><img src="images/demo-12-04.png"></center>
</p>

<h1>demo 12 (normal merge)</h1>

<p><center><img src="images/demo-12-05.png"></center>
</p>

<h1>demo 13 (rebase)</h1>

<p><center><img src="images/demo-13-01.png"></center>
</p>

<h1>demo 13 (rebase)</h1>

<p><center><img src="images/demo-13-02.png"></center>
</p>

<h1>demo 13 (rebase)</h1>

<p><center><img src="images/demo-13-03.png"></center>
</p>

<h1>odds and ends</h1>

<ul>
<li>only one ".git" dir at the top</li>
<li>patches and repo updates can be ftp-d or mailed</li>
<li>multi-protocol transport
<ul>
<li>http, ssh, git</li>
</ul></li>
<li>all copies of a repo have the same history
<ul>
<li>universal public identifier (a SHA-1 hash)</li>
<li>entire 2 year history of linux kernel is half the current full size</li>
</ul></li>
</ul>

<h1>summary: what is git optimised for</h1>

<ul>
<li>distributed development</li>
<li>large file sets</li>
<li>complex merges</li>
<li>speculative, trial branches</li>
<li>EXTREME SPEED -- very fast and very robust</li>
</ul>

<h1>Thank you</h1>

<hr />

<h3>Questions?</h3>

<hr />

<hr />
